<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kali配置]]></title>
    <url>%2F2018%2F11%2F15%2FKali%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[系统安装 据博主亲测,Kali从2018年版本开始,再用UltraISO之类的软件制作U盘启动盘来装Kali系统,都会出现下图的问题,百度和google上有很多解决方案,然并卵. 今天偶然发现了一款U盘制作软件—-Rufus,可以去官网 下载,在用Rufus制作启动U盘的时候,选择后U盘和Kali的安装文件,点击开始,这时候只要选择如下图的DD模式,就会正常安装Kali了. 软件安装1. shadowsocks-qt5 身在华夏,当然免不了被墙,而Kali的官方源是国外的服务器,所以,那速度…无法忍受,当然,也可以用国内的源,然后,博主的强迫症发作,因此决定用ss-qt5出去溜达溜达!说起来,现在连ss-qt5都用Appimage这种跨平台的打包方式,我喜欢… 1. github搜索shadowsocks-qt5-&gt;releases-&gt;找到对应执行程序(Appimage)下载即可 2. 可以说,所有的Appimage程序都是用以下的方式运行的1chmod +x Shadoosocks-Qt5-3.0.1-x86_64.AppImage 3. 双击运行,然后加入你服务器的配置就行4. 配置终端fq 终端不支持socks5协议,所以需要借助工具proxychains4 1234567git clone https://github.com/rofl0r/proxychains-ng.gitcd proxychains-ng./configure --prefix=/usr --sysconfdir=/etcmakesudo make installsudo make install-configsudo gedit /etc/proxychains4.conf 2. 显卡驱动 装完Kali,当然得装显卡不懂啊,不然排热扇猛地在转,笔记本很快就没电了.注意:在安装显卡之前,必须要更新完系统,命令如下 123apt updateapt upgrade -yapt dist-upgrade -y 1. 安装 Linux 内核头通过命令uname -a查看自己的内核版本1apt install linux-headers-4.15.0-kali2-amd64 linux-headers-4.15.0-kali2-common linux-headers-4.15.0-kali2-all ps:如果实在没有,可以试试apt install linux-headers-*全部安装 2. 禁用默认使用的显卡驱动 nouveau。在命令行中输入1echo -e "blacklist nouveau\noptions nouveau modeset=0\nalias nouveau off" &gt; /etc/modprobe.d/blacklist-nouveau.conf 应用刚刚的修改并重启系统1update-initramfs -u &amp;&amp; reboot 3. 重启后 nouveau 应该被禁用了。在命令行中输入以下命令来确认 nouveau 被禁用1lsmod |grep -i nouveau 如果输入此命令后未显示任何内容，证明 nouveau 已被成功禁用。 4. 下载 NVIDA 官方驱动到 NVIDA 的官网下载对应型号的驱动 http://www.nvidia.com/Download/index.aspx?lang=en-us ，注意，这里要选择和你显卡硬件型号对应的版本，否则一定失败。比如我的是 GTX960M 的笔记本显卡，所以我的选择如下图： 点击SEARCH 后就可以看到 DOWNLOAD 的按钮了，点击下载就可以了 5. 安装下载好 NVIDA 的显卡驱动文件后，使用以下命令赋予执行权限1chmod a+x NVIDIA-Linux-x86_64-390.67.run 然后使用以下命令安装.注意,安装过程中会提示警告，全部选择 yes。1./NVIDIA-Linux-x86_64-384.98.run 6. 配置安装完成之后,必须要配置一些东西,让Kali知道你使用的是什么显卡驱动,否则可能开机黑屏. 1. 查看显卡BusID1nvidia-xconfig --query-gpu-info | grep &apos;BusID : &apos; | cut -d &apos; &apos; -f6 它应该会显示如下的内容1PCI:2:0:0 这个就是我们需要的 BUS ID 2. 创建一个 /etc/X11/xorg.conf文件1gedit /etc/X11/xorg.conf 然后填入以下内容 123456789101112131415161718192021222324252627Section "ServerLayout"Identifier "layout"Screen 0 "nvidia"Inactive "intel"EndSectionSection "Device"Identifier "nvidia"Driver "nvidia"BusID "PCI:2:0:0"EndSectionSection "Screen"Identifier "nvidia"Device "nvidia"Option "AllowEmptyInitialConfiguration"EndSectionSection "Device"Identifier "intel"Driver "modesetting"EndSectionSection "Screen"Identifier "intel"Device "intel"EndSection 注意,将PCI:2:0:0替换为自己的 BUS ID，保存即可 7. 据我们的显示管理器 (display manager)来创建一些脚本由于我们的 kali 默认使用的是 GDM (Gnome Display Manager)，我们需要创建两个文件：12gedit /usr/share/gdm/greeter/autostart/optimus.desktopgedit /etc/xdg/autostart/optimus.desktop 内容均为123456[Desktop Entry]Type=ApplicationName=OptimusExec=sh -c "xrandr --setprovideroutputsource modesetting NVIDIA-0; xrandr --auto"NoDisplay=trueX-GNOME-Autostart-Phase=DisplayServer 8. 重启系统之后检测是否正常12apt install mesa-utilsglxinfo | grep -i &quot;direct rendering&quot; 如果一切正常,应当显示1direct rendering: Yes 3. 安装输入法 安装 1apt install ibus ibus-pinyin fcitx fcitx-googlepinyin ibus-setup 选择输入法 1Input Method-&gt;Add-&gt;汉语-&gt;pingyin 输入源选择 1设置-&gt;区域和语言-&gt;输入源-&gt;汉语-&gt;拼音 4. 坚果云 国内的Dropbox,不能不用啊!!!然而却没有合适Kali版本的,ubuntu和debian版本我都试过了,用不了,只能用源码了 1234567apt install libglib2.0-dev libgtk2.0-dev libnautilus-extension-dev gvfs-bin openjdk-8-jre-headlesswget http://www.jianguoyun.com/static/exe/installer/nutstore_linux_src_installer.tar.gztar zxf nutstore_linux_src_installer.tar.gzcd nutstore_linux_src_installer &amp;&amp; ./configure &amp;&amp; makemake installnautilus -q./runtime_bootstrap 5. root用户打开chrome 好吧!我也不知道为毛root用户打不开chrome 使用文件管理器打开路径/usr/share/applications/ ，找到google-chrome的图标，鼠标右键打开属性，在命令一栏/usr/bin/google-chrome-stable %U 的后面加上--no-sandbox --user-data-dir &amp;。重新打开chrome即可 6. 终端设置快捷键设置-&gt;设备-&gt;键盘-&gt;命令如下:1gnome-terminal 7. 添加add-apt-repository Kali Linux默认不含add-apt-repository，某些情况下并不方便。可以手动启用它来添加PPA。 首先安装软件属性程序包。 1apt install software-properties-common 接下来安装apt-file。 1apt install apt-file 更新apt-file。 1apt-file update apt-file更新完毕，你应该能够搜索它了。 1apt-file search add-apt-repository 你的输出结果应该看起来类似这样： 12software-properties-common: /usr/bin/add-apt-repositorysoftware-properties-common: /usr/share/man/man1/add-apt-repository.1.gz 模仿Ubuntu，让add-apt-repository正常工作。 12cd /usr/sbingedit add-apt-repository 添加下列代码，并保存文件。 1234567891011121314151617181920212223#!/bin/bashif [ $# -eq 1 ]NM=`uname -a &amp;&amp; date`NAME=`echo $NM | md5sum | cut -f1 -d" "`then ppa_name=`echo "$1" | cut -d":" -f2 -s` if [ -z "$ppa_name" ] then echo "PPA name not found" echo "Utility to add PPA repositories in your debian machine" echo "$0 ppa:user/ppa-name" else echo "$ppa_name" echo "deb http://ppa.launchpad.net/$ppa_name/ubuntu xenial main" &gt;&gt; /etc/apt/sources.list apt-get update &gt;&gt; /dev/null 2&gt; /tmp/$&#123;NAME&#125;_apt_add_key.txt key=`cat /tmp/$&#123;NAME&#125;_apt_add_key.txt | cut -d":" -f6 | cut -d" " -f3` apt-key adv --keyserver keyserver.ubuntu.com --recv-keys $key rm -rf /tmp/$&#123;NAME&#125;_apt_add_key.txt fielse echo "Utility to add PPA repositories in your debian machine" echo "$0 ppa:user/ppa-name"fi 注意：在echo “deb http://ppa.launchpad.net/$ppa_name/ubuntu xenial main” &gt;&gt; /etc/apt/sources.list 这一行中，我使用了xenial，也就是ubuntu 16.04。你可以根据自己的选择，更改其他代号。现在，使用chmod和chown这两个命令，对文件进行相应的操作。 12chmod +x /usr/sbin/add-apt-repositorychown root:root /usr/sbin/add-apt-repository 接下来就可以使用add-apt-repository，添加PPA软件库。我试着输入下面这些命令，安装ssqt5。123add-apt-repository ppa:hzwhuang/ss-qt5apt updateapt install shadowsocks-qt5]]></content>
      <categories>
        <category>Linux</category>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>kali显卡</tag>
        <tag>kali系统安装</tag>
        <tag>kali安装ss-qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt遇到的一些坑]]></title>
    <url>%2F2018%2F11%2F15%2FQt%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[记得重新构建所有项目 Could not determine which “make” command to run问题12321:48:20: Could not determine which &quot;make&quot; command to run. Check the &quot;make&quot; step in the build configuration.Error while building/deploying project MarkdownPic (kit: Desktop Qt 5.11.1 GCC 64bit)When executing step &quot;qmake&quot; 解决 1sudo apt install cmake g++ gcc gdb 然后打开qtcreator-&gt;工具-&gt;选项-&gt;构建和运行-&gt;构建套件kit-&gt;自动检测的其中一项-&gt;编译器，给C++也选择一个即可 cannot find -IGL解决1sudo apt install libgl1-mesa-dev CURL_OPENSSL_3问题1usr/lib/x86_64-linux-gnu/libcurl.so.4: version `CURL_OPENSSL_3&apos; not found 解决123456# 先试一下下面的sudo apt-get install libcurl4-openssl-dev# 不行再用以下的apt remove -y libcurl4apt install -y libcurl4 curl 编译提示缺少openssl目录下一些问题件问题： 解决1sudo apt install libssl-dev]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>IGL</tag>
        <tag>CURL_OPENSSL_3</tag>
        <tag>Openssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt5安装]]></title>
    <url>%2F2018%2F11%2F15%2FQt5%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Windows1. 安装Qt5 点击进入Qt官网下载Qt5,这里我下载的是最新版的Qt5.11,windows平台. tips:由于文件比较大,最好右键-&gt;复制链接地址-&gt;打开迅雷,用迅雷下载 下载完成后,双击安装 有三个地方要注意 让你注册登录的时候,可以Skip跳过 自行修改安装路径最好是英文的 选择安装组件的时候,要Select All 然后就是一路Next,最后Install了. tips:博主在安装过程中,会弹出一个Installer Error的警告,本人是直接点Ignore的,忽略此警告 最后,点击Finish完成 自此,Qt5的安装完毕 2. 配置Qt5的环境2.1 安装windbg 默认情况下是没有调试器的，必须手动下载 下载调试器windbg,在安装过程中,只勾选Debugging Tools for Windows,其他不选 2.2 验证 打开 Qt Creator，工具-&gt;选项-&gt;构建和运行-&gt;编译器,进入编译器部分，可以看到 Qt 已经自动检测出来了，不需要手动配置 而构建套件(Kit)中,已经自动检测出来调试器了 3. VS2017配置3.1 安装插件Qt VIsual Studio Tools 打开VS2017-&gt;工具-&gt;扩展和更新 联机-&gt;搜索框输入Qt-&gt;Qt Visual Studio Tools-&gt;下载,然后就会自动安装了,安装完成会提示重启VS2017 重启vs2017后,就会看到Qt VS Tools菜单项了 3.2 插件配置Qt VS Tools-&gt;Qt Options-&gt;Add-&gt; 4. Helloworld 配置好vs和qt的环境之后,接下来就是测试了,入门第一课:Hello World 打开vs2017-&gt;文件-&gt;新建-&gt;项目-&gt;Visual C++-&gt;Qt-&gt;Qt GUI Application-&gt;修改项目名称和位置-&gt;确定 tips: 要是发现自己没有Visual C++,右键开始菜单-&gt;应用和功能-&gt;Visual Studio Professional 2017-&gt;修改-&gt;找到使用C++的桌面开发-&gt;点击修改即可 然后就是一路默认就行 这时候,打开main.cpp,如下12345678910#include "QtHelloWorld.h"#include &lt;QtWidgets/QApplication&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); QtHelloWorld w; w.show(); return a.exec();&#125; 因为我们要打印一个hello world,所以说,简单改一下main.cpp代码,如下1234567891011#include &lt;QtWidgets/QApplication&gt;#include &lt;QLabel&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); QLabel label("hello world"); label.show(); return a.exec();&#125; 结果如下: Ubuntu1. 安装pyqt5123sudo apt install pyqt5*sudo apt install qt5-defaultsudo apt install qttools5-dev-tools 2. 设置QtDesigner 打开pycharm后点击File- &gt; setting - &gt; Tools- &gt; External Tools, 点击 + 号添加两个文件 第一个文件—-QtDesigner12/usr/bin/designer # 填入Program$FileDir$ # 填入Working directory 第二个文件—-PyUIC123/usr/bin/python3 # 填入Program-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py # 填入Arguments$FileDir$ # 填入Working direction 使用 在pycharm中的下拉菜单Tools中的Qt5就能看到刚刚定义的两个工具]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt5安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt打包]]></title>
    <url>%2F2018%2F11%2F15%2FQt%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Windows打包 首先我们是生成Release离线文件 找到项目文件夹下生成的exe文件,如我的是MarkdownPic.exe,将该exe文件复制到一个新的文件夹,比如我将其复制到C:\Users\13612\Dropbox\HMP目录下 开始菜单搜索qt,然后找到Qt 5.11.0 for Desktop,打开运行,如下图 cd到C:\Users\13612\Dropbox\HMP目录 ps:windows下,要先使用C:,切换到C盘,然后才能cd到C盘的子目录 然后执行如下命令进行打包1windeployqt MarkdownPic.exe 然后就可以看到如下效果,当然,如果你没有使用第三方的库,这个时候,你可以直接双击MarkdownPic.exe运行了,如果你使用了第三方的库,运行的时候会提示你缺少一些库文件,缺啥补啥就行 比如我使用了七牛云,就会出现如下的提示 将dll全部复制到HMP目录下,就可以正常运行了 接下来就是程序发布阶段,我使用的是Enigma Virtual Box,它可以将所有东西压缩到一个文件里面.操作如下(1) Browse-&gt;要打包程序,这里是MarkdownPic.exe (2) 将HMP目录下所有文件拖动到Enigma Virtual Box上,拖完后会弹框,选择OK即可,如下图 (3) 选择Files Options-&gt;勾选Compress Files (4) 点击Process开始 (5) 打包完成,如下图,程序打包成了MarkdownPic_boxed.exe,可以拿这个exe去发布了,其他的文件都没有用了. Linux打包成Appimage Release模式下生成离线文件 将其复制到一个空文件夹，这里是fabuHMP，然后cd到fabuHMP下 使用ldd命令查看依赖库，发现有一个libqiniu.so不是系统自带的库，是第三方库，因此ldd命令在系统库那里找不到，需要添加环境变量，命令如下 1234# 用法如下：export LD_LIBRARY_PATH=/Path/To/Lib:$LD_LIBRARY_PATH# 我的是如下export LD_LIBRARY_PATH=/home/hua/Dropbox/MarkdownPic/MarkdownPic-linux:$LD_LIBRARY_PATH 此时再执行ldd MarkdownPic，发现可以找到libqiniu.so库了 下一步的操作是将所有的依赖库都复制到fabuHMP目录下，一个个复制粘贴太复杂，因此，需要用到shell脚本，如下12345678#!/bin/bashexe="MarkdownPic" # 发布的程序名称des="/home/hua/fabuHMP" # 你的发布程序存放路径# 将 /home/hua/Dropbox/MarkdownPic/MarkdownPic-linux 替换成第三方库所在位置export LD_LIBRARY_PATH=/home/hua/Dropbox/MarkdownPic/MarkdownPic-linux:$LD_LIBRARY_PATHdeplist=$(ldd $exe | awk '&#123;if (match($3,"/"))&#123; printf("%s "),$3 &#125; &#125;')cp $deplist $des 这时候，所以的依赖库都复制到fabuHMP目录下了 添加qmake环境,编辑.bashrc文件1gedit ~/.bashrc` 在最后添加如下代码1234#add QT ENVexport PATH=/home/hua/Qt5.11.1/5.11.1/gcc_64/bin:$PATHexport LD_LIBRARY_PATH=/home/hua/Dropbox/MarkdownPic/MarkdownPic-linux:$LD_LIBRARY_PATHexport QT_PLUGIN_PATH=/home/hua/Qt5.11.1/5.11.1/gcc_64/plugins:$QT_PLUGIN_PATH 重新打开一个终端，运行qmake -v,可以看到如下图则成功 下载linuxdeployqt打开下载linuxdeployqt 重命名为 linuxdeployqt,并赋予可执行权限12sudo mv linuxdeployqt-continuous-x86_64.AppImage linuxdeployqtchmod +x linuxdeployqt 移动到目录 /usr/bin1sudo mv linuxdeployqt /usr/bin 这时候终端执行linuxdeployqt可看到用法 执行如下命令即可打包成一个appiamge，将该文件拷贝给其他人即可1linuxdeployqt MarkdownPic -appimage mac打包12pyinstaller --windowed --onefile --clean --noconfirm demo.pypyinstaller --clean --noconfirm --windowed --onefile demo.spec]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime text 3]]></title>
    <url>%2F2018%2F11%2F15%2Fsublime-text-3%2F</url>
    <content type="text"><![CDATA[本文来探究一下Ubuntu和Deepin下sublime text 3的安装与配置 1. 安装1.1 下载与安装点击打开官网 123456789wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -sudo apt install apt-transport-httpsecho "deb https://download.sublimetext.com/ apt/stable/" | sudo tee /etc/apt/sources.list.d/sublime-text.listsudo apt updatesudo apt install sublime-text 1.2 激活 注意:先增加Host 屏蔽,然后输入秘钥才行 Windows : c:/windows/system32/drivers/etc/hosts Linux : /etc/hosts 12#127.0.0.1 www.sublimetext.com127.0.0.1 license.sublimehq.com 12345678910111213----- BEGIN LICENSE -----sgbteamSingle User LicenseEA7E-11532598891CBB9 F1513E4F 1A3405C1 A865D53F115F202E 7B91AB2D 0D2A40ED 352B269B76E84F0B CD69BFC7 59F2DFEF E267328F215652A3 E88F9D8F 4C38E3BA 5B2DAAE4969624E7 DC9CD4D5 717FB40C 1B9738CF20B3C4F1 E917B5B3 87C38D9C ACCE7DD85F7EF854 86B9743C FADC04AA FB0DA5C0F913BE58 42FEA319 F954EFDD AE881E0B------ END LICENSE ------ 1用户名：Caitingting，序列号：E8DD-289C-3F20-AA7D 2. 无法输入中文法一 以下方法是最快捷有效的方法,然而,可以输入中文了,但是,选择文件-&gt;右键-&gt;用sublime text 3打开,你会发现打不开文件了.但是先打开sublime,然后在里面选择文件又可以打开 12345678910111213141516171819git clone https://github.com/jfcherng/my_scriptssudo apt install -y fcitxsudo apt updatesudo apt install -y build-essential libgtk2.0-devcd my_scripts/sublime_text/sublime_text_fcitxgcc -Os -shared -o libsublime-imfix.so sublime_imfix.c $(pkg-config --libs --cflags gtk+-2.0) -fPICsudo mv -f libsublime-imfix.so /opt/sublime_textsudo cp -f subl "$(which subl)"sudo cp -f sublime_text.desktop /usr/share/applications/sudo cp -f sublime_text.desktop /opt/sublime_text 法二:123sudo apt update &amp;&amp; sudo apt upgradegit clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfix &amp;&amp; ./sublime-imfix 完成！重新启动后就可以在Sublime Text 3中使用搜狗输入法输入中文了 这里值得一提的是，博主用的是deepin，然后，一旦将st3固定在下面，然后，很快就又不能输入中文了，卸载重装即可 3. 插件3.1 安装package control 为了使用众多的插件来扩展 Sublime 的功能，你需要安装一个叫做 Package Control 的插件管理器,一旦你安装好了以后，你就可以使用 Package Control来安装，移除或者升级所有的 ST3 插件了。 按Ctrl+~打开控制台 到 https://packagecontrol.io/installation#st3 获取安装代码,这里如下 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 输入完了按Enter就行 现在你可以通过快捷键 Ctrl+Shift+P 打开 Package Control来安装其他的插件了。输入 install 然后你就能看见屏幕上出现了 Package Control: Install Package，点击回车然后搜索你想要的插件。想装什么直接点击。注意看下面的status bar是显示进度的地方 3.2 安装Anaconda python插件 Anaconda 是一个终极 Python 插件。它为 ST3 增添了多项 IDE 类似的功能，其具体配置文件在 https://github.com/DamnWidget/anaconda 例如： Autocompletion:自动完成，该选项默认开启,按TAB或Ctrl+Space显示代码提示窗口 Goto Definitions:能够在你的整个工程中查找并且显示任意一个变量，函数，或者类的定义。,键盘按下:Ctrl+Alt+g Find Usage 使用此命令，用户可以找到正在使用符号（变量，函数，方法，类或模块）的所有位置。键盘按下:Ctrl+Alt+f Display Signatures:能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下) Show Documentation： 可以查找并向用户显示任何函数，方法，类，模块或包的文档字符串。用户只需将光标放在想要获取文档字符串的符号上（或在括号之后，例如在写入之后sys.exit()),然后键盘按下Ctrl+Alt+d Code linting:使用支持 pep8 标准的 PyLint 或者 PyFlakes。因为我个人使用的是另外的 linting 工具，所以我会在 Anaconda 的配置文件 Anaconda.sublime-settings中将 linting 完全禁用。操作如下: Sublime &gt; Preferences &gt; Package Settings &gt; Anaconda &gt; Settings – User： {&quot;anaconda_linting&quot;: false} 最后,配置一下Anaconda 123456789101112131415&#123;&quot;python_interpreter&quot;:&quot;/usr/bin/python3&quot;,&quot;anaconda_linting&quot;: false,//保存文件后自动pep8格式化&quot;auto_formatting&quot;: true,// st3自动补全&quot;suppress_word_completions&quot;: true,&quot;suppress_explicit_completions&quot;: true,//&quot;complete_parameters&quot;: true&#125; 3.3 SublimeREPL插件 SublimeREPL会新建一个交互式命令行界面,让你的py可以有输入 配置python3环境 Preferences-&gt;Browse Packages,找到SublimeREPL的文件夹，再进入config文件夹，可以看到许多语言的配置文件，Python也在里面 在config文件夹下新建python3文件夹,在里面新建Default.sublime-commands和Menu.sublime-menu两个文件(模仿Python文件夹),因为我们Python3目前只要能打开shell运行，和运行这个脚本，两个功能，因此就只要包含Python3和 Python3 – Run current file两项就好了 Default.sublime-commands配置如下： 1234567891011121314151617181920[ &#123; &quot;caption&quot;: &quot;SublimeREPL: Python3&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123; &quot;id&quot;: &quot;repl_python3&quot;, &quot;file&quot;: &quot;config/Python3/Main.sublime-menu&quot; &#125; &#125;, &#123; &quot;caption&quot;: &quot;SublimeREPL: Python3 - RUN current file&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123; &quot;id&quot;: &quot;repl_python3_run&quot;, &quot;file&quot;: &quot;config/Python3/Main.sublime-menu&quot; &#125; &#125;] Menu.sublime-menu配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[ &#123; &quot;id&quot;: &quot;tools&quot;, &quot;children&quot;: [&#123; &quot;caption&quot;: &quot;SublimeREPL&quot;, &quot;mnemonic&quot;: &quot;R&quot;, &quot;id&quot;: &quot;SublimeREPL&quot;, &quot;children&quot;: [ &#123;&quot;caption&quot;: &quot;Python3&quot;, &quot;id&quot;: &quot;Python3&quot;, &quot;children&quot;:[ &#123;&quot;command&quot;: &quot;repl_open&quot;, &quot;caption&quot;: &quot;Python3&quot;, &quot;id&quot;: &quot;repl_python3&quot;, &quot;mnemonic&quot;: &quot;P&quot;, &quot;args&quot;: &#123; &quot;type&quot;: &quot;subprocess&quot;, &quot;encoding&quot;: &quot;utf8&quot;, &quot;cmd&quot;: [&quot;python3&quot;, &quot;-i&quot;, &quot;-u&quot;], &quot;cwd&quot;: &quot;$file_path&quot;, &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;, &quot;external_id&quot;: &quot;python3&quot;, &quot;extend_env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;&#125; &#125; &#125;, &#123;&quot;command&quot;: &quot;repl_open&quot;, &quot;caption&quot;: &quot;Python3 - RUN current file&quot;, &quot;id&quot;: &quot;repl_python3_run&quot;, &quot;mnemonic&quot;: &quot;R&quot;, &quot;args&quot;: &#123; &quot;type&quot;: &quot;subprocess&quot;, &quot;encoding&quot;: &quot;utf8&quot;, &quot;cmd&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$file_basename&quot;], &quot;cwd&quot;: &quot;$file_path&quot;, &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;, &quot;external_id&quot;: &quot;python3&quot;, &quot;extend_env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;&#125; &#125; &#125; ]&#125; ] &#125;] &#125;] 保存文件后,就可以Tools-&gt;SublimeREPL-&gt;Python3运行命令了 为了好看,采取和Ctr+B同样的上下布局 设置key binding每次这样到菜单栏里去找，太慢，能不能像ctrl+B一样直接运行呢？可以的，只要设置快捷键就好了，在Preference-&gt;key Bindings-User里 写入如下配置,即可F4运行python2.7 repl, F5 运行python 3 repl,注意id还是要和Menu.sublime-menu文件里的id要一致， 1234567891011121314151617181920212223242526272829303132333435[ &#123; &quot;keys&quot;:[&quot;f4&quot;], &quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123; &quot;id&quot;: &quot;repl_python_run&quot;, &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot; &#125; &#125;, &#123; &quot;keys&quot;:[&quot;f5&quot;], &quot;caption&quot;: &quot;SublimeREPL: Python3 - RUN current file&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123; &quot;id&quot;: &quot;repl_python3_run&quot;, &quot;file&quot;: &quot;config/Python3/Main.sublime-menu&quot; &#125; &#125;] can’t open file ‘$file_basename’: [Errno 2] No such file or directory这个只要再次用鼠标点击一下test.py就好了，就可以获取运行的文件了 3.4 SublimeTmpl 新建文件模板 在settings-user写入以下信息 123456789&#123; &quot;disable_keymap_actions&quot;: false, // &quot;all&quot;; &quot;html,css&quot; &quot;date_format&quot; : &quot;%Y-%m-%d %H:%M:%S&quot;, &quot;attr&quot;: &#123; &quot;author&quot;: &quot;江南小虫虫&quot;, &quot;email&quot;: &quot;fwh13612265462@gmail.com&quot;, &quot;link&quot;: &quot;http://www.jnxcc.top&quot; &#125;&#125; Ctlr+Alt+Shift+P:默认创建python文件,这里进行修改.在key bindings-user中添加了以下信息，意思ctrl+alt+n就可以创建一个新的Python模板 1234&#123; &quot;caption&quot;: &quot;Tmpl: Create python&quot;, &quot;command&quot;: &quot;sublime_tmpl&quot;, &quot;keys&quot;: [&quot;ctrl+alt+n&quot;], &quot;args&quot;: &#123;&quot;type&quot;: &quot;python&quot;&#125;&#125;, 3.5 SideBarEnhancements4. 配置4.1 隐藏mipmap和打开packages所在目录 View-&gt;Hide minimap:隐藏minimap Preferences-&gt;Browse Packages:打开packages所在目录 4.2 设置运行python3 sublime默认的是python2.7如果我想让他运行python3，怎么办呢? 运行which命令找到python3的路径 1which python3` 自定义环境:Tools-&gt;Build System-&gt;New Build System,会弹出一个后缀为sublime-build的文件。 将以下配置复制粘贴进去,如果发现pyqt5运行的时候啥也不显示，可将&quot;shell&quot;:&quot;true&quot;删掉123456&#123; &quot;cmd&quot;: [&quot;/usr/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;], &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;, &quot;selector&quot;: &quot;source.python&quot;, &quot;shell&quot;:&quot;true&quot;&#125; windows粘贴下面的:12345678&#123; &quot;cmd&quot;:[&quot;E:\\Python\\Python36-32\\python.exe&quot;,&quot;-u&quot;,&quot;$file&quot;], &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;, &quot;selector&quot;: &quot;source.python&quot;, &quot;encoding&quot;: &quot;utf-8&quot; , &quot;env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf8&quot;&#125;, &quot;shell&quot;:&quot;true&quot;&#125; 记住,其中的python3运行路径要和你系统中的路径一致,然后按Ctlr+S保存文件,文件名改为为python3.sublime-build，保存的路径就是Crtl+S后默认的路径,然后你在Tools-&gt;Build System,可以看到python3了,选择它再运行python,就会使用python3而不是python2.7了 4.3 一些常用的配置打开Preferences-&gt;Settings,可以看到右边有个settings-User,我们修改这个文件就行 .将一下配置粘贴进去就行12345678910111213141516171819202122232425&#123; &quot;font_size&quot;: 13, &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ], &quot;theme&quot;: &quot;Boxy Monokai.sublime-theme&quot;, // 使用空格代替tab &quot;translate_tabs_to_spaces&quot;: true, // 高亮未保存文件 &quot;highlight_modified_tabs&quot;: true, // 默认编码格式 &quot;default_encoding&quot;: &quot;UTF-8&quot;, // 窗口失焦立即保存文件 &quot;save_on_focus_lost&quot;: true, // 保存时自动去除行末空白 &quot;trim_trailing_white_space_on_save&quot;: true, // 保存时自动增加文件末尾换行,这样 git 提交时不会生产额外的 diff &quot;ensure_newline_at_eof_on_save&quot;: true, // 当前行高亮 &quot;highlight_line&quot;: true, // 设置行间距，看起来不那么&quot;挤&quot; &quot;line_padding_bottom&quot;: 1, &quot;line_padding_top&quot;: 1&#125; 另一种的12345678910111213141516171819&#123; &quot;color_scheme&quot;: &quot;Packages/Boxy Theme/schemes/Boxy Monokai.tmTheme&quot;, &quot;default_encoding&quot;: &quot;UTF-8&quot;, &quot;ensure_newline_at_eof_on_save&quot;: true, &quot;font_size&quot;: 12, &quot;highlight_line&quot;: true, &quot;highlight_modified_tabs&quot;: true, &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ], &quot;line_padding_bottom&quot;: 1, &quot;line_padding_top&quot;: 1, &quot;save_on_focus_lost&quot;: true, &quot;theme&quot;: &quot;Boxy Monokai.sublime-theme&quot;, &quot;translate_tabs_to_spaces&quot;: true, &quot;trim_trailing_white_space_on_save&quot;: true, &quot;update_check&quot;: false&#125; 4.4 Sublime常用快捷键1234567891011Ctrl+] 向右缩进Ctrl+[ 向左缩进Ctrl+Z 撤销。Ctrl+Y 恢复撤销。Ctrl+F 打开底部搜索框，查找关键字。Ctrl+A 选中全文Ctrl+B 运行pythonCtrl+Shift+P 调出命令窗Ctrl+shift+R 格式化Ctrl+shift+V 格式化粘贴 这个很有用，可以把网上的代码按照我的格式粘到我的文档里Ctrl+//注释 这个比较厉害，如果是python,就是加#号的，想取消再弄一次就好了 mac sublime text 3快捷键123456789101112131415161718192021[ &#123; &quot;caption&quot;: &quot;Tmpl: Create python&quot;, &quot;command&quot;: &quot;sublime_tmpl&quot;, &quot;keys&quot;: [&quot;ctrl+alt+n&quot;], &quot;args&quot;: &#123;&quot;type&quot;: &quot;python&quot;&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+b&quot;], &quot;command&quot;: &quot;build&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+shift+b&quot;], &quot;command&quot;: &quot;build&quot;, &quot;args&quot;: &#123;&quot;select&quot;: true&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+f&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: &#123;&quot;panel&quot;: &quot;find&quot;, &quot;reverse&quot;: false&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+s&quot;], &quot;command&quot;: &quot;save&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+x&quot;], &quot;command&quot;: &quot;cut&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+c&quot;], &quot;command&quot;: &quot;copy&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+v&quot;], &quot;command&quot;: &quot;paste&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+z&quot;], &quot;command&quot;: &quot;undo&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+shift+p&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;command_palette&quot;&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+a&quot;], &quot;command&quot;: &quot;select_all&quot; &#125;, &#123; &quot;keys&quot;: [&quot;home&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;bol&quot;&#125; &#125;, &#123; &quot;keys&quot;: [&quot;end&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;eol&quot;&#125; &#125;, &#123; &quot;keys&quot;: [&quot;shift+end&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;eol&quot;, &quot;extend&quot;: true&#125; &#125;, &#123; &quot;keys&quot;: [&quot;shift+home&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;bol&quot;, &quot;extend&quot;: true &#125; &#125;] mac sublime text C/C++12345678910111213&#123; &quot;cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;g++ &apos;$&#123;file&#125;&apos; -std=c++11 -stdlib=libc++ -o &apos;$&#123;file_path&#125;/$&#123;file_base_name&#125;&apos;&quot;], &quot;file_regex&quot;: &quot;^(..&#123;FNXX==XXFN&#125;*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;, &quot;selector&quot;: &quot;source.c, source.c++&quot;, &quot;variants&quot;: [ &#123; &quot;name&quot;: &quot;Run&quot;, &quot;cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;g++ &apos;$&#123;file&#125;&apos; -std=c++11 -stdlib=libc++ -o &apos;$&#123;file_path&#125;/$&#123;file_base_name&#125;&apos; &amp;&amp; open -a Terminal.app &apos;$&#123;file_path&#125;/$&#123;file_base_name&#125;&apos;&quot;] &#125; ]&#125;]]></content>
      <categories>
        <category>软件配置</category>
      </categories>
      <tags>
        <tag>sublime text 3</tag>
        <tag>st3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18.04安装ss-qt5]]></title>
    <url>%2F2018%2F11%2F15%2Fubuntu18-04%E5%AE%89%E8%A3%85ss-qt5%2F</url>
    <content type="text"><![CDATA[今天ubuntu18.04正式版终于出来了,笔者等了好久了,于是马上官网下载下来安装一波.界面确实比16.04好看好多 安装18.04系统之后,当然少不了ss梯子了,然而,在安装shadowsocks-qt5的时候,安装16.04的安装方法如下: 123sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt updatesudo apt install shadowsocks-qt5 然而在第二步update的时候出现了一个错误,如下 123忽略: http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic InRelease错误: http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic Release 404 Not Found [IP:91.189.95.83 80] Are you kidding me?装不了ss?不存在的!吓得我马上上shadowsocks-qt5那里看了一下 原来是作者还没有测试18.04,这简单啊!将源中的bionic改成artful不就行了? 1234------&gt;原来的如下:http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic main------&gt;改成如下:http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu artful main 操作很简单(dan teng),点左下角九个点点,然后找到软件和更新-&gt;其他软件 这里一开始笔者是想找到etc/apt/sources.list来修改的,但是这个文件里看不到ss-qt5的源… … 在这里修改ss-qt5的源,然后继续安装就行了. 接下来就是 enjoy your ubuntu]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ss-qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu配置]]></title>
    <url>%2F2018%2F11%2F15%2FUbuntu%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[必备基础更新123sudo apt updatesudo apt upgradesudo apt dist-upgrade 软件安装软件包里有的软件(一般都是这个)1sudo apt install 软件名 .deb结尾的文件1sudo dpkg -i 软件名 解除依赖1sudo apt -f install Ubuntu中软件包管理 1.下载的软件存放位置1/var/cache/apt/archives 2.安装后软件默认位置1/usr/share 3.可执行文件位置1/usr/bin 4.配置文件位置1/etc 5.lib文件位置1/usr/lib 以下为常用的各种软件vm-tool(虚拟机才会使用,用于全屏,复制)1sudo apt install open-vm-tools-desktop fuse 删除基本不用的自带软件1sudo apt purge libreoffice-common unity-webapps-common thunderbird totem rhythmbox simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku onboard deja-dup shadowsocks-qt5(ubuntu18.04失效)123sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt updatesudo apt install shadowsocks-qt5 proxychains4 借助它，ss才能终端翻墙 123456git clone https://github.com/rofl0r/proxychains-ng.gitcd proxychains-ng./configure --prefix=/usr --sysconfdir=/etcmakesudo make installsudo make install-config 然后还要编辑一下proxychains的配置文件12sudo gedit /etc/proxychains.conf# 如果你之前安装过proxychains,那么这时候的配置文件应该是proxychains4.conf,但是在进行以下修改的时候，两个配置文件都要修改 安装必要软件1sudo apt install vim ctags git gcc gdb rar diffuse shutter curl vim:强大的编辑器 git:代码管理 gcc,gdb,ctags:编译C语言用到 rar:解压.rar压缩文件 diffuse:文件比对 shutter:一款截图软件,快捷键：shutter —select) curl:一般我用来测试proxychains4安装Oracle Java123sudo add-apt-repository ppa:webupd8team/javasudo apt updatesudo apt install oracle-java8-installer 安装WPS 官网下载WPS(.deb): http://community.wps.cn/download/ dpkg -i 包名,进行安装 sudo apt -f install,解除依赖 安装网易云 官网下载网易云：http://music.163.com/#/download dpkg -i 包名 sudo apt -f install 运行：sudo netease-cloud-music 安装搜狗输入法 官网下载搜狗输入法： http://pinyin.sogou.com/linux/?r=pinyin dpkg -i 包名 sudo apt -f install 重启即可若出现无法输入中文普通用户,不用提权123cd ~/.configfind . -name sogou*find . -name Sogou* 将那三个文件干掉即可 若想输入英文标点Ctrl+. Flatabulous主题123456sudo add-apt-repository ppa:noobslab/themessudo add-apt-repository ppa:noobslab/iconssudo apt updatesudo apt install flatabulous-themesudo apt install ultra-flat-iconssudo apt install unity-tweak-tool 然后启动unity-tweak-tool,主题选择Flatabulous，图标选择Ultra-flat 安装CodeBlock 访问 https://launchpad.NET/~damien-moore/+archive/ubuntu/codeblocks-stable 找到页面上以“ppa:”开头加粗的那一段英文，比如这次就是“ppa:damien-moore/codeblocks-stable”123sudo add-apt-repository ppa:damien-moore/codeblocks-stablesudo apt updatesudo apt install codeblocks libwxgtk3.0-dev wx-common codeblocks-contrib 无法输入中文或终端中文出现乱码1Settings-&gt;General Setting-&gt;Environment-Terminal to launch console programs下拉菜单改成gnome-terminal -t $TITLE -x 无法正常关机重启方法1：系统设置-&gt; 软件和更新-&gt;附加驱动-&gt;安装专有驱动-&gt;安装完后重启，笔者就是用这种方法解决的。 方法2：1234567sudo gedit /etc/modprobe.d/blacklist.conf最下面添加下列内容blacklist vga16fbblacklist nouveaublacklist rivafbblacklist nvidiafbblacklist rivatv 方法3：在关机或重启前用sync命令 系统提示/boot空间不够123uname -a //查看内核信息dpkg --get-selections|grep linux-image 过滤过期内核sudo apt purge linux-image-4.4.0-66-generic 删掉内核 ps:千万不要删掉现在的内核，后果很严重 安装smplayer1sudo apt install smplayer 安装文泉驿微字体1sudo apt install ttf-wqy-microhei 安装苹果启动项1sudo apt install docky 安装Android Studio 翻墙去官网下载Android studio 将下载下来的文件解压到home目录 进入Android studio目录里面的bin目录 给studio.sh添加运行权限 1chmod +x studio.sh 终端运行 1sh studio.sh // 这里千万不要加sudo 经过一系列的下载安装,在主页面选择Configure →Create Desktop Entry →for all users vim配置第一种：界面好看1curl https://j.mp/spf13-vim3 -L &gt; spf13-vim.sh &amp;&amp; sh spf13-vim.sh 第二种：方便运行 将下列东西复制到~/.vimrc,然后就可以自动补全括号,F5编译,F6运行 当然也可以两种方法结合，在是用了第一种方法之后，记得先去~/.vimrc，将其中的F5,F6快捷键用&quot;注释掉，然后再复制粘贴以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125inoremap ( ()&lt;Esc&gt;iinoremap [ []&lt;Esc&gt;iinoremap &#123; &#123;&lt;CR&gt;&#125;&lt;Esc&gt;Oautocmd Syntax html,vim inoremap &lt; &lt;lt&gt;&gt;&lt;Esc&gt;i| inoremap &gt; &lt;c-r&gt;=ClosePair('&gt;')&lt;CR&gt;inoremap ) &lt;c-r&gt;=ClosePair(')')&lt;CR&gt;inoremap ] &lt;c-r&gt;=ClosePair(']')&lt;CR&gt;inoremap &#125; &lt;c-r&gt;=CloseBracket()&lt;CR&gt;inoremap " &lt;c-r&gt;=QuoteDelim('"')&lt;CR&gt;inoremap ' &lt;c-r&gt;=QuoteDelim("'")&lt;CR&gt;function ClosePair(char) if getline('.')[col('.') - 1] == a:char return "&lt;Right&gt;" else return a:char endifendffunction CloseBracket() if match(getline(line('.') + 1), 's*&#125;') &lt; 0 return "&lt;CR&gt;&#125;" else return "&lt;Esc&gt;j0f&#125;a" endifendffunction QuoteDelim(char) let line = getline('.') let col = col('.') if line[col - 2] == "\" return a:char elseif line[col - 1] == a:char return "&lt;Right&gt;" else return a:char.a:char."&lt;Esc&gt;i" endifendf" F6运行Cfunc! CompileGcc() exec "w" let compilecmd="!gcc " let compileflag="-o %&lt; " if search("mpi.h") != 0 let compilecmd = "!mpicc " endif if search("glut.h") != 0 let compileflag .= " -lglut -lGLU -lGL " endif if search("cv.h") != 0 let compileflag .= " -lcv -lhighgui -lcvaux " endif if search("omp.h") != 0 let compileflag .= " -fopenmp " endif if search("math.h") != 0 let compileflag .= " -lm " endif exec compilecmd." % ".compileflagendfuncfunc! CompileGpp() exec "w" let compilecmd="!g++ " let compileflag="-o %&lt; " if search("mpi.h") != 0 let compilecmd = "!mpic++ " endif if search("glut.h") != 0 let compileflag .= " -lglut -lGLU -lGL " endif if search("cv.h") != 0 let compileflag .= " -lcv -lhighgui -lcvaux " endif if search("omp.h") != 0 let compileflag .= " -fopenmp " endif if search("math.h") != 0 let compileflag .= " -lm " endif exec compilecmd." % ".compileflagendfuncfunc! RunPython() exec "!python %"endfuncfunc! CompileJava() exec "!javac %"endfuncfunc! CompileCode() exec "w" if &amp;filetype == "cpp" exec "call CompileGpp()" elseif &amp;filetype == "c" exec "call CompileGcc()" elseif &amp;filetype == "python" exec "call RunPython()" elseif &amp;filetype == "java" exec "call CompileJava()" endifendfuncfunc! RunResult() exec "w" if search("mpi.h") != 0 exec "!mpirun -np 4 ./%&lt;" elseif &amp;filetype == "cpp" exec "! ./%&lt;" elseif &amp;filetype == "c" exec "! ./%&lt;" elseif &amp;filetype == "python" exec "call RunPython" elseif &amp;filetype == "java" exec "!java %&lt;" endifendfuncmap &lt;F5&gt; :call CompileCode()&lt;CR&gt;imap &lt;F5&gt; &lt;ESC&gt;:call CompileCode()&lt;CR&gt;vmap &lt;F5&gt; &lt;ESC&gt;:call CompileCode()&lt;CR&gt;map &lt;F6&gt; :call RunResult()&lt;CR&gt; 安装Xmind 官网下载：http://www.xmind.net/download/previous/ dpkg -i 包名 安装indicator-sysmonitor123sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitorsudo apt updatesudo apt install indicator-sysmonitor 终端执行：indicator-sysmonitor &amp;为程序添加开机启动！鼠标右键点击标题栏上图标，弹出菜单，选择首选项 勾上Run on startup:， 这样就能开机启动了。切换到 Advanced 选项，可以对要显示的信息的格式进行设置。然后关闭终端,按window键搜索indicator,然后打开就行 win10,Ubuntu双系统,发现window的盘打不开类似这样的错误:Error mounting /dev/sda51sudo ntfsfix /dev/sda5 安装GIMP 号称Linux下的ps1sudo apt install gimp 安装护眼的f.lux123sudo add-apt-repository ppa:nathan-renniewaldock/fluxsudo apt updatesudo apt install fluxgui 安装MPV播放器 相对于smplayer的另一个播放器123sudo add-apt-repository ppa:mc3man/mpv-testssudo apt updatesudo apt install mpv 提高笔记本电池寿命12sudo apt install tlp tlp-rdwsudo tlp start 设置root密码12345sudo su -输入你的账户的密码passwd输入新的root密码再次输入新的root密码 安装Qt 网站: https://www.qt.io/download-open-source/选择不联网的那个安装的时候不要提权安装Qt出现无法输入中文1.安装fcitx-frontend-qt51sudo apt install fcitx-frontend-qt5 2.输入dpkg -L fcitx-frontend-qt5,找到安装路径,出现libfcitxplatforminputcontextplugin.so的就是3.将上面的文件复制到Qt安装目录,我的是12/home/hua/Qt5.11.1/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/home/hua/Qt5.11.1/5.11.1/gcc_64/plugins/platforminputcontexts 123# 所以我的命令如下cp -r /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so /home/hua/Qt5.11.1/Tools/QtCreator/lib/Qt/plugins/platforminputcontextscp -r /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so /home/hua/Qt5.11.1/5.11.1/gcc_64/plugins/platforminputcontexts 123# 有时候可能有对`.so`文件进行提权，可`cd`到指定目录下，分别进行如下操作，如果提示没有权限就用`sudo`chmod +x libfcitxplatforminputcontextplugin.sochmod 777 libfcitxplatforminputcontextplugin.so 常用压缩包的打包和解压 .tar.bz 解压:tar jxvf 文件名.tar.bz .tar.gz 解压:tar zxvf 文件名.tar.gz 压缩:tar zcvf 文件名.tar.gz 目标名 .zip: 解压:unzip -O CP936 xxx.zip 压缩:zip 目标文件名.zip 要压缩的东西,一般都是zip 目标文件名.zip ./*:将当前目录下的所有东西全部压缩成 目标文件名.zip .tar: 解压:tar xvf 文件名.tar 压缩:tar cvf 文件名.tar 目标名 .rar: 解压:rar x 文件名.rar 压缩:rar a 文件名.rar 目标名 安装QQ 网站:http://phpcj.org/wineqq 准备环境 123sudo add-apt-repository ppa:wine/wine-buildssudo apt updatesudo apt install winehq-devel 下载wineqq下载地址提取密码:f2sn 将压缩包解压到用户主目录 1tar xvf wineQQ8.9.4_21584.tar.xz -C ~/ 打开qq,等待安装一些东西即可 出现方块字体12PC:~winecfg//第一次运行然系统初始化好然后关闭下载好我给你们的文件（3个文件：wine−zh−fix−reg.tar.gz解压后放在一边在终端里面输入：‘PC: winecfg//第一次运行然系统初始化好然后关闭下载好我给你们的文件（3个文件：wine−zh−fix−reg.tar.gz解压后放在一边在终端里面输入：‘PC: regedit xxx.reg //xxx.reg是解压的文件 全部都要执行该命令`再打开wine：完美解决 使用CrossOver安装qq1.下载安装CrossOver12345sudo dpkg --add-architecture i386sudo apt updatesudo apt install gdebiwget http://crossover.codeweavers.com/redirect/crossover.debsudo gdebi crossover.deb 下载后解压出crack文件夹里面的winewrapper.exe.so拷贝到/opt/cxoffice/lib/wine/目录下 最简单的qq安装 https://github.com/askme765cs/Wine-QQ-TIM 下载完成后,双击运行 Atom配置相关设置 Tab长度：File &gt; settings &gt; Tab Length 设置为4快捷键 ctrl+shift+M：Markdown编辑环境下的分隔到右侧预览效果插件安装 File &gt; settings &gt; Install &gt; Search pachages &gt;Packages &gt;Install 安装完成后会在settings &gt; Packages &gt; Community Packages中看到插件介绍 simplified-chinese-menu：简体中文包汉化菜单插件 file-icons:file文件图标 linter:检查错误 minimap:小地图 script:运行代码。快捷键Ctrl+Shift+b autocomplete-python:python代码自动补全 highlight-selected:高亮选择的词 minimap-highlight-selected:小地图高亮 nucleus-dark-ui | seti-ui:最漂亮的两个主题 atom-monokai | monokai:最漂亮的两个语法主题 markdown-img-paste:图片粘贴(Ctrl+shift+v) markdown-preview-enhanced:中国人自己写的强大的markdown gpp-compiler:写C语言用 ubuntu16.04与windows时间同步代码：第一种方法12sudo timedatectl set-local-rtc 1 --adjust-system-clocksudo timedatectl set-ntp 0 第二种方法123sudo apt install ntpdatesudo ntpdate time.windows.comsudo hwclock --localtime --systohc 出现“无法获得锁 /var/lib/apt/lists/lock”错误1sudo rm /var/lib/apt/lists/lock Gparted 一个分区工具，它可以用于创建、删除、移动分区，调整分区大小，检查、复制分区等操作。可以用于调整分区以安装新操作系统、备份特定分区到另一块硬盘等。1sudo apt install gparted -y FileZilla FileZilla是一个免费开源的FTP软件，分为客户端版本和服务器版本，具备所有的FTP软件功能。可控性、有条理的界面和管理多站点的简化方式使得Filezilla客户端版成为一个方便高效的FTP客户端工具。1sudo apt install filezilla Kazam Kazam 是 Ubuntu 上一款简易的桌面屏幕录制工具，它只能录制整个屏幕，可以录制声音，并可以快速上传录制好的视频到 YouTube 及 VideoBin 视频分享网站上 123sudo add-apt-repository ppa:and471/kazam-daily-buildssudo apt updatesudo apt install kazam Silentcast Silentcast是一款专注于GIF录制工具。 123sudo add-apt-repository ppa:sethj/silentcastsudo apt updatesudo apt install silentcast Okular Okular 是一个 PDF 文档阅读软件，支持 PDF、TIFF、CHM、ODF、EPUB、mobi 等文档格式。 1sudo apt install okular -y Albert Spotlight Albert Spotlight是 Ubuntu的一项快速、随打即找、系统支援的桌面搜寻特色。spotlight 被设计为可以找到任何位于电脑中广泛的项目，包含文件、图片、音乐、应用程式、系统喜好设定控制台，也可以是文件或是PDF中指定的字。优雅地取代了Mac中的mac Spotlight。 在安装完成之后,打开,配置打开的快捷键即可. 民间 123sudo add-apt-repository ppa:noobslab/macbuntusudo apt updatesudo apt install albert 官方 12345wget -nv https://download.opensuse.org/repositories/home:manuelschneid3r/xUbuntu_16.04/Release.key -O Release.keysudo apt-key add - &lt; Release.keysudo sh -c "echo 'deb http://download.opensuse.org/repositories/home:/manuelschneid3r/xUbuntu_16.04/ /' &gt; /etc/apt/sources.list.d/albert.list"sudo apt updatesudo apt install albert enca enca文件编码转换工具。 1sudo apt install enca 12#enca查看文件编码enca filename Figlet Figlet是一个将字符串在终端生成一个logo的终端工具。 1sudo apt install figlet Wingware 这是一个很牛的PythonIDE 官网地址:http://www.wingware.com/ Pro版本为商业版本,可破解 破解脚本,注意修改里面的LicenseID和RequestCode即可 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python3LicenseID='CN823-12345-12345-67891'RequestCode='RL625-QV8EM-EHT8Y-G5XW8'import hashlibB16 = '0123456789ABCDEF'B30 = '123456789ABCDEFGHJKLMNPQRTVWXY'def B(n,f,t): xx = 0 for d in str(n): xx = xx * len(f) + f.index(d) res = '' while xx &gt; 0: res=t[int(xx%len(t))]+res xx//=len(t) return resdef S(D): r = B(''.join([c for i,c in enumerate(D) if i//2*2==i]),B16,B30) while len(r) &lt; 17: r = '1' + r return rdef A(c): return c[:5]+'-'+c[5:10]+'-'+c[10:15]+'-'+c[15:]h = hashlib.sha1()h.update(RequestCode.encode('utf-8')+LicenseID.encode('utf-8'))lichash=A(RequestCode[:3]+S(h.hexdigest().upper()) )data=[23,161,47,9]tmp=0realcode=''for i in data: for j in lichash: tmp=(tmp*i+ord(j))&amp;0xFFFFF realcode+=format(tmp,'=05X') tmp=0D=B(realcode,B16,B30)while len(D) &lt; 17: D = '1' + Dprint("The Activation Code is: "+A('AXX'+D)) 在Ubuntu下无法输入中文 1dpkg -L fcitx-frontend-qt5 1dpkg -L wingide6 | grep platforminputcontexts 1sudo cp /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so /usr/lib/wingide6/bin/runtime-qt5.5/plugins/platforminputcontexts 常用技巧 F1,F2:上下左右框的开合 Edit-&gt;Preferences-&gt;User Interface-&gt;Color Palete选择主题 显示行号:Edit -&gt; Show(Hide) Line Numbers TAB:自动补全 设置补全键：Edit-&gt;Keybord Personality-&gt;Config auto..-&gt;Editors-&gt;Auto-completion 安装汇编环境12sudo apt install dosemu# 将下载下来dos程序如masm复制到`~/.dosemu/drives/d/bin`中即可 编写汇编代码 在dos下直接输入edit,用鼠标选择File-&gt;New,开始编写,然后选择Save as保存为.asm后缀文件即可 终端进入~/.dosemu/drives/c目录下,用vim编写 开机自动挂载Windows分区 前期准备 查看系统磁盘号1sudo fdisk -l 查看磁盘类型1sudo blkid 修改配置文件1sudo gedit /etc/fstab 配置文件包括下面几项: 内容 例子 分区定位 可以给磁盘号，UUID或LABEL，例如：/dev/sda2，UUID=6E9ADAC29ADA85CD或LABEL=software 具体挂载点的位置 例如：/media/C 挂载磁盘类型 linux分区一般为ext4，windows分区一般为ntfs 挂载参数 一般为defaults 磁盘备份 默认为0，不备份 磁盘检查 默认为0，不检查 配置图如下: 12345678910111213141516# disk for Window10# c for Windows10UUID="3C5002DB50029BB0" /media/hua/3C5002DB50029BB0 ntfs defaults 0 0# d for Windows10UUID="1C963ACF963AA962" /media/hua/软件安装处 ntfs defaults 0 0# e for Windows10UUID="5CA074DBA074BD58" /media/hua/资料与娱乐 ntfs defaults 0 0# f for Windows10UUID="4AD483BBD483A7B1" /media/hua/软件 ntfs defaults 0 0# g for Windows10UUID="32C290FDC290C68F" /media/hua/虚拟机及代码 ntfs defaults 0 0 检查并挂载新添加项:1sudo mount -a 改命令会在/etc/fstab中的项全部挂载,如果有错,则会提示错误,然后根据错误找出原因修改 安装wireshark wireshark是一个网络抓包分析工具12sudo apt install wireshark # 弹框选"YES"sudo usermod -a -G wireshark $USER 为重装系统做准备在自己的系统配置到差不多的时候，可以1sudo apt-mark showmanual &gt; .install 在需要重装系统的时候，执行1sudo apt install $(cat .install) 就可以安装之前选择的所有软件了～当然/home需要单独分区 xx-net的ipv6123sudo apt install miredo重启sudo miredo 打开启动应用管理1gnome-session-properties]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四章 多变量线性回归(Linear Regression with Multiple Variables)]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92(Linear-Regression-with-Multiple-Variables)%2F</url>
    <content type="text"><![CDATA[Multiple Features（多维特征） 在这段视频中 我们将开始 介绍一种新的 更为有效的线性回归形式 这种形式适用于多个变量或者多特征量的情况 在之前我们学习过的 线性回归中 我们只有一个单一特征量 房屋面积 x 我们希望用这个特征量 来预测 房子的价格 这就是我们的假设 但是想象一下 如果我们不仅有房屋面积 作为预测房屋 价格的特征量 或者变量 我们还知道 卧室的数量 楼层的数量以及房子的使用年限 这样就给了我们 更多可以用来 预测房屋价格的信息 先简单介绍一下记法 我们开始的时候就提到过 我要用 x 下标1 x 下标2 等等 来表示 这种情况下的四个特征量 然后仍然用 Y来表示我们 所想要预测的输出变量 让我们来看看更多的表示方式 现在我们有四个特征量 我要用小写n 来表示特征量的数目 因此在这个例子中 我们的n等于4 因为你们看 我们有 1 2 3 4 共4个特征量 这里的n和我们之前 使用的n不同 之前我们是用的“m”来表示样本的数量 所以如果你有47行 那么m就是这个表格里面的行数 或者说是训练样本数 然后我要用x 上标 (i) 来表示第i个 训练样本的 输入特征值 举个具体的例子来说 x上标 (2) 就是表示第二个 训练样本的特征向量 因此这里 x(2)就是向量 [1416, 3, 2, 40] 因为这四个数字对应了 我用来预测房屋价格的 第二个房子的 四个特征量 因此在这种记法中 这个上标2 就是训练集的一个索引 而不是x的2次方 这个2就对应着 你所看到的表格中的第二行 即我的第二个训练样本 x上标(2) 这样表示 就是一个四维向量 事实上更普遍地来说 这是n维的向量 用这种表示方法 x上标2就是一个向量 因此 我用x上标(i) 下标j 来表示 第i个训练样本的 第j个特征量 因此具体的来说 x上标(2)下标3代表着 第2个训练样本里的第3个特征量 对吧？ 这个是3 我写的不太好看 所以说x上标(2)下标3就等于2 既然我们有了多个特征量 让我们继续讨论一下 我们的假设形式应该是怎样的 这是我们之前使用的假设形式 x就是我们唯一的特征量 但现在我们有了多个特征量 我们就不能再 使用这种简单的表示方式了 取而代之的 我们将把线性回归的假设 改成这样 θ0加上 θ1 乘以 x1 加上 θ2乘以x2 加上 θ3 乘以x3 加上θ4乘以x4 然后如果我们有n个特征量 那么我们要将所有的n个特征量相加 而不是四个特征量 我们需要对n个特征量进行相加 举个具体的例子 在我们的设置的参数中 我们可能有h(x)等于 80 + 0.1 x1 + 0.01x2 + 3x3 - 2x4 这就是一个 假设的范例 别忘了 假设是为了预测 大约以千刀为单位的房屋价格 就是说 一个房子的价格 可以是 80 k加上 0.1乘以x1 也就是说 每平方尺100美元 然后价格 会随着楼层数的增加 再继续增长 x2是楼层数 接着价格会继续增加 随着卧室数的增加 因为x3是 卧室的数量 但是呢 房子的价格会 随着使用年数的增加 而贬值 这是重新改写过的假设的形式 接下来 我要来介绍一点 简化这个等式的表示方式 为了表示方便 我要将x下标0的值设为1 具体而言 这意味着 对于第i个样本 都有一个向量x上标(i) 并且x上标(i) 下标0等于1 你可以认为我们 定义了一个额外的第0个特征量 因此 我过去有n个特征量 因为我们有x1 x2 直到xn 由于我另外定义了 额外的第0个特征向量 并且它的取值 总是1 所以我现在的特征向量x 是一个从0开始标记的 n+1维的向量 所以现在就是一个 n+1维的特征量向量 但我要从0开始标记 同时 我也想把我的参数 都看做一个向量 所以我们的参数就是 我们的θ0 θ1 θ2 等等 直到θn 我们要把 所有的参数都写成一个向量 θ0 θ1...一直到 直到θn 这里也有一个从0开始标记的矢量 下标从0开始 这是另外一个 所以我的假设 现在可以写成θ0乘以x0 加上θ1乘以x1直到 θn 乘以xn 这个等式 和上面的等式是一样的 因为你看 x0等于1 下面 我要 把这种形式假设等式 写成 θ转置乘以X 取决于你对 向量内积有多熟悉 如果你展开 θ转置乘以X 那么就得到 θ0 θ1直到θn 这个就是θ转置 实际上 这就是一个 n+1乘以1维的矩阵 也被称为行向量 用行向量 与X向量相乘 X向量是 x0 x1等等 直到xn 因此内积就是 θ转置乘以X 就等于这个等式 这就为我们提供了一个 表示假设的 更加便利的形式 即用参数向量θ以及 特征向量X的内积 这就是改写以后的 表示方法 这样的表示习惯 就让我们 可以以这种紧凑的形式写出假设 这就是多特征量情况下的假设形式 起另一个名字 就是 所谓的多元线性回归 多元一词 也就是用来预测的多个特征量 或者变量 就是一种更加好听的说法罢了 Gradient Descent for Multiple Variables(多变量梯度下降) 在之前的视频中 我们谈到了一种线性回归的假设形式 这是一种有多特征或者是多变量的形式 在本节视频中 我们将会谈到如何找到满足这一假设的参数 尤其是如何使用梯度下降法 来解决多特征的线性回归问题 为尽快让你理解 现假设现有多元线性回归 并约定 x0=1 该模型的参数是从 θ0 到 θn 不要认为这是 n+1 个单独的参数 你可以把这 n+1 个 θ 参数想象成一个 n+1 维的向量 θ 所以 你现在就可以把这个模型的参数 想象成其本身就是一个n+1 维的向量 我们的代价函数是从 θ0 到 θn 的函数 J 并给出了误差项平方的和 但同样地 不要把函数 J 想成是一个关于 n+1 个自变量的函数 而是看成带有一个 n+1 维向量的函数 这就是梯度下降法 我们将会不停地用 θj 减去 α 倍的导数项 来替代 θj 同样的方法 我们写出函数J(θ) 因此 θj 被更新成 θj 减去学习率 α 与对应导数的乘积 就是代价函数的对参数 θj 的偏导数 当我们实现梯度下降法后 你可以仔细观察一下 尤其是它的偏导数项 下面是我们当特征 n=1 时 梯度下降的情况 我们有两条针对参数 θ0 和 θ1 不同的更新规则 希望这些对你来说并不陌生 这一项是代价函数里部分求导的结果 就是代价函数相对于 θ0 的偏导数 同样 对参数 θ1 我们有另一个更新规则 仅有的一点区别是 当我们之前只有一个特征 我们称该特征为x(i) 但现在我们在新符号里 我们会标记它为 x 上标 (i) 下标1 来表示我们的特征 以上就是当我们仅有一个特征时候的算法 下面我们来讲讲当有一个以上特征时候的算法 现有数目远大于1的很多特征 我们的梯度下降更新规则变成了这样 有些同学可能知道微积分 如果你看看代价函数 代价函数 J 对参数 θj 求偏导数 你会发现 求其偏导数的那一项 我已经用蓝线圈出来了 如果你实现了这一步 你将会得到多元线性回归的梯度下降算法 最后 我想让你明白 为什么新旧两种算法实际上是一回事儿 或者说为什么这两个是类似的算法 为什么它们都是梯度下降算法 考虑这样一个情况 有两个或以上个数的特征 同时我们有对θ1、θ2、θ3的三条更新规则 当然可能还有其它参数 如果你观察θ0的更新规则 你会发现这跟之前 n=1的情况相同 它们之所以是等价的 这是因为在我们的标记约定里有 x(i)0=1 也就是 我用品红色圈起来的两项是等价的 同样地 如果你观察 θ1 的更新规则 你会发现这里的这一项是 和之前对参数θ1的更新项是等价的 在这里我们只是用了新的符号x(i)1来表示我们的第一个特征 现在我们有个更多的特征 那么就可以用与之前相同的更新规则 我们可以用同样的规则来处理 θ2 等其它参数 这张幻灯片的内容不少 请务必仔细理解 如果觉得幻灯片上数学公式没看懂 尽管暂停视频 请确保理解了再继续后面的学习 如果你将这些算法都实现了 那么你就可以直接应用到多元线性回归中了 多变量梯度下降笔记 Gradient Descent in Practice 1-Feature Sacling(梯度下降法实践1-特征缩放) 在这段视频 以及下一段视频中 我想告诉你一些关于 梯度下降运算中的实用技巧 在这段视频中 我会告诉你一个称为特征缩放 (feature scaling) 的方法 如果你有一个机器学习问题 这个问题有多个特征 如果你能确保这些特征 都处在一个相近的范围 我的意思是确保不同特征的取值 在相近的范围内,这样梯度下降法就能更快地收敛 具体地说 假如你有一个具有两个特征的问题 其中 x1 是房屋面积大小 它的取值 在0到2000之间 x2 是卧室的数量 可能这个值 取值范围在1到5之间 如果你画出代价函数 J(θ) 的轮廓图 那么这个轮廓看起来 应该是像这样的 J(θ) 是一个关于 参数 θ0 θ1 和 θ2 的函数 但我要忽略 θ0 所以暂时不考虑 θ0 并假想一个函数的变量 只有 θ1 和 θ2 但如果 x1 的取值范围 远远大于 x2 的取值范围的话 那么最终画出来的 代价函数 J(θ) 的轮廓图 就会呈现出这样一种 非常偏斜 并且椭圆的形状 2000 和 5的比例 会让这个椭圆更加瘦长 所以 这是一个又瘦又高的 椭圆形轮廓图 就是这些非常高大细长的椭圆形 构成了代价函数 J(θ) 而如果你用这个代价函数 来运行梯度下降的话 你要得到梯度值 最终可能 需要花很长一段时间 并且可能会来回波动 然后会经过很长时间 最终才收敛到全局最小值 事实上 你可以想像 如果这些 轮廓再被放大一些的话 如果你画的再夸张一些 把它画的更细更长 那么可能情况会更糟糕 梯度下降的过程 可能更加缓慢 需要花更长的时间 反复来回振荡 最终才找到一条正确通往全局最小值的路 在这样的情况下 一种有效的方法是进行特征缩放(feature scaling) 具体来说 把特征 x 定义为 房子的面积大小 除以2000的话 并且把 x2 定义为 卧室的数量除以5 那么这样的话 表示代价函数 J(θ) 的轮廓图的形状 就会变得偏移没那么严重 可能看起来更圆一些了 如果你用这样的代价函数 来执行梯度下降的话 那么 梯度下降算法 你可以从数学上来证明 梯度下降算法 就会找到一条 更捷径的路径通向全局最小 而不是像刚才那样 沿着一条让人摸不着头脑的路径 一条复杂得多的轨迹 来找到全局最小值 因此 通过特征缩放 通过”消耗掉”这些值的范围 在这个例子中 我们最终得到的两个特征 x1 和 x2 都在0和1之间 这样你得到的梯度下降算法 就会更快地收敛 更一般地 我们执行特征缩放时 我们通常的目的是 将特征的取值约束到 -1 到 +1 的范围内 你的特征 x0 是总是等于1 因此 这已经是在这个范围内 但对其他的特征 你可能需要通过除以不同的数 来让它们处于同一范围内 -1 和 +1 这两个数字并不是太重要 所以 如果你有一个特征 x1 它的取值 在0和3之间 这没问题 如果你有另外一个特征 取值在-2 到 +0.5之间 这也没什么关系 这也非常接近 -1 到 +1的范围 这些都可以 但如果你有另一个特征 比如叫 x3 假如它的范围 在 -100 到 +100之间 那么 这个范围 跟-1到+1就有很大不同了 所以 这可能是一个 不那么好的特征 类似地 如果你的特征在一个 非常非常小的范围内 比如另外一个特征 x4 它的范围在 0.0001和+0.0001之间 那么 这同样是一个 比-1到+1小得多的范围 比-1到+1小得多的范围 因此 我同样会认为这个特征也不太好 所以 可能你认可的范围 也许可以大于 或者小于 -1 到 +1 但是也别太大 只要大得不多就可以接受 比如 +100 或者也别太小 比如这里的0.001 不同的人有不同的经验 但是我一般是这么考虑的 如果一个特征是在 -3 到 +3 的范围内 那么你应该认为 这个范围是可以接受的 但如果这个范围 大于了 -3 到 +3 的范围 我可能就要开始注意了 如果它的取值 在-1/3 到+1/3的话 我觉得 还不错 可以接受 或者是0到1/3 或-1/3到0 这些典型的范围 我都认为是可以接受的 但如果特征的范围 取得很小的话 比如像这里的 x4 你就要开始考虑进行特征缩放了 因此 总的来说 不用过于担心 你的特征是否在完全 相同的范围或区间内 但是只要他们都 只要它们足够接近的话 梯度下降法就会正常地工作 除了在特征缩放中 将特征除以最大值以外 有时候我们也会进行一个 称为均值归一化的工作(mean normalization) 我的意思是这样的 如果你有一个特征 xi 你就用 xi - μi 来替换 通过这样做 让你的特征值 具有为0的平均值 很明显 我们不需要 把这一步应用到 x0中 因为 x0 总是等于1的 所以它不可能有 为0的的平均值 但是 对其他的特征来说 比如房子的大小 取值介于0到2000 并且假如 房子面积 的平均值 是等于1000的 那么你可以用这个公式 将 x1 的值变为 x1 减去平均值 μ1 再除以2000 类似地 如果你的房子有 五间卧室 并且平均一套房子有 两间卧室 那么你可以 使用这个公式 来归一化你的第二个特征 x2 在这两种情况下 你可以算出新的特征 x1 和 x2 这样它们的范围 可以在-0.5和+0.5之间 当然这肯定不对 x2的值实际上肯定会大于0.5 但很接近 更一般的规律是 你可以用这样的公式 你可以用 (x1 - μ1)/S1 来替换原来的特征 x1 其中定义μ1的意思是 在训练集中 特征 x1 的平均值 而 S1 是 该特征值的范围 我说的范围是指 最大值减去最小值或者学过 标准差的同学可以记住 也可以把 S1 设为 变量的标准差 但其实用最大值减最小值就可以了 类似地 对于第二个 特征 x2 你也可以用同样的这个 特征减去平均值 再除以范围 来替换原特征 范围的意思依然是最大值减最小值 这类公式将 把你的特征 变成这样的范围 也许不是完全这样 但大概是这样的范围 顺便提一下 有些同学可能比较仔细 如果我们用最大值减最小值 来表示范围的话 这里的5有可能应该是4 如果最大值为5 那么减去最小值1 这个范围值就是4 但不管咋说 这些取值 都是非常近似的 只要将特征转换为 相近似的范围 就都是可以的 特征缩放其实 并不需要太精确 只是为了让梯度下降 能够运行得更快一点而已 好的 现在你知道了 什么是特征缩放 通过使用这个简单的方法 你可以将梯度下降的速度变得更快 让梯度下降收敛所需的循环次数更少 这就是特征缩放 在接下来的视频中 我将介绍另一种技巧来使梯度下降 在实践中工作地更好 Gradient Descent in Practice II-Learning Rate(梯度下降法实践2-学习率) 在本段视频中 我想告诉大家 一些关于梯度下降算法的实用技巧 我将集中讨论 学习率 α 具体来说 这是梯度下降算法的 更新规则 这里我想要 告诉大家 如何调试 也就是我认为应该如何确定 梯度下降是正常工作的 此外我还想告诉大家 如何选择学习率 α 也就是我平常 如何选择这个参数 我通常是怎样确定 梯度下降正常工作的 梯度下降算法所做的事情 就是为你找到 一个 θ 值 并希望它能够最小化代价函数 J(θ) 我通常会在 梯度下降算法运行时 绘出代价函数 J(θ) 的值 这里的 x 轴是表示 梯度下降算法的 迭代步数 你可能会得到 这样一条曲线 注意 这里的 x 轴 是迭代步数 在我们以前看到的 J(θ) 曲线中 x 轴 也就是横轴 曾经用来表示参数 θ 但这里不是 具体来说 这一点的含义是这样的 当我运行完100步的梯度下降迭代之后 无论我得到 什么 θ 值 总之 100步迭代之后 我将得到 一个 θ 值 根据100步迭代之后 得到的这个 θ 值 我将算出 代价函数 J(θ) 的值 而这个点的垂直高度就代表 梯度下降算法 100步迭代之后 得到的 θ 算出的 J(θ) 值 而这个点 则是梯度下降算法 迭代200次之后 得到的 θ 算出的 J(θ) 值 所以这条曲线 显示的是 梯度下降算法迭代过程中代价函数 J(θ) 的值 如果梯度下降算法 正常工作 那么每一步迭代之后 J(θ) 都应该下降 这条曲线 的一个用处在于 它可以告诉你 如果你看一下 我画的这条曲线 当你达到 300步迭代之后 也就是300步到400步迭代之间 就是曲线的这一段 看起来 J(θ) 并没有下降多少 所以当你 到达400步迭代时 这条曲线看起来已经很平坦了 也就是说 在这里400步迭代的时候 梯度下降算法 基本上已经收敛了 因为代价函数并没有继续下降 所以说 看这条曲线 可以帮助你判断 梯度下降算法是否已经收敛 顺便说一下 对于每一个特定的问题 梯度下降算法所需的迭代次数 可以相差很大 也许对于某一个问题 梯度下降算法 只需要30步迭代就可以收敛 然而换一个问题 也许梯度下降算法就需要3000步迭代 对于另一个机器学习问题 则可能需要三百万步迭代 实际上 我们很难提前判断 梯度下降算法 需要多少步迭代才能收敛 通常我们需要画出这类曲线 画出代价函数随迭代步数数增加的变化曲线 通常 我会通过看这种曲线 来试着判断 梯度下降算法是否已经收敛 另外 也可以 进行一些自动的收敛测试 也就是说用一种算法 来告诉你梯度下降算法 是否已经收敛 自动收敛测试 一个非常典型的例子是 如果代价函数 J(θ) 的下降小于 一个很小的值 ε 那么就认为已经收敛 比如可以选择 1e-3 但我发现 通常要选择一个合适的阈值 ε 是相当困难的 因此 为了检查 梯度下降算法是否收敛 我实际上还是 通过看 左边的这条曲线图 而不是依靠自动收敛测试 此外 这种曲线图 也可以 在算法没有正常工作时 提前警告你 具体地说 如果代价函数 J(θ) 随迭代步数 的变化曲线是这个样子 J(θ) 实际上在不断上升 那就很明显的表示 梯度下降算法没有正常工作 而这样的曲线,通常意味着你应该使用较小的学习率a 这样的曲线图表示你的学习率a太大了,因此得到的结果也会不断跳过最小值,变得越来越大,因此应该使用较小的学习率a 这种图也是要选择小的a a不可以太大,也不可以太小 一般尝试的a值 Features and Polynomial Regression 特征和多项式回归 你现在了解了多变量的线性回归 在本段视频中 我想告诉你 一些用来 选择特征的方法以及 如何得到不同的学习算法 当选择了合适的特征后 这些算法往往是非常有效的 另外 我也想 给你们讲一讲多项式回归 它使得你们能够使用 线性回归的方法来拟合 非常复杂的函数 甚至是非线性函数 以预测房价为例 假设你有两个特征 分别是房子临街的宽度和垂直宽度 这就是我们想要卖出的房子的图片 临街宽度 被定义为这个距离 其实就是它的宽度 或者说是 你拥有的土地的宽度 如果这块地都是你的的话 而这所房子的 纵向深度就是 你的房子的深度 这是正面的宽度 这是深度 我们称之为临街宽度和纵深 你可能会 像这样 建立一个 线性回归模型 其中临街宽度 是你的第一个特征x1 纵深是你的第二个 特征x2 但当我们在 运用线性回归时 你不一定非要直接用 给出的 x1 和 x2 作为特征 其实你可以自己创造新的特征 因此 如果我要预测 房子的价格 我真正要需做的 也许是 确定真正能够决定 我房子大小 或者说我土地大小 的因素是什么 因此 我可能会创造一个新的特征 我称之为 x 它是临街宽度与纵深的乘积 这是一个乘法符号 它是临街宽度与纵深的乘积 这得到的就是我拥有的土地的面积 然后 我可以把 假设选择为 使其只使用 一个特征 也就是我的 土地的面积 对吧？ 由于矩形面积的 计算方法是 矩形长和宽相乘 因此 这取决于 你从什么样的角度 去审视一个特定的问题 而不是 只是直接去使用临街宽度和纵深 这两个我们只是碰巧在开始时 使用的特征 有时 通过定义 新的特征 你确实会得到一个更好的模型 与选择特征的想法 密切相关的一个概念 被称为多项式回归(polynomial regression) 比方说 你有这样一个住房价格的数据集 为了拟合它 可能会有多个不同的模型供选择 其中一个你可以选择的是像这样的二次模型 因为直线似乎并不能很好地拟合这些数据 因此 也许你会想到 用这样的二次模型去拟合数据 你可能会考量 是关于价格的一个二次函数 也许这样做 会给你一个 像这样的拟合结果 但是 然后你可能会觉得 二次函数的模型并不好用 因为 一个二次函数最终 会降回来 而我们并不认为 房子的价格在高到一定程度后 会下降回来 因此 也许我们会 选择一个不同的多项式模型 并转而选择使用一个 三次函数 在这里 现在我们有了一个三次的式子 我们用它进行拟合 我们可能得到这样的模型 也许这条绿色的线 对这个数据集拟合得更好 因为它不会在最后下降回来 那么 我们到底应该如何将模型与我们的数据进行拟合呢？ 使用多元线性回归的方法 我们可以 通过将我们的算法做一个非常简单的修改来实现它 按照我们以前假设的形式 我们知道如何对 这样的模型进行拟合 其中 ħθ(x) 等于 θ0 +θ1×x1 + θ2×x2 + θ3×x3 那么 如果我们想 拟合这个三次模型 就是我用绿色方框框起来的这个 现在我们讨论的是 为了预测一栋房子的价格 我们用 θ0 加 θ1 乘以房子的面积 加上 θ2 乘以房子面积的平方 因此 这个式子与那个式子是相等的 然后再加 θ3 乘以 房子面积的立方 为了将这两个定义 互相对应起来 为了做到这一点 我们自然想到了 将 x1 特征设为 房子的面积 将第二个特征 x2 设为 房屋面积的平方 将第三个特征 x3 设为 房子面积的立方 那么 仅仅通过将 这三个特征这样设置 然后再应用线性回归的方法 我就可以拟合 这个模型 并最终 将一个三次函数拟合到我的数据上 我还想再说一件事 那就是 如果你像这样选择特征 那么特征的归一化 就变得更重要了 因此 如果 房子的大小范围在 1到1000之间 那么 比如说 从1到1000平方尺 那么 房子面积的平方 的范围就是 一到一百万 也就是 1000的平方 而你的第三个特征 x的立方 抱歉 你的第三个特征 x3 它是房子面积的 立方 范围会扩大到 1到10的9次方 因此 这三个特征的范围 有很大的不同 因此 如果你使用梯度下降法 应用特征值的归一化是非常重要的 这样才能将他们的 值的范围变得具有可比性 最后 这里是最后一个例子 关于如何使你 真正选择出要使用的特征 此前我们谈到 一个像这样的二次模型 并不是理想的 因为 你知道 也许一个二次模型能很好地拟合 这个数据 但二次 函数最后会下降 这是我们不希望的 就是住房价格往下走 像预测的那样 出现房价的下降 但是 除了转而 建立一个三次模型以外 你也许有其他的选择 特征的方法 这里有很多可能的选项 但是给你另外一个 合理的选择的例子 另一种合理的选择 可能是这样的 一套房子的价格是 θ0 加 θ1 乘以 房子的面积 然后 加 θ2 乘以房子面积的平方根 可以吧？ 平方根函数是 这样的一种函数 也许θ1 θ2 θ3 中会有一些值 会捕捉到这个模型 从而使得这个曲线看起来 是这样的 趋势是上升的 但慢慢变得 平缓一些 而且永远不会 下降回来 因此 通过深入地研究 在这里我们研究了平方根 函数的形状 并且 更深入地了解了选择不同特征时数据的形状 有时可以得到更好的模型 在这段视频中 我们探讨了多项式回归 也就是 如何将一个 多项式 如一个二次函数 或一个三次函数拟合到你的数据上 除了这个方面 我们还讨论了 在使用特征时的选择性 例如 我们不使用 房屋的临街宽度和纵深 也许 你可以 把它们乘在一起 从而得到 房子的土地面积这个特征 实际上 这似乎有点 难以抉择 这里有这么多 不同的特征选择 我该如何决定使用什么特征呢 在之后的课程中 我们将 探讨一些算法 它们能够 自动选择要使用什么特征 因此 你可以使用一个算法 观察给出的数据 并自动为你选择 到底应该选择 一个二次函数 或者一个三次函数 还是别的函数 但是 在我们 学到那种算法之前 现在我希望你知道 你需要选择 使用什么特征 并且通过设计不同的特征 你能够用更复杂的函数 去拟合你的数据 而不是只用 一条直线去拟合 特别是 你也可以使用多项式 函数 有时候 通过采取适当的角度来观察 特征就可以 得到一个更符合你的数据的模型 Normal Equation 正规方程 在这段视频中 我们要讲 正规方程 (Normal Equation)对于某些线性回归问题 用正规方程法求解参数 θ 的最优值更好 具体而言 到目前为止 我们一直在使用的线性回归的算法 是梯度下降法 就是说 为了最小化代价函数 J(θ) 来最小化这个 我们使用的迭代算法 需要经过很多步 也就是说通过多次迭代来计算梯度下降 来收敛到全局最小值 相反地 正规方程法提供了一种求 θ 的解析解法 所以与其使用迭代算法 我们可以直接一次性求解θ的最优值 所以说基本上 一步就可以得到优化值 正规方程法有一些优点 也有一些缺点 但是在我们讲解这个 和何时使用标准方程之前 让我们先对这个算法有一个直观的理解 我们举一个例子来解释这个问题 我们假设 有一个非常简单的代价函数 J(θ) 它就是一个实数 θ 的函数 所以现在 假设 θ 只是一个标量 或者说 θ 只有一行 它是一个数字 不是向量 假设我们的代价函数 J 是这个实参数 θ 的二次函数 所以 J(θ) 看起来是这样的 那么如何最小化一个二次函数呢? 对于那些了解一点微积分的同学来说 你可能知道 最小化的一个函数的方法是 对它求导 并且将导数置零 所以对 J 求关于 θ 的导数 我不打算推导那些公式 你把那个导数置零 这样你就可以求得 使得 J(θ) 最小的 θ 值 这是数据为实数的 一个比较简单的例子 在这个问题中 我们感兴趣的是 θ不是一个实数的情况 它是一个n+1维的参数向量 并且 代价函数 J 是这个向量的函数 也就是 θ0 到 θm 的函数 一个代价函数看起来是这样 像右边的这个平方代价函数 我们如何最小化这个代价函数J? 实际上 微积分告诉我们一种方法 对每个参数 θ 求 J 的偏导数 然后把它们全部置零 如果你这样做 并且求出θ0 θ1 一直到θn的值 这样就能得到能够最小化代价函数 J 的 θ 值 如果你真的做完微积分和求解参数 θ0 到 θn 你会发现这个偏微分最终可能很复杂 接下来我在视频中要做的 实际上不是遍历所有的偏微分 因为这样太久太费事 我只是想告诉你们 你们想要实现这个过程所需要知道内容 这样你就可以解出 偏导数为0时 θ的值 换个方式说 或者等价地 这个 θ 能够使得代价函数 J(θ) 最小化 我发现可能只有熟悉微积分的同学 比较容易理解我的话 所以 如果你不了解 或者不那么了解微积分 也不必担心 我会告诉你 要实现这个算法并且使其正常运行 你所需的必要知识 举个例子 我想运行这样一个例子 假如说我有 m=4 个训练样本 假如说我有 m=4 个训练样本 为了实现正规方程法 我要这样做 看我的训练集 在这里就是这四个训练样本 在这种情况下 我们假设 这四个训练样本就是我的所有数据 我所要做的是 在我的训练集中加上一列对应额外特征变量的x0 就是那个取值永远是1的 接下来我要做的是 构建一个矩阵 X 这个矩阵基本包含了训练样本的所有特征变量 所以具体地说 这里有我所有的特征变量 我们要把这些数字 全部放到矩阵中 X 中 所以只是 每次复制一列的数据 我要对 y 做类似的事情 我要对我们将要预测的值 构建一个向量 像这样的 并且称之为向量 y 所以 X 会是一个 m*(n+1) 维矩阵 y 会是一个 m 维向量 其中 m 是训练样本数量 n 是特征变量数 n+1 是因为我加的这个额外的特征变量 x0 最后 如果你用矩阵 X 和向量 y 来计算这个 最后 θ 等于 X 转置乘以 X 的逆 乘以 X 转置 乘以 y 这样就得到能够使得代价函数最小化的 θ 幻灯片上的内容比较多 我讲解了这样一个数据组的一个例子 让我把这个写成更加通用的形式 在之后的视频中 我会仔细介绍这个方程 在一般情况下 假如我们有 m 个训练样本 x(1) y(1) 直到 x(m) y(m) n 个特征变量 所以每一个训练样本 xi 可能看起来像一个向量 像这样一个 n+1 维特征向量 我要构建矩阵 X 的方法 也被称为设计矩阵 如下所示 每个训练样本给出一个这样的特征向量 也就是说 这样的 n+1 维向量 我构建我的设计矩阵 X 的方法 就是构建这样的矩阵 接下来我要做的是将 取第一个训练样本 也就是一个向量 取它的转置 它最后是这样 扁长的样子 让 x1 转置作为我设计矩阵的第一行 然后我要把我的 第二个训练样本 x2 进行转置 让它作为 X 的第二行 以此类推 直到最后一个训练样本 取它的转置作为矩阵 X 的最后一行 这样矩阵 X 就是一个 m*(n+1) 维矩阵 举个具体的例子 假如我只有一个特征变量 就是说除了 x0 之外只有一个特征变量 而 x0 始终为1 所以如果我的特征向量 xi等于1 也就是x0 和某个实际的特征变量 比如说房屋大小 那么我的设计矩阵 X 会是这样 第一行 就是这个的转置 所以最后得到1 然后 x(1)1 对于第二行 我们得到1 然后 x(1)2 这样直到1 然后 x(1)m 这就会是一个 m*2 维矩阵 所以 这就是如何构建矩阵X 和向量y 有时我可能会在上面画一个箭头 来表示这是一个向量 但很多时候 我就只写y 是一样的 向量y 是这样求得的 把所有标签 所有训练集中正确的房子价格 放在一起 得到一个 m 维向量 y 最后 构建完矩阵 X 和向量 y 我们就可以通过计算 X转置 乘以X的逆 乘以X转置 乘以y 来得到θ 我现在就想确保你明白这个等式 并且知道如何实现它 所以具体来说 什么是 X 的转置乘以 X 的逆？ X的转置 乘以 X的逆 是 X转置 乘以X的逆矩阵 具体来说 如果你令A等于 X转置乘以X X的转置是一个矩阵 阵 我们把这个矩阵称为 A 那么 X转置乘以X的逆 就是矩阵 A 的逆 也就是 1/A 这就是计算过程 先计算 X转置乘以X 然后计算它的逆 我们还没有谈到Octave 我们将在之后的视频中谈到这个 但是在 Octave 编程语言 或者类似的 MATLAB 编程语言里 计算这个量的命令是基本相同的 X转置 乘以X的逆 乘以X转置 乘以y 的代码命令如下所示 在 Octave 中 X’ 表示 X 转置 这个用红色框起来的表达式 计算的是 X 转置乘以 X 函数 pinv 是用来计算逆矩阵的函数 所以这个计算 X转置 乘以X的逆 然后乘以X转置 再乘以y 这样就算完了这个式子 我没有证明这个式子 尽管我并不打算这么做 但是数学上是可以证明的 这个式子会给出最优的 θ 值 就是说如果你令 θ 等于这个 就是说如果你令 θ 等于这个 这个 θ 值会最小化这个线性回归的代价函数 J(θ) 最后一点 在之前视频中我提到特征变量归一化 和让特征变量在相似的范围内的想法 将所有的值归一化在类似范围内 如果你使用正规方程法 那么就不需要归一化特征变量 实际上这是没问题的 如果某个特征变量 x1 在 0到1的区间 某个特征变量 x2 在0到1000的区间 某个特征变量x3 在0到10^-5的区间 然后如果使用正规方程法 这样就没有问题 不需要做特征变量归一化 但如果你使用梯度下降法 特征变量归一化就很重要 最后 你何时应该使用梯度下降法 而何时应该使用正规方程法呢？ 这里列举了一些它们的优点和缺点 假如你有 m 个训练样本和 n 个特征变量 梯度下降法的缺点之一就是 你需要选择学习速率 α 这通常表示需要运行多次 尝试不同的学习速率 α 然后找到运行效果最好的那个 所以这是一种额外的工作和麻烦 梯度下降法的另一个缺点是 它需要更多次的迭代 因为一些细节 计算可能会更慢 我们一会儿会看到更多的东西 至于正规方程 你不需要选择学习速率 α 所以就非常方便 也容易实现 你只要运行一下 通常这就够了 并且你也不需要迭代 所以不需要画出 $J(\theta)$ 的曲线 来检查收敛性或者采取所有的额外步骤 到目前为止 天平似乎倾向于正规方程法 这里列举一些正规方程法的缺点 和梯度下降法的优点 梯度下降法在有很多特征变量的情况下也能运行地相当好 所以即使你有上百万的特征变量 所以即使你有上百万的特征变量 你可以运行梯度下降法 并且通常很有效 它会正常的运行 相对地 正规方程法 为了求解参数θ 需要求解这一项 我们需要计算这项 X转置乘以X的逆 这个是一个 n*n 的矩阵 如果你有 n 个特征变量的话 因为如果你看一下 X转置乘以X 的维度 你可以发现他们的积的维度 X转置乘以X 是一个 n*n 的矩阵 其中 n是特征变量的数量 实现逆矩阵计算所需要的计算量 大致是矩阵维度的三次方 因此计算这个逆矩阵需要计算大致 n 的三次方 有时稍微比计算 n 的三次方快一些 但是对我们来说很接近 所以如果特征变量的数量 n 很大的话 那么计算这个量会很慢 实际上标准方程法会慢很多 因此如果 n 很大 我可能还是会使用梯度下降法 因为我们不想花费 n 的三次方的时间 但如果 n 比较小 那么标准方程法可能更好地求解参数 θ 那么怎么叫大或者小呢？ 那么 如果 n 是上百的 计算百位数乘百位数的矩阵 对于现代计算机来说没有问题 如果 n 是上千的 我还是会使用正规方程法 千位数乘千位数的矩阵做逆变换 对于现代计算机来说实际上是非常快的 但如果 n 上万 那么我可能会开始犹豫 上万乘上万维的矩阵作逆变换 会开始有点慢 此时我可能开始倾向于 梯度下降法 但也不绝对 n 等于一万 你可以 逆变换一个一万乘一万的矩阵 但如果 n 远大于此 我可能就会使用梯度下降法了 所以如果 n 等于10^6 有一百万个特征变量 那么做百万乘百万的矩阵的逆变换 就会变得非常费时间 在这种情况下我一定会使用梯度下降法 所以很难给出一个确定的值 来决定何时该换成梯度下降法 但是 对我来说通常是 在一万左右 我会开始考虑换成梯度下降法 或者我们将在以后讨论到的其他算法 总结一下 只要特征变量的数目并不大 正规方程是一个很好的 计算参数 θ 的替代方法 具体地说 只要特征变量数量小于一万 我通常使用正规方程法 而不使用梯度下降法 预告一下在之后的课程中我们要讲的 随着我们要讲的学习算法越来越复杂 例如 当我们讲到分类算法 像逻辑回归算法 我们会看到 实际上对于那些算法 并不能使用正规方程法 对于那些更复杂的学习算法 我们将不得不仍然使用梯度下降法 因此 梯度下降法是一个非常有用的算法 可以用在有大量特征变量的线性回归问题 或者我们以后在课程中 会讲到的一些其他的算法 因为 标准方程法不适合或者不能用在它们上 但对于这个特定的线性回归模型 正规方程法是一个 比梯度下降法更快的替代算法 所以 根据具体的问题 所以 以及你的特征变量的数量 这两算法都是值得学习的正规方程笔记 到目前为止，我们都在使用梯度下降算法，但是对于某些线性回归问题，正规方程方法是更好的解决方案。如： 正规方程是通过求解下面的方程来找出使得代价函数最小的参数的：$\frac{\partial}{\partial{\theta_{j}}}J\left( {\theta_{j}} \right)=0$ 。 假设我们的训练集特征矩阵为 $X$（包含了 ${{x}_{0}}=1$）并且我们的训练集结果为向量 $y$，则利用正规方程解出向量 $\theta ={{\left( {X^T}X \right)}^{-1}}{X^{T}}y$ 。上标T代表矩阵转置，上标-1 代表矩阵的逆。设矩阵$A={X^{T}}X$，则：${{\left( {X^T}X \right)}^{-1}}={A^{-1}}$以下表示数据为例： 即： 运用正规方程方法求解参数： 在 Octave 中，正规方程写作： 1pinv(X&apos;*X)*X&apos;*y 注：对于那些不可逆的矩阵（通常是因为特征之间不独立，如同时包含英尺为单位的尺寸和米为单位的尺寸两个特征，也有可能是特征数量大于训练集的数量），正规方程方法是不能用的。 梯度下降与正规方程的比较： 梯度下降 正规方程 需要选择学习率$\alpha$ 不需要 需要多次迭代 一次运算得出 当特征数量$n$大时也能较好适用 需要计算${{\left( {{X}^{T}}X \right)}^{-1}}$ 如果特征数量n较大则运算代价大，因为矩阵逆的计算时间复杂度为$O\left( {{n}^{3}} \right)$，通常来说当$n$小于10000 时还是可以接受的 适用于各种类型的模型 只适用于线性模型，不适合逻辑回归模型等其他模型 总结一下，只要特征变量的数目并不大，标准方程是一个很好的计算参数$\theta $的替代方法。具体地说，只要特征变量数量小于一万，我通常使用标准方程法，而不使用梯度下降法。 随着我们要讲的学习算法越来越复杂，例如，当我们讲到分类算法，像逻辑回归算法，我们会看到，实际上对于那些算法，并不能使用标准方程法。对于那些更复杂的学习算法，我们将不得不仍然使用梯度下降法。因此，梯度下降法是一个非常有用的算法，可以用在有大量特征变量的线性回归问题。或者我们以后在课程中，会讲到的一些其他的算法，因为标准方程法不适合或者不能用在它们上。但对于这个特定的线性回归模型，标准方程法是一个比梯度下降法更快的替代算法。所以，根据具体的问题，以及你的特征变量的数量，这两种算法都是值得学习的。 正规方程的python实现： 1234567import numpy as npdef normalEqn(X, y): theta = np.linalg.inv(X.T@X)@X.T@y #X.T@X等价于X.T.dot(X) return theta 正规方程及不可逆性在这段视频中谈谈正规方程 ( normal equation )，以及它们的不可逆性。由于这是一种较为深入的概念，并且总有人问我有关这方面的问题，因此，我想在这里来讨论它，由于概念较为深入，所以对这段可选材料大家放轻松吧，也许你可能会深入地探索下去，并且会觉得理解以后会非常有用。但即使你没有理解正规方程和线性回归的关系，也没有关系。 我们要讲的问题如下：$\theta ={{\left( {X^{T}}X \right)}^{-1}}{X^{T}}y$ 有些同学曾经问过我，当计算 $\theta$=inv(X&#39;X ) X&#39;y ，那对于矩阵$X'X$的结果是不可逆的情况咋办呢?如果你懂一点线性代数的知识，你或许会知道，有些矩阵可逆，而有些矩阵不可逆。我们称那些不可逆矩阵为奇异或退化矩阵。 问题的重点在于$X'X$的不可逆的问题很少发生，在Octave里，如果你用它来实现$\theta$的计算，你将会得到一个正常的解。在Octave里，有两个函数可以求解矩阵的逆，一个被称为pinv()，另一个是inv()，这两者之间的差异是些许计算过程上的，一个是所谓的伪逆，另一个被称为逆。使用pinv() 函数可以展现数学上的过程，这将计算出$\theta$的值，即便矩阵$X'X$是不可逆的。 在pinv() 和 inv() 之间，又有哪些具体区别呢 ? 其中inv() 引入了先进的数值计算的概念。 出现不可逆的一般有两个原因,第一个原因是:如果不知何故,再你的学习问题中,你有多余的功能 例如，在预测住房价格时，如果${x_{1}}$是以英尺为尺寸规格计算的房子，${x_{2}}$是以平方米为尺寸规格计算的房子，同时，你也知道1米等于3.28英尺 ( 四舍五入到两位小数 )，这样，你的这两个特征值将始终满足约束：${x_{1}}={x_{2}}*{{\left( 3.28 \right)}^{2}}$。实际上，你可以用这样的一个线性方程，来展示那两个相关联的特征值，矩阵X&#39;X将是不可逆的。 第二个原因是，在你想用大量的特征值，尝试实践你的学习算法的时候，可能会导致矩阵$X'X$的结果是不可逆的。具体地说，在$m$小于或等于n的时候，例如，有$m$等于10个的训练样本也有$n$等于100的特征数量。要找到适合的$(n +1)$ 维参数矢量$\theta$，这将会变成一个101维的矢量，尝试从10个训练样本中找到满足101个参数的值，这工作可能会让你花上一阵子时间，但这并不总是一个好主意。因为，正如我们所看到你只有10个样本，以适应这100或101个参数，数据还是有些少。 稍后我们将看到，如何使用小数据样本以得到这100或101个参数，通常，我们会使用一种叫做正则化的线性代数方法，通过删除某些特征或者是使用某些技术，来解决当$m$比$n$小的时候的问题。即使你有一个相对较小的训练集，也可使用很多的特征来找到很多合适的参数。 总之当你发现的矩阵$X'X$的结果是奇异矩阵，或者找到的其它矩阵是不可逆的，我会建议你这么做。 首先，看特征值里是否有一些多余的特征，像这些${x_{1}}$和${x_{2}}$是线性相关的，互为线性函数。同时，当有一些多余的特征时，可以删除这两个重复特征里的其中一个，无须两个特征同时保留，将解决不可逆性的问题。因此，首先应该通过观察所有特征检查是否有多余的特征，如果有多余的就删除掉，直到他们不再是多余的为止，如果特征数量实在太多，我会删除些 用较少的特征来反映尽可能多内容，否则我会考虑使用正规化方法。如果矩阵$X'X$是不可逆的，（通常来说，不会出现这种情况），如果在Octave里，可以用伪逆函数pinv() 来实现。这种使用不同的线性代数库的方法被称为伪逆。即使$X'X$的结果是不可逆的，但算法执行的流程是正确的。总之，出现不可逆矩阵的情况极少发生，所以在大多数实现线性回归中，出现不可逆的问题不应该过多的关注${X^{T}}X$是不可逆的。 增加内容： $\theta ={{\left( {X^{T}}X \right)}^{-1}}{X^{T}}y$ 的推导过程： $J\left( \theta \right)=\frac{1}{2m}\sum\limits_{i=1}^{m}{{{\left( {h_{\theta}}\left( {x^{(i)}} \right)-{y^{(i)}} \right)}^{2}}}$ 其中：${h_{\theta}}\left( x \right)={\theta^{T}}X={\theta_{0}}{x_{0}}+{\theta_{1}}{x_{1}}+{\theta_{2}}{x_{2}}+...+{\theta_{n}}{x_{n}}$ 将向量表达形式转为矩阵表达形式，则有$J(\theta )=\frac{1}{2}{{\left( X\theta -y\right)}^{2}}$ ，其中$X$为$m$行$n$列的矩阵（$m$为样本个数，$n$为特征个数），$\theta$为$n$行1列的矩阵，$y$为$m$行1列的矩阵，对$J(\theta )$进行如下变换 $J(\theta )=\frac{1}{2}{{\left( X\theta -y\right)}^{T}}\left( X\theta -y \right)$ ​ $=\frac{1}{2}\left( {{\theta }^{T}}{{X}^{T}}-{{y}^{T}} \right)\left(X\theta -y \right)$ ​ $=\frac{1}{2}\left( {{\theta }^{T}}{{X}^{T}}X\theta -{{\theta}^{T}}{{X}^{T}}y-{{y}^{T}}X\theta -{{y}^{T}}y \right)$ 接下来对$J(\theta )$偏导，需要用到以下几个矩阵的求导法则: $\frac{dAB}{dB}={{A}^{T}}$ $\frac{d{{X}^{T}}AX}{dX}=2AX$ 所以有: $\frac{\partial J\left( \theta \right)}{\partial \theta }=\frac{1}{2}\left(2{{X}^{T}}X\theta -{{X}^{T}}y -{{X}^{T}}y -0 \right)$ ​ $={{X}^{T}}X\theta -{{X}^{T}}y$ 令$\frac{\partial J\left( \theta \right)}{\partial \theta }=0$, 则有$\theta ={{\left( {X^{T}}X \right)}^{-1}}{X^{T}}y$]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习入门</category>
      </categories>
      <tags>
        <tag>Linear-Regression</tag>
        <tag>多变量线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章 线性代数回顾(Linear Algebra Review)]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9B%9E%E9%A1%BE-Linear-Algebra-Review%2F</url>
    <content type="text"><![CDATA[Matrices and Vectors（矩阵和向量） 我们先复习一下线性代数的知识 在这段视频中 我会向大家介绍矩阵和向量的概念 矩阵是指 由数字组成的矩形阵列 并写在方括号中间 例如 屏幕中所示的一个矩阵 先写一个左括号 然后是一些数字 这些数字可能是 机器学习问题的特征值 也可能表示其他意思 不过现在不用管具体的数字 然后我用右方括号将其括起来 这样就得到了一个矩阵 接下来 看一下其他矩阵的例子 依次写下1 2 3 4 5 6 因此实际上矩阵 可以说是二维数组的 另一个名字 另外 我们还需要知道的是 矩阵的维度=矩阵的行数乘以列数 具体到这个例子 看左边 包括1 2 3 4共4行 以及2列 因此 这个例子是一个 4 × 2的矩阵 即行数乘以列数 4行乘2列 右边的矩阵有两行 这是第一行 这是第二行 此外包括三列 这是第一列 第二列 第三列 因此 我们把 这个矩阵称为一个 2 × 3维的矩阵 所以我们说这个矩阵的维度是2 × 3维 有时候大家会发现 书写有些不同 比如左边的矩阵 写成了R4 × 2 具体而言 大家会将该矩阵称作 是集合R4×2的元素 因此 也就是说 这个矩阵 R4×2代表所有4×2的矩阵的集合 而右边的这个矩阵 有时候也写作一个R2×3的矩阵 因此 如果你看到2×3 如果你看到 有些地方表达为 4×2的或者2×3的 一般都是指 一个特定维度的矩阵 接下来 让我们来谈谈如何表达矩阵的某个特定元素 这里我说矩阵元素 而不是矩阵 我的意思是 矩阵的条目数 也就是矩阵内部的某个数 所以 标准的表达是 如果A是 这个矩阵 那么A下标 ij 表示的是 i j对应的那个数字 意思是矩阵的第i行和第j列 对应的那个数 例如 A11 表示的是第1行 第1列所对应的那个元素 所以这是 第一行和第一列 因此A11 就等于 1402 另一个例子A12 表示的是第一行第二列 对应的那个数 所以A12 将等于191 我希望你不会犯下面的错误 但如果你这么写的话 如果你写出了A43 这应该表示的是 第四行第三列 而你知道 这个矩阵没有第三列 因此这是未定义的 接下来让我们来谈谈什么是向量 一个向量是一种特殊的矩阵 向量是只有一列的矩阵 所以 你有一个 n×1 矩阵 还记得吗 N是行数 而这里的1 表示的是列数 所以 只有一列的矩阵 就是我们所说的向量 因此 这里是一个向量的 例子 比如说 我有 n = 4 个元素 所以我们也把这个称为 另一个术语是 这是一个四维的向量 也就意味着 这是一个含有 4个元素的向量 而且 前面我们讲 矩阵的时候提到过 这个符号R3×2 表示的是一个3行2列的矩阵 而对于这个向量 我们也同样可以 表示为集合R4 因此 这个R4是指 一个四维向量的集合 接下来让我们来谈谈如何引用向量的元素 我们将使用符号 yi来代表 向量y的第i个元素 所以 如果这个向量是y 那么y下标i 则表示它的第i个元素 所以y1表示第一个元素 460 y2表示第二个元素 232 这是第二个元素 还有y3等于 315 等等 只有y1至y4是有意义的 因为这定义的是一个四维向量 此外 事实上 有两种方法来表达 某个向量中某个索引 是这两种 有时候 人们会使用 1-索引 有时候用0-索引 因此 左边这个例子 是一个1-索引向量 它的元素写作y1 y2 y3 y4 而右边这个向量 是0-索引的一个例子 我们的索引 从下标0开始 因此 元素从y0至y3 对于很多机器学习的应用问题来说 0-索引向量为我们提供了一个更方便的符号表达 所以你通常应该 做的是 除非特别指定 你应该默认我们使用的是1-索引法表示向量 在本课程的后面所有 关于线性代数的视频中 我都将使用1-索引法表示向量 按照惯例 通常在书写矩阵和向量时 大多数人会使用大写字母 来表示矩阵 因此 我们要使用 大写字母 如 A B C X 来表示矩阵 而通常我们会使用小写字母 像a b x y 来表示数字 或是原始的数字 或标量 或向量 这是实际的使用习惯 我们也经常看到 使用小写字母y 来表示向量 但我们平时 是用大写字母来表示矩阵 Matrices and Vectors笔记 矩阵是二维数组 上面的矩阵有四行三列，所以它是一个4 x 3的矩阵 向量是·一列和许多行·的矩阵： 所以向量是矩阵的一个子集。上述向量是一个4×1矩阵。 表示法和条款： $A_{ij}$引用矩阵A的第i行和第j列中的元素。 具有’n’行的矢量被称为’n’维矢量。 $v_i$指矢量的第i行中的元素。 一般来说，我们所有的向量和矩阵都是1索引的。请注意，对于某些编程语言，这些数组是0索引的。 矩阵通常用大写字母表示，而向量则用小写字母表示。 “标量”表示对象是单个值，而不是矢量或矩阵。 是指一组标量实数。 是指实数的n维向量的集合。 Addition and Scalar Multiplication 在这段视频中 我们要讲 我们将讨论矩阵的加法和减法运算 以及如何进行 数和矩阵的乘法 也就是标量乘法 让我们从下面这个例子开始 假设有这样两个矩阵 如果想对它们做求和运算 应该怎么做呢？ 或者说 矩阵的加法到底是如何进行的？ 答案是 如果你想将两个矩阵相加 你只需要将这两个矩阵的 每一个元素都逐个相加 因此 两个矩阵相加 所得到的结果 就是一个新的矩阵 它的第一个元素 是1和4相加的结果 因此我们得到5 接下来是第二个元素 用2和2相加 因此得到4 然后是3加0得到3 以此类推 这里我用不同颜色区别一下 接下来右边这一列元素 就是0.5 10和2 这里大家不难发现 只有相同维度的两个矩阵才能相加 对于这个例子而言 一個3 x 2的矩陣 也就是说矩阵的行数为3 列数是2 因此是3行2列 第二个矩阵 也是一个3行2列的矩阵 因此这两个矩阵相加的结果 也是一个3行2列的矩阵 所以你只能将相同维度的矩阵 进行相加运算 同时 所得到的结果 将会是一个新的矩阵 这个矩阵与相加的两个矩阵维度相同 反过来 如果你想将这样两个矩阵相加 这是一个3行2列的矩阵 行数为3 列数为2 而这一个是2行2列的矩阵 那么由于这两个矩阵 维度是不相同的 这就出现错误了 所以我们不能将它们相加 也就是说 这两个矩阵的和是没有意义的 这就是矩阵的加法运算 接下来 我们讨论矩阵和标量的乘法运算 这里所说的标量 可能是一个复杂的结构 或者只是一个简单的数字 或者说实数 标量在这里指的就是实数 如果我们用数字3来和这个矩阵相乘 那么结果是显而易见的 你只需要将矩阵中的所有元素 都和3相乘 每一个都逐一与3相乘 因此 1和3相乘 结果是3 2和3相乘 结果是6 最后3乘以3得9 我再换一下颜色 0乘以3得0 3乘以5得15 最后3乘以1得3 这样得到的这个矩阵 就是左边这个矩阵和3相乘的结果 我们再次注意到 这是一个3行2列的矩阵 得到的结果矩阵 维度也是相同的 也就是说这两个矩阵 都是3行2列 这也是3行2列 另外 你也可以写成另一种方式 这里是3和这个矩阵相乘 你也可以把这个矩阵写在前面 把左边这个矩阵照抄过来 我们也可以用这个矩阵乘以3 也就是说 3乘以这个矩阵 和这个矩阵乘以3 结果都是一回事 都是中间的这个矩阵 你也可以用矩阵除以一个数 那么 我们可以看到 用这个矩阵除以4 实际上就是 用四分之一 来和这个矩阵相乘 4 0 6 3 不难发现 相乘的结果是 1/4和4相乘为1 1/4和0相乘得0 1/4乘以6 结果是3/2 6/4也就是3/2 最后1/4乘以3得3/4 这样我们就得到了 这个矩阵除以4的结果 结果就是是右边这个矩阵 最后 我们来看一个稍微复杂一点的例子 我们可以把所有这些运算结合起来 在这个运算中 需要用3来乘以这个向量 然后加上一个向量 再减去另一个向量除以3的结果 让我们先来整理一下这几项运算 首先第一个运算 很明显这是标量乘法的例子 因为这里是用3来乘以一个矩阵 然后这一项 很显然这是另一个标量乘法 或者可以叫标量除法 其实也就是1/3乘以这个矩阵 因此 如果我们先考虑这两项运算 那么我们将得到的是 我们看一下 3乘以这个矩阵 结果是3 12 6 然后和中间的矩阵相加 也就是0 0 5 最后再减去1 0 2/3 同样地 为了便于理解 我们再来梳理一下这几项 这里的这个加号 表明这是一个矩阵加法 对吧？ 当然这里是向量 别忘了 向量是特殊的矩阵 对吧？ 或者你也可以称之为 向量加法运算 同样 这里的减号表明 这是一个矩阵减法运算 但由于这是一个n行1列的矩阵 实际上是3行1列 因此这个矩阵 实际上是也一个向量 一个列向量 因此也可以把它称作向量的减法运算 明白了吗 最后再整理一下 最终的结果依然是一个向量 向量的第一个元素 是3+0-1 就是3-1 也就是2 第二个元素是12+0-0 也就是12 最后第三个元素 6+5-(2/3) 也就是11-(2/3) 结果是10又三分之一 关闭右括号 我们得到了最终的结果 这是一个3行1列的矩阵 或者也可以说是 一个维度为3的向量 这就是这个运算式的计算结果 所以 你学会了矩阵或向量的加减运算 以及矩阵或向量跟标量 或者说实数 的乘法运算 到目前为止 我只介绍了如何进行 矩阵或向量与数的乘法运算 在下一讲中 我们将讨论一个更有趣的话题 那就是如何进行 两个矩阵的乘法运算加法和标量乘法笔记 Matrix Vector Multiplication 在本节课的视频中 讨论如何 将两个矩阵相乘 我们将从矩阵相乘的 特例 向量相乘开始 即 一个矩阵与一个向量相乘 让我们从一个例子开始 左边是一个矩阵 右边是一个向量 假如我们 将这个矩阵 与这个向量相乘 结果会怎样呢？ 我先快速计算出结果 然后我们再 退回去 查看每一个步骤 很明显 相乘的结果 将是 一个向量 我先将这部分完成 然后再来解释 我刚刚是怎么做的 要计算出结果向量的第一个元素 我将会 取这两个数字 并把他们 把矩阵 A 的 然后把对应相乘的结果加起来 取1乘以1 同时取3 乘以 5 计算得到1和15 相加得16 我将在这儿写上16 要计算第二行 的第二个元素 我需要将第二行 与这个向量相乘 所以我得到 4乘以1 加上0乘以5 结果等于4 因此在这里写上4 对于最后一个元素 我需要计算(2, 1) 乘以 (1, 5) 所以先计算2乘以1 再加上 1乘以5 最后结果为7 所以我在这儿写上7 事实证明 3x2的矩阵 和一个2x1的矩阵 即一个二维向量 相乘的结果 我们得到的 将是一个3×1 的矩阵 这个3×1的矩阵 就是这么得来的 也就是一个三维向量 我想 我可能计算时做得很快 你们并不一定能够 自己重复这个过程 下面让我们更加仔细的看一下 刚刚我做了些什么以及一个向量 和一个矩阵相乘的计算过程是怎样的 下面详细介绍了如何 计算一个矩阵与一个向量相乘 假设这是一个矩阵A 我希望将它乘以 一个向量x 结果记为 向量y 所以 矩阵A是一个 m×n维矩阵 有m行和n列 我们让它与一个 n×1的矩阵相乘 换言之 一个n维向量 明显地 这里的两个n是相等的 也就是说 这个矩阵的列数 有n列 必须要与 另一个相乘矩阵的行数相同 即必须匹配这个向量的维数。 这样相乘的结果 将会是一个n维 向量y m 将与 矩阵A的行数 相同 那么如何计算这个向量y呢？ 事实上 计算y的过程可以分解为 计算 yi 的值 让 A 的第 i 行元素 分别乘以向量 x 中的元素 并且相加 就是这样子 为了得到 y 的第一个元素 无论是多少 我们将会 把矩阵 A 的 第一行元素 每次同一个向量 x 的元素 相乘 我取第一个数 与第一个数相乘 然后取第二个数同第二个数相乘 取第三个数 与第三个数相乘 直到全部乘完 最后 将这些相乘的结果 加起来 这样我们就得到了 y 的第一个元素 然后我们 来计算 y 的第二个元素 接下来我们 取A的第二行 然后重复整个过程 现在 我们取A的第二行 将它 与其他元素相乘 也就是 x 的元素 将结果相加 这样我们就得到了 y 的第二个元素 依次计算下去 我们取A得第三行 逐行地与 向量x相乘 将结果加起来 然后得到第三个元素 以此类推 直到最后一行 所以 上述就是具体步骤 让我们再举一个例子 在这个例子中 我们先看一下矩阵的维度 左边是一个 3×4矩阵 右边是一个四维向量 也就是4×1矩阵 所以这样相乘的结果 将是 一个三维向量 我们在写的时候要给这个向量 留三个元素的空间 现在让我们一起来算一下 首先是第一个元素 我将会取这四个数 并将它们与向量x相乘 所以我需要计算 1×1 加上2×3 加1×2 加5×1 等于 1 +6 再加上2 +6 也就是14 而对边距来说 第二个元素 我要 取这一行 然后与向量 (0×1)+3相乘 我们将得到 0×1 + 3×3 0×2 + 4×1 等于 9 + 4 也就是13 最后 对最后一个元素 我将取最后一行 所以我得到了-1×1 -2×3 加上0×2 加上0×1 所以 我们将得到-1和-6 相加得 -7 明白? 所以我最后的答案是 一个向量 其中的元素为 14 我将不给这些字涂上颜色 13 -7 如前面说的 计算结果是一个3×1的矩阵 上述就是矩阵和向量相乘的方法 我知道 这张幻灯片上内容很多 如果你在看的过程中 不是很确定这些数字怎么来的 你可以随时暂停视频 慢慢地 仔细琢磨 整个计算过程 尽量 确保自己理解了 得到14 13 11 这些结果的每一个步骤 最后 我将教你们一个小技巧 假设我 有四间房子 这些房子有四种大小 我有一个 假设函数 用于预测房子的价格 我需要计算 四间房子的大小作为 h(x) 的大小即预测的房价 这里有一种简单的方法 可以同时计算四间房子的预测价格 我可以将它简单地 利用 矩阵向量相乘的思想来计算 所以 对于这个问题我会这么计算 首先我要构建一个 如下所示的矩阵 元素是1 1 1 1 然后我把四个房子的大小 写在这儿 我还需要构造一个向量 我的向量 它将是一个 二维向量 即 40 和 0.25 这是预测函数的两个系数 θ0 和 θ1 接下来 我要做的就是 将我构造好的矩阵和向量相乘 这是相乘符号 我将得到什么结果呢？ 左边是一个 4×2 矩阵 右边是一个 2×1 矩阵 所以结果 将是一个4×1向量 对吧 所以 让我在幻灯片上写上 结果将是 一个4×1的矩阵 输出结果也就是 一个四维向量 让我来把它写出来 用四个实数表示我的四个元素 事实上 结果的第一个元素 我的计算方式 是 将这一行同我的向量相乘 结果将是 -40×1 + 4.25×2104 顺便说一下 在先前的幻灯片中 我写的是 1× (-40) + 2104 × 0.25 但是顺序无关紧要 对吧？ -40×1 和 1×(-40)是一样的 这第一个元素 就是当x为2104时的 h 值 因此 这是我的第一个房子的预测价格 那么 第二个元素呢？ 你应该已经想到了 我要怎么计算第二个元素了 对吧? 我要把这个乘以我的向量 所以就是 -40×1 + 0.25×1416 这就是x为1416的 h 对吧? 这是第三个 和第四个 后面就依次计算这个4×1矩阵的第三和第四个元素 得出结果 这里 我画了绿色边框的部分 是一个实数 对吧？ 它是一个实数 这里 我画了洋红色边框的部分 紫色 洋红色 边框 是一个实数 对吧？ 所以右边 最右边 就是一个 4×1矩阵 是一个4维向量 这个例子的一个小技巧是 当你 在程序中实现这个过程的时候 当你有四间房子 你想使用自己的预测函数 来预测房子的价格 完成这些工作 你可以用一行代码搞定 我们后面会谈到Octave 以及编程语言 你可以只写一行代码就完成整个过程 你可以这样写 prediction = DataMatrix × Parameters 对吧 数据矩阵是这一部分 参数 是这一部分 这就是一个矩阵向量乘法 如果你这么做了 这个变量prediction 抱歉 我的字写得很潦草 只需要实现 这一行代码 如果你有一个做矩阵向量相乘的函数库的话 如果你这样做的话 右侧的prediction变量就会形成 一个4维向量 给你所有的预测价格 另一种计算方式是 作为一种矩阵向量相乘的方式 实际上就是一种 通过for循环 for 1 to 4 对吧？ 如果说你有一千间房子 就将是 for 1 to 1000 或者别的任何数 然后如果i等于的话 你必须写一个 有一个假设条件 I相等 然后需要做 比矩阵向量相乘多得多的工作 当你有 大量的房子的时候 如果你试图预测 不只是四座 或许是一千座房子的时候 事实证明 当你使用矩阵向量相乘的方法时 在计算机中 使用任何语言 不仅仅是Octave 还有C++ Java Python 等高级语言 以及其他语言 都可以很快的实现 事实证明 像左边这样子写代码 不仅可以 简化你的代码 现在你只需要 写一行代码 而不是一堆代码 而且 还有一个微妙的好处 我们后面将会了解到 就是基于你所有的房子 这样做计算效率将会更高 比你像右边那样 用代码实现公式 的方式效率 将会高很多 我后面在讨论向量化的时候 会详细地 讨论这个问题 所以 通过这种方式计算预测值 不仅代码更加简洁 而且效率更高 基本用不上 我们在后面 在其他模型中 计算实例的回归的时候 将会有效地利用到这一讲的内容 在接下来的视频中 我将会从特殊到一般 讲讲矩阵与矩阵相乘的情况 矩阵向量乘法笔记 矩阵和向量的乘法如图：m×n 的矩阵乘以 n×1 的向量，得到的是 m×1 的向量 举例 Matrix Matrix 在这段视频中我们将会讨论 矩阵 矩阵的乘法以及 如何将两个矩阵相乘 我们会使用这样一种方法 在线性回归中用以解决 参数计算的问题 这种方法会把θ0、θ1等参数都放在一起来计算 也就是说 我们不需要一个迭代的梯度下降算法 当我们谈到这个算法的时候 就会发现矩阵以及矩阵间的乘法运算 是你必须理解的关键步骤之一 所以让我们像往常那样 从一个例子开始 比方说 我有两个矩阵 我想将它们相乘 让我先只是按照这个例子做一遍（乘法） 然后告诉你这其中运算的细节 那么 我要做的第一件事是 我先把 右边这个矩阵的第一列 提取出来 然后我将会把 左边的这个矩阵和 之前取出来的这一列（前面提过的，向量）相乘 这只是第一列 是吧？ 然后我们可以看到 如果我 这么做 我就会得到向量（11,9） 所以这是与上个视频的矩阵 和向量的乘法是一样的 我已经提前算出了这个结果 是（11,9） 那么 之后的第二件事 我要做的就是 我将把第二列再单独提出出来 右边这个矩阵的第二列 然后我将要把它和 左边这个矩阵相乘 是的吧 所以 这就是那个矩阵 用右边的第二列 来乘以这个矩阵 因此 同样的 这是一个矩阵和 向量的乘法运算 这 就是你从上一个视频所学到的 如果你这么做 把这个矩阵和这个向量相乘 你会得到 （10,14）这个结果 顺便说一下 如果你想练习 矩阵和向量的乘法运算 那么就先暂停下视频 自己算一算结果对不对 好吧 现在我仅仅需要 将得到的这两个结果放在一起 那么这就是我的答案了 那么 我们可以看到 计算结果是 一个2 x 2的矩阵 我用来填充这个矩阵的方法 就是 把我的（11,9） 填在这里 把（10，14）填在 第二列 是的吧？ 所以 这就是如何 将两个矩阵相乘的 详细方法与过程 每次你只需要看 第二个矩阵的一列 然后把你的答案拼凑起来 再次强调下 我们将一步步的来计算 几秒中的时间里需要非常仔细 但我也要指出 我也要指出的是 第一个例子是一个2X3矩阵 乘以一个 3x2的矩阵 他们相乘 得到的结果 是一个2x2的 矩阵 我们将很快知道为什么是这个结果 好的 这是计算的技巧 让我们再看看 这其中的细节 看看究竟发生了什么 下面就是详细的过程 我有一个矩阵A 我要把它乘以 矩阵B 其结果 会是一个新的矩阵C 并且你会发现你只能 相乘那些维度 匹配的矩阵 因此如果A是一个m×n的矩阵 就是说m行n列 我将要用它与 一个n×o的矩阵相乘 并且实际上这里的n 必须匹配这里的这个n 所以第一个矩阵的列的数目 必须等于第二矩阵中的行的数目 并且相乘得到的结果 结果会是一个m×o的矩阵 就像这个矩阵C这样 并且 在前面的视频中 我们所做的一切都符合这个规则 这是一种当矩阵B的o值 等于1的特殊情况（指的是矩阵和向量相乘） 明白了吗？ 这是在B是一个向量的情况下 但是现在 我们要处理 O的值大于1的情况 所以 这里就是你怎样 把两个矩阵相乘 为了得到结果 我要做的就是 我将要取 B矩阵的第一列 把取出的这列看成一个向量 并乘以矩阵A 用B矩阵的第一列 这个计算结果将是 m×1的矩阵（也就是一个向量） 我们把结果先放在这里 然后 我将要取 B矩阵的 第二列 那么我会又得到一个n×1的向量 也就是 这里的这一列 这是正确的 n×1的矩阵 也就是n维的向量 我将要把这个矩阵 和这些n乘1的向量相乘 其结果将是 一个m维的向量 然后我会把结果先放在那里 依此类推 对吧？ 那么 你知道的 我开始取第三列 把它和这个矩阵相乘 我又得到了一个M维向量 依此类推 直到你计算到了 最后一列 矩阵乘以 你取到的最后一列 就是C的最后一列 再说一遍 矩阵C的第i列 是根据把 矩阵A与 矩阵B的第i列 相乘得到的 结果 依次相加 从1,2到o依次相加的 对吧？ 那么 我们在这里做一个总结 我们总结了我们为了 计算矩阵C所做的步骤 让我们再看一个例子 比方说我想把这两个矩阵相乘 矩阵乘法笔记 Matrix Multiplication Properties 矩阵乘法的性质笔记 Inverse adn Transpose 只有方阵才有逆阵 Octave求逆阵 矩阵的逆和转置笔记]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习入门</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章 单变量线性回归(Linear Regression with One Variable)]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8D%95%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-Linear-Regression-with-One-Variable%2F</url>
    <content type="text"><![CDATA[Gradient Descennt 我们已经定义了代价函数J 而在这段视频中 我想向你们介绍梯度下降这种算法 这种算法可以将代价函数J最小化 梯度下降是很常用的算法 它不仅被用在线性回归上 它实际上被广泛的应用于机器学习领域中的众多领域 在后面课程中 为了解决其他线性回归问题 我们&amp;&amp;也将使用梯度下降法 最小化其他函数 而不仅仅是只用在本节课的代价函数J 因此在这个视频中 我将讲解用梯度下降算法最小化函数 J 在后面的视频中 我们还会将此算法应用于具体的 代价函数J中来解决线性回归问题 下面是问题概述 在这里 我们有一个函数$J(\theta_0, \theta_1)$ 也许这是一个线性回归的代价函数 也许是一些其他函数 要使其最小化 我们需要用一个算法 来最小化函数$J(\theta_0, \theta_1)$ 就像刚才说的 事实证明 梯度下降算法可应用于 多种多样的函数求解 所以想象一下如果你有一个函数 J(θ0, θ1, θ2, …,θn ) 你希望可以通过最小化 θ0到θn 来最小化此代价函数J(θ0 到θn) 用n个θ是为了证明梯度下降算法可以解决更一般的问题 但为了简洁起见 为了简化符号 在接下来的视频中 我只用两个参数 下面就是关于梯度下降的构想 我们要做的是 我们要开始对θ0和θ1 进行一些初步猜测 它们到底是什么其实并不重要 但通常的选择是将 θ0设为0 将θ1也设为0 将它们都初始化为0 我们在梯度下降算法中要做的 就是不停地一点点地改变 θ0和θ1 试图通过这种改变使得J(θ0, θ1)变小 直到我们找到 J 的最小值 或许是局部最小值 让我们通过一些图片来看看梯度下降法是如何工作的 我在试图让这个函数值最小 注意坐标轴 θ0和θ1在水平轴上 而函数 J在垂直坐标轴上 图形表面高度则是 J的值 我们希望最小化这个函数 所以我们从 θ0和θ1的某个值出发 所以想象一下 对 θ0和θ1赋以某个初值 也就是对应于从这个函数表面上的某个起始点出发 对吧 所以不管 θ0和θ1的取值是多少 我将它们初始化为0 但有时你也可把它初始化为其他值 现在我希望大家把这个图像想象为一座山 想像类似这样的景色 公园中有两座山 想象一下你正站立在山的这一点上 站立在你想象的公园这座红色山上 在梯度下降算法中 我们要做的就是旋转360度 看看我们的周围 并问自己 我要在某个方向上 用小碎步尽快下山 这些小碎步需要朝什么方向? 如果我们站在山坡上的这一点 你看一下周围 你会发现最佳的下山方向 大约是那个方向 好的 现在你在山上的新起点上 你再看看周围 然后再一次想想 我应该从什么方向迈着小碎步下山? 然后你按照自己的判断又迈出一步 往那个方向走了一步 然后重复上面的步骤 从这个新的点 你环顾四周 并决定从什么方向将会最快下山 然后又迈进了一小步 又是一小步 并依此类推 直到你接近这里 直到局部最低点的位置 此外 这种下降有一个有趣的特点 第一次我们是从这个点开始进行梯度下降算法的 是吧 在这一点上从这里开始 现在想象一下 我们在刚才的右边一些的位置 对梯度下降进行初始化 想象我们在右边高一些的这个点 开始使用梯度下降 如果你重复上述步骤 停留在该点 并环顾四周 往下降最快的方向迈出一小步 然后环顾四周 又迈出一步 然后如此往复 如果你从右边不远处开始 梯度下降算法将会带你来到 这个右边的第二个局部最优处 如果从刚才的第一个点出发 你会得到这个局部最优解 但如果你的起始点偏移了一些 起始点的位置略有不同 你会得到一个 非常不同的局部最优解 这就是梯度下降算法的一个特点 我们会在之后继续探讨这个问题 好的 这是我们从图中得到的直观感受 看看这个图 这是梯度下降算法的定义 我们将会反复做这些 直到收敛 我们要更新参数 θj 方法是 用 θj 减去 α乘以这一部分 := 表示赋值 这是一个赋值运算符 等号 = :写出a=b 那么这是一个判断为真的声明 如果我写 a=b 就是在断言 a的值是等于 b的值的 这是声明 声明 a的值 与b的值相同 α :一个数字 被称为学习速率 什么是α呢? 在梯度下降算法中 它控制了 我们下山时会迈出多大的步子 因此如果 α值很大 那么相应的梯度下降过程中 我们会试图用大步子下山 如果α值很小 那么我们会迈着很小的小碎步下山 关于如何设置 α的值等内容 在之后的课程中 我会回到这里并且详细说明 最后 是公式的这一部分这是一个微分项 我现在不想谈论它 但我会推导出这个微分项 并告诉你到底这要如何计算 你们中有人大概比较熟悉微积分 但即使你不熟悉微积分 也不用担心 我会告诉你 对这一项 你最后需要做什么 现在 在梯度下降算法中 还有一个更微妙的问题 在梯度下降中 我们要更新 θ0和θ1 当 j=0 和 j=1 时 会产生更新 所以你将更新 J θ0还有θ1 实现梯度下降算法的微妙之处是 在这个表达式中 如果你要更新这个等式 你需要同时更新 θ0和θ1 我的意思是在这个等式中 我们要这样更新 θ0:=θ0 - 一些东西 并更新 θ1:=θ1 - 一些东西 实现方法是 你应该计算公式右边的部分 通过那一部分计算出θ0和θ1的值 然后同时更新 θ0和θ1 让我进一步阐述这个过程 在梯度下降算法中 这是正确实现同时更新的方法 我要设 temp0等于这些 设temp1等于那些 所以首先计算出公式右边这一部分 然后将计算出的结果 一起存入 temp0和 temp1 之中 然后同时更新 θ0和θ1 因为这才是正确的实现方法 与此相反 下面是不正确的实现方法 因为它没有做到同步更新 在这种不正确的实现方法中 我们计算 temp0 然后我们更新θ0 然后我们计算 temp1 然后我们将 temp1 赋给θ1 右边的方法和左边的区别是 让我们看这里 就是这一步 如果这个时候你已经更新了θ0 那么你会使用 θ0的新的值来计算这个微分项 所以由于你已经在这个公式中使用了新的 θ0的值 那么这会产生一个与左边不同的 temp1的值 所以右边并不是正确地实现梯度下降的做法 我不打算解释为什么你需要同时更新 同时更新是梯度下降中的一种常用方法 我们之后会讲到 实际上同步更新是更自然的实现方法 当人们谈到梯度下降时 他们的意思就是同步更新 如果用非同步更新去实现算法 代码可能也会正确工作 但是右边的方法并不是人们所指的那个梯度下降算法 而是具有不同性质的其他算法 由于各种原因 这其中会表现出微小的差别 你应该做的是 在梯度下降中真正实现同时更新 这些就是梯度下降算法的梗概 在接下来的视频中 我们要进入这个微分项的细节之中 我已经写了出来但没有真正定义 如果你已经修过微积分课程 如果你熟悉偏导数和导数 这其实就是这个微分项 如果你不熟悉微积分 不用担心 即使你之前没有看过微积分 或者没有接触过偏导数 在接下来的视频中 你会得到一切你需要知道的 如何计算这个微分项的知识 下一个视频中 希望我们能够给出 实现梯度下降算法的所有知识 Gradient Descennt笔记 所以我们有我们的假设函数，并且我们有一种测量它适合数据的方式。现在我们需要估计假设函数中的参数。这就是梯度下降的地方。 设想我们根据它的域θ0和θ1来描绘我们的假设函数（实际上我们将代价函数绘制为参数估计的函数）。我们不是图表x和y本身，而是我们的假设函数的参数范围和选择一组特定参数所产生的成本。 我们在x轴上放置θ0，在y轴上放置θ1，在垂直z轴上放置代价函数。我们图上的点将是使用我们的假设与那些特定theta参数的成本函数的结果。下面的图表描述了这样的设置。 当我们的代价函数处于图的坑底时，即当其值最小时，我们将知道我们已经成功了。红色箭头显示图表中的最小点。 我们这样做的方式是通过获取代价函数的导数（函数的切线）。切线的斜率是该点的导数，它会给我们一个走向的方向。我们逐步降低成本函数的下降速度。每一步的大小由参数α决定，称为学习率。 例如，上图中每个“星号”之间的距离代表由我们的参数α确定的一个步骤。 α越小，步长越小，α越大，步长越大。步进的方向取决于J（θ0，θ1）的偏导数。根据图表的起始位置，可能会出现不同的点。上面的图片向我们展示了两个不同的起点，最终在两个不同的地方。 梯度下降算法是：重复，直到收敛： j = 0,1代表特征索引号。 在每次迭代j中，应同时更新参数θ1，θ2，…，θn。在计算第j次迭代之前更新特定参数会导致错误的实现。 Gradient Descent Intuition 在之前的视频中 我们给出了一个数学上关于梯度 下降的定义 本次视频我们更深入研究一下 更直观地感受一下这个 算法是做什么的 以及梯度下降算法的更新过程有什么意义 这是我们上次视频中看到的梯度下降算法 提醒一下 这个参数 α 术语称为学习速率 它控制我们以多大的幅度更新这个参数θj. 第二部分是导数项 而我在这个视频中要做的就是 给你一个更直观的认识 这两部分有什么用 以及 为什么当把 这两部分放一起时 整个更新过程是有意义的 为了更好地让你明白 我要做是用一个稍微简单的例子 比如我们想最小化的那个 函数只有一个参数的情形 所以 假如我们有一个代价函数J 只有一个参数 θ1 就像我们前几次视频中讲的 θ1是一个实数 对吧？那么我们可以画出一维的曲线 看起来很简单 让我们试着去理解 为什么梯度下降法 会在这个函数上起作用 所以 假如这是我的函数 关于$\theta_1$的函数$J(\theta_1)$是一个实数 对吧？ 现在我们已经对这个点上用于梯度下降法的$\theta_1$ 进行了初始化 想象一下在我的函数图像上 从那个点出发 那么梯度下降 要做的事情是不断更新 θ1等于θ1减α倍的 d/dθ1J(θ1)这个项 对吧？哦 顺便插一句 你知道 这个微分项是吧？可能你想问为什么我改变了符号 之前用的是偏导数的符号 如果你不知道偏导数的符号 和d/dθ之间的区别是什么 不用担心 从技术上讲 在数学中 我们称这是一个偏导数 这是一个导数 这取决于函数J的参数数量 但是这是一个 数学上的区别 就本课的目标而言 可以默认为 这些偏导数符号 和d/dθ1是完全一样的东西 不用担心 是否存在任何差异 我会尽量使用数学上的 精确的符号 但就我们的目的而言 这些符号是没有区别的 好的 那么我们来看这个方程 我们要计算 这个导数 求导的目的 基本上可以说 取这一点的切线 就是这样一条红色的直线 刚好与函数相切于这一点 让我们看看这条红色直线的斜率 其实这就是导数 也就是说 直线的斜率 也就是这条 刚好与函数曲线相切的这条直线 这条直线的斜率正好是 这个高度除以这个水平长度 现在 这条线有 一个正斜率 也就是说它有正导数 因此 我得到的新的θ θ1更新后等于θ1减去一个正数乘以α. α 也就是学习速率也是一个正数 所以 我要使θ1减去一个东西 所以相当于我将θ1向左移 使θ1变小了 我们可以看到 这么做是对的 因为实际上我往这个方向移动 确实让我更接近那边的最低点 所以 梯度下降到目前为止似乎 是在做正确的事 让我们来看看另一个例子 让我们用同样的函数J 同样再画出函数J(θ1)的图像 而这次 我们把参数初始化到左边这点 所以θ1在这里 同样把这点对应到曲线上 现在 导数项d/dθ1J(θ1)在这点上计算时 看上去会是这样 这条线的斜率 这个导数是这条线的斜率 但是这条线向下倾斜 所以这条线具有负斜率 对吧？ 或者说 这个函数有负导数 也就意味着在那一点上有负斜率 因此 这个导数项小于等于零 所以 当我更新θ时 θ被更新为θ减去α乘以一个负数 因此我是在用 θ1减去一个负数 这意味着我实际上是在增加θ1 对不对？因为这是减去一个负数 意味着给θ加上一个数 这就意味着最后我实际上增加了θ的值 因此 我们将 从这里开始 增加θ 似乎这也是我希望得到的 也就是 让我更接近最小值了 所以 我希望这样很直观地给你解释了 导数项的意义 让我们接下来再看一看学习速率α 我们来研究一下它有什么用 这就是我梯度下降法的 更新规则 就是这个等式 让我们来看看如果α 太小或 α 太大 会出现什么情况 这第一个例子 α太小会发生什么呢 这是我的函数J(θ) 就从这里开始 如果α太小了 那么我要做的是要去 用一个比较小的数乘以更新的值 所以最终 它就像一个小宝宝的步伐 这是一步 然后从这个新的起点开始 迈出另一步 但是由于α 太小 因此只能迈出另一个 小碎步 所以如果我的学习速率太小 结果就是 只能这样像小宝宝一样一点点地挪动 去努力接近最低点 这样就需要很多步才能到达最低点 所以如果α 太小的话 可能会很慢 因为它会一点点挪动 它会需要 很多步才能到达全局最低点 那么如果α 太大又会怎样呢 这是我的函数J(θ) 如果α 太大 那么梯度下降法可能会越过最低点 甚至可能无法收敛 我的意思是 比如我们从这个点开始 实际上这个点已经接近最低点 因此导数指向右侧 但如果α 太大的话 我会迈出很大一步 也许像这样巨大的一步 对吧？所以我最终迈出了一大步 现在 我的代价函数变得更糟 因为离这个最低点越来越远 现在我的导数指向左侧 实际上在减小θ 但是你看 如果我的学习速率过大 我会移动一大步 从这点一下子又到那点了 对吗？如果我的学习率太大 下一次迭代 又移动了一大步 越过一次 又越过一次 一次次越过最低点 直到你发现 实际上 离最低点越来越远 所以 如果α太大 它会导致无法收敛 甚至发散 现在 我还有一个问题 这问题挺狡猾的 如果我们预先把θ1 放在一个局部的最低点 你认为下一步梯度下降法会怎样工作？ 所以假设你将θ1初始化在局部最低点 假设这是你的θ1的初始值 在这儿 它已经在一个局部的 最优处或局部最低点 结果是局部最优点的导数 将等于零 因为它是那条切线的斜率 而这条线的斜率将等于零 因此 此导数项等于0 因此 在你的梯度下降更新过程中 你有一个θ1 然后用θ1 减α 乘以0来更新θ1 所以这意味着什么 这意味着你已经在局部最优点 它使得θ1不再改变 也就是新的θ1等于原来的θ1 因此 如果你的参数已经处于 局部最低点 那么梯度下降法更新其实什么都没做 它不会改变参数的值 这也正是你想要的 因为它使你的解始终保持在 局部最优点 这也解释了为什么即使学习速率α 保持不变时 梯度下降也可以收敛到局部最低点 我想说的是这个意思 我们来看一个例子 这是代价函数J(θ) 我想找到它的最小值 首先初始化我的梯度下降算法 在那个品红色的点初始化 如果我更新一步梯度下降 也许它会带我到这个点 因为这个点的导数是相当陡的 现在 在这个绿色的点 如果我再更新一步 你会发现我的导数 也即斜率 是没那么陡的 相比于在品红点 对吧？因为随着我接近最低点 我的导数越来越接近零 所以 梯度下降一步后 新的导数会变小一点点 然后我想再梯度下降一步 在这个绿点我自然会用一个稍微 跟刚才在那个品红点时比 再小一点的一步 现在到了新的点 红色点 更接近全局最低点了 因此这点的导数会比在绿点时更小 所以 我再进行一步梯度下降时 我的导数项是更小的 θ1更新的幅度就会更小 所以你会移动更小的一步 像这样 随着梯度下降法的运行 你移动的幅度会自动变得越来越小 直到最终移动幅度非常小 你会发现 已经收敛到局部极小值 所以回顾一下 在梯度下降法中 当我们接近局部最低点时 梯度下降法会自动采取 更小的幅度 这是因为当我们接近局部最低点时 很显然在局部最低时导数等于零 所以当我们 接近局部最低时 导数值会自动变得越来越小 所以梯度下降将自动采取较小的幅度 这就是梯度下降的做法 所以实际上没有必要再另外减小α 这就是梯度下降算法 你可以用它来最小化 最小化任何代价函数J 不只是线性回归中的代价函数J 在接下来的视频中 我们要用代价函数J 回到它的本质 线性回归中的代价函数 也就是我们前面得出的平方误差函数 结合梯度下降法 以及平方代价函数 我们会得出第一个机器学习算法 即线性回归算法 Gradient Descent Intuition笔记 在本视频中，我们探索了使用一个参数θ1并绘制其代价函数来实现梯度下降的场景。 我们的单一参数公式为： 无论的斜率符号如何，θ1最终收敛到其最小值。 下图显示当斜率为负值时，θ1的值增加，当为正值时，θ1的值减小。 在附注中，我们应该调整参数α以确保梯度下降算法在合理的时间内收敛。 未能收敛或获得最小值的时间太多意味着我们的步长是错误的。 梯度下降如何以固定步长α收敛？收敛背后的直觉是，当我们逼近我们的凸函数的底部时，接近0。 至少，派生将始终为0，因此我们得到： Gradient Descent For Linear Regression 在以前的视频中我们谈到 关于梯度下降算法 梯度下降是很常用的算法 它不仅被用在线性回归上 和线性回归模型、平方误差代价函数 在这段视频中 我们要 将梯度下降 和代价函数结合 在后面的视频中 我们将用到此算法 并将其应用于 具体的拟合直线的线性回归算法里 这就是 我们在之前的课程里所做的工作 这是梯度下降算法 这个算法你应该很熟悉 这是线性回归模型 还有线性假设和平方误差代价函数 我们将要做的就是 用梯度下降的方法 来最小化平方误差代价函数 为了 使梯度下降 为了 写这段代码 我们需要的关键项 是这里这个微分项 所以.我们需要弄清楚 这个偏导数项是什么 并结合这里的 代价函数J 的定义 就是这样 一个求和项 代价函数就是 这个误差平方项 我这样做 只是 把定义好的代价函数 插入了这个微分式 再简化一下 这等于是 这一个求和项 θ0 + θ1x(i) - y(i) 实际上我们需要 弄清楚这两个 偏导数项是什么 这两项分别是 j=0 和j=1的情况 因此我们要弄清楚 θ0 和 θ1 对应的 偏导数项是什么 (将上面的式子平方化开再分别对θ0 和θ1求偏导) 所以 偏导数项 从这个等式 到下面的等式 计算这些偏导数项需要一些多元微积分 如果你掌握了微积分 你可以随便自己推导这些 然后你检查你的微分 你实际上会得到我给出的答案 但如果你 不太熟悉微积分 别担心 你可以直接用这些 已经算出来的结果 你不需要掌握微积分 或者别的东西 来完成作业 你只需要会用梯度下降就可以 在定义这些以后 在我们算出 这些微分项以后 这些微分项 实际上就是代价函数J的斜率 现在可以将它们放回 我们的梯度下降算法 所以这就是专用于 线性回归的梯度下降 反复执行括号中的式子直到收敛 θ0和θ1不断被更新 都是加上一个-α/m 乘上后面的求和项 所以这里这一项 所以这就是我们的线性回归算法 这一项就是关于θ0的偏导数 在上一张幻灯片中推出的 而第二项 这一项是刚刚的推导出的 关于θ1的 偏导数项 提醒一下 执行梯度下降时 有一个细节要注意 就是必须要 同时更新θ0和θ1 所以 让我们来看看梯度下降是如何工作的 我们用梯度下降解决问题的 一个原因是 它更容易得到局部最优值 当我第一次解释梯度下降时 我展示过这幅图 在表面上 不断下降 并且我们知道了 根据你的初始化 你会得到不同的局部最优解 你知道.你可以结束了.在这里或这里。 但是 事实证明 用于线性回归的 代价函数 总是这样一个 弓形的样子 这个函数的专业术语是 这是一个凸函数 我不打算在这门课中 给出凸函数的定义 凸函数(convex function) 但不正式的说法是 它就是一个弓形的函数 因此 这个函数 没有任何局部最优解 只有一个全局最优解 并且无论什么时候 你对这种代价函数 使用线性回归 梯度下降法得到的结果 总是收敛到全局最优值 因为没有全局最优以外的其他局部最优点 现在 让我们来看看这个算法的执行过程 像往常一样 这是假设函数的图 还有代价函数J的图 让我们来看看如何 初始化参数的值通常来说 初始化参数为零 θ0和θ1都在零 但为了展示需要 在这个梯度下降的实现中 我把θ0初始化为-900 θ1初始化为-0.1 现在进行一次梯度下降,从一点开始向左下方移动一小步,然后就得到了第二个点,假设函数的线改变了一点点. 不断的移动代价函数的点梯度不断下降,假设函数越来越拟合数据,,直到收敛到全局最小值 现在就可以用它来预测房价了. “Batch”Gradient Descent:批量梯度下降:在梯度下降的每一步中,我们都用到了所有的训练样本 在梯度下降中,在计算微分求导项时,我们需要进行求和计算,所以在每一个单独的梯度计算中,我们最终都要计算这样一个东西—-这个项需要对所有m个训练样本求和.]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习入门</category>
      </categories>
      <tags>
        <tag>单变量线性回归</tag>
        <tag>Linear-Regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章: Model and Cost Function]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Model-and-Cost-Function%2F</url>
    <content type="text"><![CDATA[Model Representation:模型表示 我们的第一个学习算法是线性回归算法,了解监督学习过程完整的流程 例子 这个例子是预测住房价格的 我们要使用一个数据集 数据集包含俄勒冈州波特兰市的住房价格 在这里 我要根据不同房屋尺寸所售出的价格 画出我的数据集 比方说 我们来看这个数据集 你有一个朋友正想出售自己的房子 如果你朋友的房子是1250平方尺大小 你要告诉他们 这房子能卖多少钱 那么 你可以做的一件事就是 构建一个模型 也许是条直线 从这个数据模型上来看 也许你可以告诉你的朋友 他能以大约220000(美元)左右的价格 卖掉这个房子 那么这就是监督学习算法的一个例子 它被称作监督学习是因为对于每个数据来说 我们给出了 “正确的答案” 即告诉我们 根据我们的数据来说 房子实际的价格是多少 而且 更具体来说 这是一个回归问题 回归一词指的是我们根据之前的数据预测出一个准确的输出值 对于这个例子就是价格 同时 还有另一种最常见的监督学习方式 叫做分类问题 当我们想要预测离散的输出值 例如 如果我们正在寻找 癌症肿瘤并想要确定 肿瘤是良性的还是恶性的 这就是0/1离散输出的问题 更进一步来说 在监督学习中我们有一个数据集 这个数据集被称训练集 因此对于房价的例子 我们有一个训练集 包含不同的房屋价格 我们的任务就是从这个数据中学习预测房屋价格 现在我们给出这门课中经常使用的一些符号定义 我们要定义颇多符号 不过没关系 现在你记不住所有的符号也没关系 随着课程的进展 你会发现记住这些符号会很有用 我将在整个课程中用小写的 m:来表示训练样本的数目 因此 在这个数据集中 如果表中有47行 那么我们就有47组训练样本 m就等于47 x来表示输入变量 往往也被称为特征量 这就是用x表示输入的特征 y来表示输出变量或者目标变量 也就是我的预测结果 那么这就是第二列 在这里使用(x, y)来表示一个训练样本 所以 在这个表格中的单独的一行对应于一个训练样本 表示某个训练样本 我将使用x上标(i)与y上标(i)来表示 ,即 这就是一个监督学习算法的工作方式 我们可以看到这里有我们的训练集里房屋价格 我们把它喂给我们的学习算法 这就是学习算法的工作了 然后输出一个函数 按照惯例 通常表示为小写h h代表hypothesis(假设) h表示一个函数 输入是房屋尺寸大小 就像你朋友想出售的房屋 因此 h 根据输入的 x 值来得出 y 值 y值对应房子的价格 因此 h是一个从x到y的函数映射 人们经常问我为什么这个函数被称作假设(hypothesis)你们中有些人可能知道hypothesis的意思 从字典或者其它什么方式可以查到 其实在机器学习中 这是一个在早期被用于机器学习的名称 它有点绕口 对这类函数来说 这可能不是一个很恰当的名字 对表示从房屋的大小到价格的函数映射 我认为这个词”hypothesis” 可能不是最好的名称 但是这是人们在机器学习中使用的标准术语 所以不用太纠结人们为什么这么叫它 当设计学习算法的时候 我们接下来需要去思考的是 怎样得到这个假设h 对于这一点在接下来的几个视频中 我将选择最初的使用规则 h代表hypothesis 我们将会这么写为了方便 有时非书面形式也可以这么写 hθ(x) 我就写成h(x) 这是缩写方式 但一般来说我会保留这个下标θ 从这个图片中 所有这一切意味着我们要预测一个关于x的 线性函数 y 对吧? 所以这就是数据集和函数的作用:用来预测 这里是y关于x的线性函数 hθ(x)=θ0+θ1*x 那么为什么是一个线性函数呢? 有时候 我们会有更复杂的函数 也许是非线性函数 但是 由于线性方程是简单的形式 我们将先从线性方程的例子入手 当然 最终我们将会建立更复杂的模型 以及更复杂的学习算法 好吧 让我们也给这模型 起一个名字 这个模型被称为线性回归(linear regression)模型 另外 这实际上是关于单个变量的线性回归 这个变量就是x 根据x来预测所有的价格函数 同时 对于这种模型有另外一个名称 称作单变量线性回归 单变量是对一个变量的一种 特别的表述方式 总而言之 这就是线性回归 在接下来的视频中 我们将开始讨论如何去实现这种模型 笔记—Model Representation模型表示 为了建立将来使用的符号，我们将使用 x^i来表示“输入”变量（在这个例子中是居住区域），也被称为输入要素，而 y^i 表示我们试图预测的“输出”或目标变量（价格）。一对 (x^i，y^i)被称为训练样例，我们将用来学习的数据集----m个训练样例的列表(x^i，y^i);i= 1，。 。 。 ，m—— 被称为训练集。请注意，符号中的上标“（i）”仅仅是训练集的索引，与幂运算无关。我们也将用X来表示输入值的空间，用Y来表示输出值的空间。在这个例子中，X = Y =ℝ。 为了更形式化地描述监督学习问题，我们的目标是在给定训练集的情况下，去学习一个函数h：X→Y，使得h（x）是y的相应值的“好”预测器。由于历史原因，这个函数h被称为假设。从形象上看，这个过程是这样的： 当我们试图预测的目标变量是连续的，比如在我们的住房例子中，我们把学习问题称为回归问题。当y只能接受少量的离散值时（比如，如果考虑到居住面积，我们想要预测一个住宅是房子还是公寓），我们称之为分类问题。 Cost Function(代价函数) 这里将定义代价函数的概念 这有助于我们 弄清楚如何把最有可能的直线与我们的数据相拟合 在线性回归中我们有一个像这样的训练集 记住M代表了训练样本的数量 所以 比如说M = 47 而我们的假设函数 也就是用来进行预测的函数 是这样的线性函数形式 接下来我们会引入一些术语 这些θ0和θ1 这些θi我把它们称为模型参数 在这个视频中 我们要做的就是谈谈如何选择这两个参数值θ0和θ1 选择不同的参数θ0和θ1 我们会得到不同的假设函数，如果θ0是1.5 θ1是0 那么假设函数会看起来是这样， 因为你的假设函数是h(x)=1.5+0*x 是这样一个常数函数 恒等于1.5 如果θ0=0并且θ1=0.5 那么假设会看起来像这样 它会通过点(2,1) 这样你又得到了h(x) 或者hθ(x) 但是有时我们为了简洁会省略θ 因此 h(x)将等于0.5倍的x 就像这样 最后 如果θ0=1并且θ1=0.5 我们最后得到的假设会看起来像这样 让我们来看看 它应该通过点(2,2) 这是我的新的h(x)或者写作hθ(x) 对吧？ 你还记得之前我们提到过·hθ(x)的 但作为简写 我们通常只把它写作h(x)· 在线性回归中 我们有一个训练集 可能就像我在这里绘制的 我们要做的就是 得出θ0 θ1这两个参数的值 来让假设函数表示的直线 尽量地与这些数据点很好的拟合 也许就像这里的这条线一样 那么我们如何得出θ0 θ1的值 来使它很好地拟合数据的呢？我们的想法是 我们要选择 能使h(x) 也就是 输入x时我们预测的值 最接近该样本对应的y值的参数θ0 θ1所以 在我们的训练集中我们会得到一定数量的样本 我们知道x表示卖出哪所房子 并且知道这所房子的实际价格 所以 我们要尽量选择参数值 使得 在训练集中 给出训练集中的x值 我们能合理准确地预测y的值 让我们给出标准的定义 在线性回归中 我们要解决的是一个最小化问题 所以我要写出关于θ0 θ1的最小化 而且 我希望这个式子极其小 是吧 我想要h(x)和y之间的差异要小 我要做的事情是尽量减少假设的输出与房子真实价格 之间的差的平方 接下来我会详细的阐述 别忘了 我用符号( x(i),y(i) )代表第i个样本 所以我想要做的是对所有训练样本进行一个求和 对i=1到i=M的样本 将对假设进行预测得到的结果 此时的输入是第i号房子的面积 对吧 将第i号对应的预测结果 减去第i号房子的实际价格 所得的差的平方相加得到总和 而我希望尽量减小这个值 也就是预测值和实际值的差的平方误差和 或者说预测价格和 实际卖出价格的差的平方 我说了这里的m指的是训练集的样本容量 对吧 这个井号是训练样本“个数”的缩写 对吧 而为了让表达式的数学意义 变得容易理解一点 我们实际上考虑的是 这个数的1/m 因此我们要尝试尽量减少我们的平均误差 也就是尽量减少其1/2m 通常是这个数的一半 前面的这些只是为了使数学更直白一点 因此对这个求和值的二分之一求最小值 应该得出相同的θ0值和相同的θ1值来 请大家一定弄清楚这个道理 没问题吧？在这里hθ(x)的这种表达 这是我们的假设 它等于θ0加上θ1与x(i)的乘积 而这个表达 表示关于θ0和θ1的最小化过程 这意味着我们要找到θ0和θ1 的值来使这个表达式的值最小 这个表达式因θ0和θ1的变化而变化对吧？ 因此 简单地说 我们正在把这个问题变成 找到能使 我的训练集中预测值和真实值的差的平方的和 的1/2M最小的θ0和θ1的值 因此 这将是我的线性回归的整体目标函数 为了使它更明确一点 我们要改写这个函数 按照惯例 我要定义一个代价函数 正如屏幕中所示 这里的这个公式 我们想要做的就是关于θ0和θ1 对函数J(θ0,θ1)求最小值 这就是我的代价函数 代价函数也被称作平方误差函数 有时也被称为 平方误差代价函数 事实上 我们之所以要求出 误差的平方和 是因为误差平方代价函数 对于大多数问题 特别是回归问题 都是一个合理的选择 还有其他的代价函数也能很好地发挥作用 但是平方误差代价函数可能是解决回归问题最常用的手段了 在后续课程中 我们还会谈论其他的代价函数 但我们刚刚讲的选择是对于大多数线性回归问题非常合理的 好吧 所以这是代价函数 到目前为止 我们已经 介绍了代价函数的数学定义 也许这个函数J(θ0,θ1)有点抽象 可能你仍然不知道它的内涵 在接下来的几个视频里 我们要更进一步解释 代价函数J的工作原理 并尝试更直观地解释它在计算什么 以及我们使用它的目的 Cost Function(代价函数)笔记 我们可以通过使用代价函数来衡量我们的假设函数的准确性。 这个假设的所有结果的平均差异（实际上是一个平均值的更漂亮的版本）与来自x的输入和实际输出y的输入。 To break it apart，结果是，其中是 $h_\theta(x_i)-y_i$ 平方的平均值，或预测值与实际值之间的差值。 该函数被称为“平方误差函数(Squared error function)”或“均方误差(Mean squared error)”。 由于平方函数的导数项将抵消该项，平均值被减半以作为计算梯度下降的便利。 以下图片总结了成本函数的作用： Cost Function - Intuition I 在上一个视频中 我们给了代价函数一个数学上的定义 在这个视频里 让我们通过一些例子来获取一些直观的感受 看看代价函数到底是在干什么 回顾一下 这是我们上次所讲过的内容 我们想找一条直线来拟合我们的数据 所以我们用 θ0 θ1 等参数 得到了这个假设 而且通过选择不同的参数 我们会得到不同的直线拟合 所以拟合出的数据就像这样 然后我们还有一个代价函数 这就是我们的优化目标 在这个视频里 为了更好地 将代价函数可视化 我将使用一个简化的假设函数 就是下面这个函数 然后我将会用这个简化的假设 也就是 θ1*x 我们可以将这个函数看成是 把 θ0 设为0 所以我只有一个参数 也就是 θ1 代价函数看起来与之前的很像 唯一的区别是现在 h(x) 等于 θ1*x 只有一个参数 θ1 所以我的 优化目标是将 J(θ1)最小化 用图形来表示就是 如果 θ0 等于零 也就意味这我们选择的假设函数 会经过原点 也就是经过坐标 (0,0) 通过利用简化的假设得到的代价函数 我们可以试着更好地理解 代价函数这个概念 我们要理解的是这两个重要的函数 第一个是假设函数 第二个是代价函数 注意这个假设函数 h(x) 对于一个固定的 θ1 ，h(x)是关于 x 的函数 所以这个假设函数就是一个关于 x 这个房子大小的函数 与此不同的是 代价函数 J 是一个关于参数 θ1 的函数 而 θ1 控制着这条直线的斜率 现在我们把这写函数都画出来 试着更好地理解它们 我们从假设函数开始 比如说这里是我的训练样本 它包含了三个点 (1,1) (2,2) 和 (3,3) 现在我们随便选择一个值 θ1 ，这里选择 θ1 等于1 ，选择 θ1=1之后， 那么我的假设函数看起来就会像是这条直线 我将要指出的是 当我想要描绘出我的假设函数时， 我的横轴被标定为X轴 X轴是表示房子大小的量 现在暂时把 θ1 定为1 我想要做的就是 算出在 θ1 等于 1 的时候 J(θ1) 等于多少 所以我们 按照这个思路来计算代价函数的大小 和之前一样 代价函数定义如下 是吧 对这个误差平方项进行求和 这就等于 这样一个形式 简化以后就等于 三个0的平方和 当然还是0 现在 在代价函数里 我们发现所有这些值都等于0 因为对于我所选定的这三个训练样本 ( 1 ,1 ) (2,2) 和 (3,3) 如果 θ1 等于 1 那么 h(x(i)) 就会正好等于 y(i) 所以 h(x) - y 所有的这些值都会等于零 这也就是为什么J(1) 等于零 所以 我们现在知道了 J(1) 是0 让我把这个画出来 我将要在屏幕右边画出我的代价函数 J 要注意的是 因为我的代价函数是关于参数 θ1 的函数 当我描绘我的代价函数时 X轴就是 θ1 现在我有 J(1) 等于零 让我们继续把函数画出来 结果我们会得到这样一个点 现在我们来看其它一些样本 θ1 可以被设定为 某个范围内各种可能的取值 所以 θ1 可以取负数 0 或者正数 所以如果 θ1 等于0.5会发生什么呢 继续把它画出来 现在要把 θ1 设为0.5 在这个条件下 我的假设函数看起来就是这样 这条线的斜率等于0.5 现在让我们计算 J(0.5) 所以这将会等于1除以2m 乘以那一块 其实我们不难发现后面的求和 就是这条线段的高度的平方 加上这条线段高度的平方 再加上这条线段高度的平方 三者求和 对吗？ 就是 y(i) 与预测值 h(x(i)) 的差 对吗 所以第一个样本将会是0.5减去1的平方 因为我的假设函数预测的值是0.5 而实际值则是1 第二个样本 我得到的是1减去2的平方 因为我的假设函数预测的值是1 但是实际房价是2 最后 加上 1.5减去3的平方 那么这就等于1除以2乘以3 因为训练样本有三个点所以 m 等于3 对吧 然后乘以括号里的内容 简化后就是3.5 所以这就等于3.5除以6 也就约等于0.68 让我们把这个点画出来 不好意思 有一个计算错误 这实际上该是0.58 所以我们把点画出来 大约会是在这里 对吗 现在 让我们再多做一个点 让我们试试θ1等于0 J(0) 会等于多少呢 如果θ1等于0 那么 h(x) 就会等于一条水平的线 对了 就会像这样是水平的 所以 测出这些误差 我们将会得到 J(0) 等于 1除以 2m 乘以1的平方 加上2的平方 加上3的平方 也就是 1除以6乘以14 也就是2.3左右 所以让我们接着把这个点也画出来 所以这个点最后是2.3 当然我们可以接着设定 θ1 等于别的值 进行计算 你也可以把 θ1 设定成一个负数 所以如果 θ1 是负数 那么 h(x) 将会等于 打个比方说 －0.5 乘以x 然后 θ1 就是 -0.5 那么这将会 对应着一个斜率为-0.5的假设函数 而且你可以 继续计算这些误差 结果你会发现 对于0.5 结果会是非常大的误差 最后会得到一个较大的数值 类似于5.25 等等 对于不同的 θ1 你可以计算出这些对应的值 对吗 结果你会发现 你算出来的这些值 你得到一条这样的曲线 通过计算这些值 你可以慢慢地得到这条线 这就是 J(θ) 的样子了 我们来回顾一下 任何一个 θ1 的取值对应着一个不同的 假设函数 或者说对应着左边一条不同的拟合直线。 对于任意的θ1 你可以算出一个不同的 J(θ1) 的取值 举个例子 你知道的 θ1 等于1时对应着穿过这些数据的这条直线 当 θ1 等于0.5 也就是这个玫红色的点 也许对应着这条线 然后 θ1 等于0 也就是蓝色的这个点 对应着 这条水平的线 对吧 所以对于任意一个 θ1 的取值 我们会得到 一个不同的 J(θ1) 而且我们可以利用这些来描出右边的这条曲线 现在你还记得 学习算法的优化目标 是我们想找到一个 θ1 的值 来将 J(θ1) 最小化 对吗 这是我们线性回归的目标函数 嗯 看这条曲线 让 J(θ1) 最小化的值 是 θ1 等于1 然后你看 这个确实就对应着最佳的通过了数据点的拟合直线 这条直线就是由 θ1=1 的设定而得到的 然后 对于这个特定的训练样本 我们最后能够完美地拟合 这就是为什么最小化 J(θ1) 对应着寻找一个最佳拟合直线的目标 总结一下 在这个视频里 我们看到了一些图形 来理解代价函数 要做到这个 我们简化了算法 让这个函数只有一个参数 θ1 也就是说我们把 θ0 设定为0 在下一个视频里 我们将回到原来的问题的公式 然后看一些 带有 θ0 和 θ1 的图形 也就是说不把 θ0 设置为0了 希望这会让你更好地理解在原来的线性回归公式里 代价函数 J 的意义 Cost Function - Intuition I笔记 如果我们试图用视觉术语来思考它，我们的训练数据集就散布在x-y平面上。 我们试图做一条直线（由$h_\theta(x)$定义）来穿过这些散布的数据点。 我们的目标是获得最佳线路。 尽可能最好的线是这样的，以便线上散射点的平均垂直距离将是最小的。 理想情况下，该线应该通过我们训练数据集的所有点。 在这种情况下，$J(\theta_0,\theta_1)$值将为0.以下示例显示了代价函数为0的理想情况。 当$\theta_1=1$我们得到1的斜率时，它会经历我们模型中的每个单一数据点。 相反，当$\theta_1=0.5$我们看到从适合度到数据点的垂直距离增加时。 这使我们的代价函数增加到0.58。 绘制几个其他点产生到以下图表： 因此，作为一个目标，我们应该尽量减少代价函数。 在这种情况下，$\theta_1=1$是我们整体最低的。 Cost Function - Intuition II 这节课中 我们将更深入地学习代价函数的作用 这段视频的内容假设你已经认识轮廓图 如果你对轮廓图不太熟悉的话 这段视频中的某些内容你可能会听不懂 但不要紧 如果你跳过这段视频的话 也没什么关系 不听这节课对后续课程理解影响不大 和之前一样 这是我们的几个重要公式 包括了假设h、参数θ、代价函数J 以及优化目标 跟前一节视频不同的是 我还是把θ写成$\theta_0$,$\theta_1$的形式 便于这里我们要对代价函数进行的可视化 和上次一样 首先来理解假设h和代价函数J 这是房价数据组成的训练集数据 让我们来构建某种假设 就像这条线一样 很显然这不是一个很好的假设 但不管怎样 如果我假设θ0等于50 θ1等于0.06的话 那么我将得到这样一个假设函数 对应于这条直线 给出θ0和θ1的值 我们要在右边画出代价函数的图像 上一次 我们是只有一个θ1 也就是说 画出的代价函数是关于θ1的函数 但现在我们有两个参数 θ0和θ1 因此图像就会复杂一些了 当只有一个参数θ1的时候 我们画出来是这样一个弓形函数 而现在我们有了两个参数 那么代价函数 仍然呈现类似的某种弓形 实际上这取决于训练样本 你可能会得到这样的图形 因此这是一个三维曲面图 两个轴分别表示θ0和θ1 随着你改变θ0和θ1的大小 你便会得到不同的代价函数 J(θ0,θ1) 对于某个特定的点 (θ0,θ1) 这个曲面的高度 也就是竖直方向的高度 就表示代价函数 J(θ0,θ1) 的值 不难发现这是一个弓形曲面 我们来看看三维图 这是这个曲面的三维图 水平轴是θ0、θ1 竖直方向表示 J(θ0,θ1) 旋转一下这个图 你就更能理解这个弓形曲面所表示的代价函数了 在这段视频的后半部分 为了描述方便 我将不再像这样给你用三维曲面图的方式解释代价函数J 而还是用轮廓图来表示 .contour plot 或 contour figure 意思一样 下图就是一个轮廓图 两个轴分别表示 θ0 和 θ1 而这些一圈一圈的椭圆形 每一个圈就表示 J(θ0,θ1) 相同的所有点的集合 具体举例来说 我们选三个点出来 这三个桃红色的点 都表示相同的 J(θ0,θ1) 的值 对吧 横纵坐标分别是θ0 θ1 这三个点的 J(θ0,θ1) 值是相同的 如果你之前没怎么接触轮廓图的话 你就这么想 你就想象一个弓形的函数从屏幕里冒出来 因此最小值 也就是这个弓形的最低点就是这个点 对吧 也就是这一系列同心椭圆的中心点 想象一下这个弓形从屏幕里冒出来 所以这些椭圆形 都从我的屏幕上冒出相同的高度 弓形的最小值点是这个位置 因此轮廓图是一种很方便的方法 能够直观地观察 代价函数J 接下来让我们看几个例子 在这里有一点 这个点表示θ0等于800 θ1大概等于-0.15 那么这个红色的点 代表了某个 (θ0,θ1) 组成的数值组 而这个点也对应于左边这样一条线 对吧 θ0等于800 也就是跟纵轴相交于大约800 斜率大概是-0.15 当然 这条线并不能很好地拟合数据 对吧 以这组 θ0 θ1 为参数的这个假设 h(x) 并不是数据的较好拟合 并且你也发现了 这个代价值 就是这里的这个值 距离最小值点还很远 也就是说这个代价值还是算比较大的 因此不能很好拟合数据 让我们再来看几个例子 这是另一个假设 你不难发现 这依然不是一个好的拟合 但比刚才稍微好一点 这是我的 θ0 θ1 点 这是 θ0 的值 大约为360 θ1 的值为0 我们把它写下来 θ0=360 θ1=0 因此这组θ值对应的假设是 这条水平的直线 也就是h(x) = 360 + 0 × x 这就是假设 这个假设同样也有某个代价值 而这个代价值就对应于这个代价函数在这一点的高度 最后一个例子 这个点其实不是最小值 但已经非常靠近最小值点了 这个点对数据的拟合就很不错 它对应这样两个θ0 和 θ1 的值 同时也对应这样一个 h(x) 这个点虽然不在最小值点 但非常接近了 因此误差平方和 或者说 训练样本和假设的距离的平方和 这个距离值的平方和 非常接近于最小值 尽管它还不是最小值 好的 通过这些图形 我希望你能更好地 理解这些代价函数 J 所表达的值 它们是什么样的 它们对应的假设是什么样的 以及什么样的假设对应的点 更接近于代价函数J的最小值 当然 我们真正需要的是一种有效的算法 能够自动地找出这些使代价函数J取最小值的参数θ0和θ1来 对吧 我想我们也不希望编个程序 把这些点画出来 然后人工的方法来读出这些点的数值 这很明显不是一个好办法 事实上 我们后面就会学到 我们会遇到更复杂、更高维度、更多参数的情况 这在我们在后面的视频中很快就会遇到 而这些情况是很难画出图的 因此更无法将其可视化 因此我们真正需要的 是编写程序来找出这些最小化代价函数的θ0和θ1的值 在下一节视频中 我们将介绍一种算法 能够自动地找出能使代价函数 J 最小化的参数θ0和θ1的值 Cost Function(代价函数) - Intuition II笔记 轮廓图（或者叫等值线图）是包含许多等高线的图。两个变量函数的轮廓线在同一行的所有点上具有恒定值。这种图的一个例子就是下面的图。 采取任何颜色并沿着“圆”走，人们会期望获得相同的成本函数值。例如，上面绿线上的三个绿色点对于J（θ0，θ1）具有相同的值，因此它们沿着同一条线发现。带圆圈的x显示θ0= 800和θ1= -0.15时左侧图形的成本函数值。再取一个h（x）并绘制其轮廓图（等值线图），可以得到以下图表： 当θ0= 360且θ1= 0时，等值线图中J（θ0，θ1）的值更靠近中心，从而降低了代价函数误差。现在给我们的假设函数一个稍微正向的斜率会导致更好的数据拟合。 上面的图尽可能地降低了成本函数，因此，θ1和θ0的结果分别趋于0.12和250左右。将我们图上的这些值绘制在右侧似乎将我们的观点置于最内层“圈子”的中心。]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习入门</category>
      </categories>
      <tags>
        <tag>Cost Function</tag>
        <tag>代价函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零:机器学习介绍]]></title>
    <url>%2F2018%2F11%2F15%2F%E9%9B%B6-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[视频地址 定义定义1给予计算机学习能力的领域。 Samuel的定义可以回溯到50年代，他编写了一个西洋棋程序。 这程序神奇之处在于，编程者自己并不是个下棋高手。 但因为他太菜了，于是就通过编程， 让西洋棋程序自己跟自己下了上万盘棋。通过观察 哪种布局（棋盘位置）会赢，哪种布局会输， 久而久之，这西洋棋程序明白了什么是好的布局， 什么样是坏的布局。然后就牛逼大发了，程序通过学习后， 玩西洋棋的水平超过了Samuel。这绝对是令人注目的成果。 尽管编写者自己是个菜鸟，但因为 计算机有着足够的耐心，去下上万盘的棋， 没有人有这耐心去下这么多盘棋。通过这些练习， 计算机获得无比丰富的经验，于是渐渐成为了 比Samuel更厉害的西洋棋手。 定义2: 由Tom Mitchell提出，来自卡内基梅隆大学.一个好的学习一个程序被认为能从经验E中学习，解决任务 T，达到 性能度量值P，当且仅当，有了经验E后，经过P评判， 程序在处理 T 时的性能有所提升 在西洋棋那例子中， 经验E :程序上万次的自我练习的经验 任务T :就是下棋。 性能度量值p:，就是它在与一些新的对手比赛时，赢得比赛的概率。 目主要的两种类型学习算法被我们称之为监督学习和无监督学习。 监督学习:我们将教计算机如何去完成任务 无监督学习:让它自己进行学习。监督学习(Supervised Learning)例子1: 假设你想预测房价， 之前，某学生已经从某地收集了数据集其中一个数据集是这样的。 这是横坐标，即不同房子的面积，单位平方脚（^-^） 纵轴上是房价，单位 千美元。 根据给定数据，假设你朋友有栋房子，750平尺（70平米） 想知道这房子能卖多少，好卖掉。 那么，学习算法怎么帮你呢？学习算法可以： 绘出一条直线，让直线尽可能匹配到所有数据。 基于此，看上去，那个房子应该、可能、也许、大概 卖到15万美元（一平米两千刀！）。 但这不是唯一的学习算法。 可能还有更好的。比如不用直线了， 可能平方函数会更好， 即二次多项式更符合数据集。如果你这样做， 预测结果就应该是20万刀（一平三千刀，涨价好快）。 后面我们会介绍到如何选择 是选择直线还是平方函数来拟合。 没有明确的选择，就不知哪个能给你的朋友 更好的卖房建议。只是这些每个都是很好的学习算法例子。 也是监督学习的例子。 术语监督学习，意指给出一个算法， 需要部分数据集已经有正确答案。比如给定房价数据集， 对于里面每个数据，算法都知道对应的正确房价， 即这房子实际卖出的价格。算法的结果就是 算出更多的正确价格，比如那个新房子， 你朋友想卖的那个。用更术语的方式来定义， 监督学习又叫回归问题(regression problem)，（应该是回归属于监督中的一种） 意指要预测一个连续值的输出，比如房价。 虽然从技术上，一般把房价记到美分单位。 所以实际还是个离散值，但通常把它看作实际数字， 是一个标量值，一个连续值的数，而术语回归， 意味着要预测这类连续值属性的种类。 例子2: 另一个监督学习的例子，我和一些朋友 之前研究的领域。让我们来看医学记录， 并预测胸部肿瘤是恶性良性。 如果某人发现有胸部肿瘤，恶性肿瘤有害又危险， 良性肿瘤则是少害。 显然人们很关注这个。让我们看一个收集好的数据集， 假设在数据集中，横轴表示肿瘤的大小， 纵轴我打算圈上0或1，是或否， 即肿瘤是恶性的还是良性的。 所以如图所示，可以看到这个大小的肿瘤块 是良性的，还有这些大小的都是良性的。 不幸地是也看到一些恶性肿瘤，比如这些大小的肿瘤。 所以，有5个良性块，在这一块， 还有5个恶性的，它们纵轴值为1. 现在假设某人杯具地得胸部肿瘤了， 大小大概是这么大。 对应的机器学习问题就是，你能否估算出一个概率， 即肿瘤为恶或为良的概率？ 专业地说，这是个分类问题(classification problem)。 分类是要预测一个离散值输出。 这里是0或1，恶性或良性。 事实证明， 在分类问题中，有时会有超过两个的值， 输出的值可能超过两种。举个具体例子， 胸部肿瘤可能有三种类型，所以要预测离散值0，1，2，3 ，假设总共有三种癌症。 0就是良性肿瘤，没有癌症。 1 表示1号癌症 2 是2号癌症， 3 就是3号癌症 这同样是个分类问题，因为它的输出的离散值集合 分别对应于无癌，1号，2号，3号癌症 我再露一小手，在分类问题中，还有另一种作图方式 来描述数据—-我画你猜。要用到些许不同的符号集合来描绘数据。如果肿瘤大小作为唯一属性， 被用于预测恶性良性，可以把数据作图成这样。 使用不同的符号来表示良性和 恶性，即阴性和阳性。所以，不再统一画叉叉了， 改用圈圈来代表良性肿瘤，就像这样。 仍沿用X（叉叉）代表恶性肿瘤。希望你能明白。 我所做的就是，把在上面的数据， 映射下来。再用不同的符号， 圈和叉来分别代表良性和恶性。 在上例中，只使用了一个特征属性，即肿瘤块大小， 来预测肿瘤是恶性良性。在其它机器学习问题里， 有着不只一个的特征和属性。 例子，现在不只是知道肿瘤大小， 病人年龄和肿瘤大小都知道了。这种情况下， 数据集如表图所示，有些病人，年龄、肿瘤已知， 不同的病人，会有一点不一样， 肿瘤恶性，则用叉来代表。所以，假设 有一朋友得了肿瘤。肿瘤大小和年龄 落在此处。那么依据这个给定的数据集，学习算法 所做的就是画一条直线，分开 恶性肿瘤和良性肿瘤，所以学习算法会 画条直线，像这样，把两类肿瘤分开。 然后你就能判断你朋友的肿瘤是…了 如果它在那边，学习算法就说 你朋友的肿瘤在良性一边，因此更可能 是良性的。 好，本例中，总共有两个特征， 即病人年龄和肿瘤大小。在别的ML问题中， 经常会用到更多特征，我朋友研究这个问题时， 通常使用这些特征：比如块的厚度，即胸部肿瘤的厚度 肿瘤细胞大小和形状的一致性， 等等。它表明， 最有趣的学习算法（本课中将学到） 能够处理，无穷多个特征。不是3到5个这么少。 在这张幻灯片中，我已经列举了总共5个不同的特征。 但对于一些学习问题， 真要用到的不只是三五个特征， 要用到无数多个特征，非常多的属性， 所以，你的学习算法要使用很多的属性 或特征、线索来进行预测。 那么，你如何处理无限多特征呢？甚至你如何存储无数的东西 进电脑里，又要避免内存不足？ 事实上，等我们介绍一种叫支持向量机的算法时， 就知道存在一个简洁的数学方法，能让电脑处理无限多的特征。 想像下，我不是这边写两个特征， 右边写三个特征。而是，写一个无限长的特征表， 不停地写特征，似乎是个无限长的特征的表。 但是，我们也有能力设计一个算法来处理这个问题。 本课中，我们介绍监督学习。 其基本思想是，监督学习中，对于数据集中的每个数据， 都有相应的正确答案（训练集） ,算法就是基于这些来做出预测.就像那个房价， 或肿瘤的性质。后面介绍了回归问题。 即通过回归来预测一个连续值输出。 我们还谈到了分类问题， 目标是预测离散值输出。 下面是个小测验题目： 假设你有家公司，希望研究相应的学习算法去 解决两个问题。第一个问题，你有一堆货物的清单。 假设一些货物有几千件可卖， 你想预测出，你能在未来三个月卖出多少货物。 第二个问题，你有很多用户， 你打算写程序来检查每个用户的帐目。 对每个用户的帐目， 判断这个帐目是否被黑过（hacked or compromised）。 请问，这两个问题是分类问题，还是回归问题？ 问题一是个回归问题 因为如果我有几千件货物， 可能只好把它当作一个实际的值，一个连续的值。 也把卖出的数量当作连续值。 第二个问题，则是分类问题，因为可以把 我想预测的一个值设为0，来表示账目没有被hacked 另一个设为1，表示已经被hacked。 就像乳癌例子中，0表示良性，1表示恶性。 所以这个值为0或1，取决于是否被hacked， 有算法能预测出是这两个离散值中的哪个。 因为只有少量的离散值，所以这个就是个分类问题。 笔记 在监督式学习中，我们给了一个数据集，并且已经知道我们的正确输出应该是什么样子，并且有输入和输出之间有关系的想法。 监督学习问题分为“回归”和“分类”问题。 在回归问题中，我们试图预测连续输出中的结果，这意味着我们试图将输入变量映射到某个连续函数。 在分类问题中，我们试图预测离散输出的结果。换句话说，我们试图将输入变量映射到离散类别 例子 回归 - 给定一个人的照片，我们必须根据给定的图片来预测他们的年龄 分类 - 给予患有肿瘤的患者，我们必须预测肿瘤是恶性的还是良性的。 无监督学习(Unsupervised Learning) 在上一节视频中 我们已经讲过了监督学习 回想起上次的数据集 每个样本 都已经被标明为 正样本或者负样本 即良性或恶性肿瘤 因此 对于监督学习中的每一个样本 我们已经被清楚地告知了 什么是所谓的正确答案 即它们是良性还是恶性 在无监督学习中 我们用的数据会和监督学习里的看起来有些不一样 在无监督学习中 没有属性或标签这一概念 也就是说所有的数据都是一样的,没有区别 所以在无监督学习中 我们只有一个数据集 没人告诉我们该怎么做 我们也不知道每个数据点究竟是什么意思,相反 它只告诉我们:现在有一个数据集 你能在其中找到某种结构吗? 对于给定的数据集,无监督学习算法可能判定,该数据集包含两个不同的聚类,这是第一个聚类,然后这是另一个聚类 .无监督学习算法 会把这些数据分成两个不同的聚类,所以这就是所谓的聚类算法 例子1 我们来举一个聚类算法的例子 Google 新闻的例子 如果你还没见过这个页面的话 你可以到这个URL:news.google.com 去看看谷歌新闻每天都在干什么呢？ 他们每天会去收集成千上万的网络上的新闻然后将他们分组组成一个个新闻专题 比如 让我们来看看这里,这里的URL链接连接着不同的有关BP油井事故的报道,所以 让我们点击 这些URL中的一个 恩 让我们点一个 然后我们会来到这样一个网页 这是一篇来自华尔街日报的 有关……你懂的 有关BP油井泄漏事故的报道 标题为《BP杀死了Macondo》 Macondo 是个地名 就是那个漏油事故的地方 如果你从这个组里点击一个不同的URL 那么你可能会得到不同的新闻 这里是一则CNN的新闻 是一个有关BP石油泄漏的视频 如果你再点击第三个链接 又会出现不同的新闻 这边是英国卫报的报道 也是关于BP石油泄漏 所以 谷歌新闻所做的就是 去搜索成千上万条新闻 然后自动的将他们聚合在一起 因此 有关同一主题的 新闻被显示在一起 实际上 聚类算法和无监督学习算法 也可以被用于许多其他的问题 例子2 这里我们举个它在基因组学中的应用 下面是一个关于基因芯片的例子 基本的思想是 给定一组不同的个体,对于每个个体,检测它们是否拥有某个特定的基因 也就是说，你要去分析有多少基因显现出来了 因此 这些颜色 红 绿 灰 等等 它们 展示了这些不同的个体 是否拥有一个特定基因 的不同程度 然后你能做的就是 运行一个聚类算法 把不同的个体归入不同的类 或归为不同类型的人 这就是无监督学习 我们没有提前告知这个算法 这些是第一类的人 这些是第二类的人 这些是第三类的人等等 相反我们只是告诉算法 你看 这儿有一堆数据 我不知道这个数据是什么东东 我不知道里面都有些什么类型 叫什么名字 我甚至不知道都有哪些类型 但是 请问你可以自动的找到这些数据中的类型吗？ 然后自动的 按得到的类型把这些个体分类 虽然事先我并不知道哪些类型 因为对于这些数据样本来说 我们没有给算法一个正确答案,所以这就是无监督学习 其他例子 无监督学习或聚类算法在其他领域也有着大量的应用 它被用来组织大型的计算机集群 我有一些朋友在管理 大型数据中心 也就是 大型计算机集群 并试图 找出哪些机器趋向于 协同工作 如果你把这些机器放在一起 你就可以让你的数据中心更高效地工作 用于社交网络的分析 所以 如果可以得知 哪些朋友你用email联系的最多 或者知道你的Facebook好友 或者你Google+里的朋友 知道了这些之后 我们是否可以自动识别 哪些是很要好的朋友组 哪些仅仅是互相认识的朋友组 还有在市场分割中的应用 许多公司拥有庞大的客户信息数据库,那么,给你一个客户数据集,你能否自动找出不同的市场分割,并自动将你的客户分到不同的细分市场中.从而有助于我在不同的细分市场中进行更有效的销售 这也是无监督学习 我们现在有 这些客户数据 但我们预先并不知道 有哪些细分市场 而且 对于我们数据集的某个客户 我们也不能预先知道 谁属于细分市场一 谁又属于细分市场二等等 但我们必须让这个算法自己去从数据中发现这一切 天文数据分析 通过这些聚类算法 我们发现了许多 惊人的、有趣的 以及实用的 关于星系是如何诞生的理论 所有这些都是聚类算法的例子 而聚类只是无监督学习的一种 鸡尾酒宴问题 恩 我想你参加过鸡尾酒会的 是吧？ 嗯 想象一下 有一个宴会 有一屋子的人 大家都坐在一起 而且在同时说话 有许多声音混杂在一起 因为每个人都是在同一时间说话的 在这种情况下你很难听清楚你面前的人说的话 因此 比如有这样一个场景 宴会上只有两个人 两个人 同时说话 恩 这是个很小的鸡尾酒宴会 我们准备好了两个麦克风 把它们放在房间里 然后 因为这两个麦克风距离这两个人 的距离是不同的 每个麦克风都记录下了 来自两个人的声音的不同组合 也许A的声音 在第一个麦克风里的声音会响一点 也许B的声音 在第二个麦克风里会比较响一些 因为2个麦克风 的位置相对于 2个说话者的位置是不同的 但每个麦克风都会录到 来自两个说话者的重叠部分的声音 一个研究员录下的两个说话者的声音,无监督学习算法可以将两种混合在一起的音频分开 所以,你可以看到,像这样的无监督学习算法,看起来 为了 构建这个应用程序 做这个音频处理 似乎需要写好多代码啊 或者需要链接到 一堆处理音频的Java库 貌似需要一个非常复杂的程序,分离出音频等 实际上,要实现混合音频分离的效果,只需要一行代码就可以了 当然 研究人员 花了很长时间才想出这行代码的,我不是说这是一个简单的问题 但事实上 如果你 使用正确的编程环境 许多学习 算法是用很短的代码写出来的 所以这也是为什么在 这门课中我们要 使用Octave的编程环境 Octave是一个免费的 开放源码的软件 使用Octave或Matlab这类的工具 许多学习算法 都可以用几行代码就可以实现 在后续课程中 我会教你如何使用Octave 你会学到 如何在Octave中实现这些算法 或者 如果你有Matlab 你可以用它 事实上 在硅谷 很多的机器学习算法 我们都是先用Octave 写一个程序原型 因为在Octave中实现这些 学习算法的速度快得让你无法想象 在这里 每一个函数 例如 SVD 意思是奇异值分解 但这其实是解线性方程 的一个惯例 它被内置在Octave软件中了 如果你试图 在C + +或Java中做这个 将需要写N多代码 并且还要连接复杂的C + +或Java库 所以 你可以在C++或 Java或Python中 实现这个算法 只是会 更加复杂而已 如果你使用Octave的话 会学的更快 并且如果你用 Octave作为你的学习工具 和开发原型的工具 你的学习和开发过程 会变得更快 而事实上在硅谷 很多人会这样做 他们会先用Octave 来实现这样一个学习算法原型 只有在确定 这个算法可以工作后 才开始迁移到 C++ Java或其它编译环境 事实证明 这样做 实现的算法 比你一开始就用C++ 实现的算法要快多了 我们谈到了无监督学习 它是一种学习机制 你给算法大量的数据 要求它找出数据中 蕴含的类型结构 以下的四个例子中 哪一个 您认为是 无监督学习算法 而不是监督学习问题 * 恩 没忘记垃圾邮件文件夹问题吧？ 如果你已经标记过数据 那么就有垃圾邮件和 非垃圾邮件的区别 我们会将此视为一个监督学习问题 * 新闻故事的例子 正是我们在本课中讲到的 谷歌新闻的例子 我们介绍了你可以如何使用 聚类算法这些文章聚合在一起 所以这是无监督学习问题 * 市场细分的例子 我之前有说过 这也是一个无监督学习问题 因为我是要 拿到数据 然后要求 它自动发现细分市场 * 最后一个例子 糖尿病 这实际上就像我们 上节课讲到的乳腺癌的例子 只不过这里不是 好的或坏的癌细胞 良性或恶性肿瘤我们 现在是有糖尿病或 没有糖尿病 所以这是 有监督的学习问题 像处理那个乳腺癌的问题一样 我们会把它作为一个 有监督的学习问题来处理 笔记 无监督的学习使我们能够很少或根本不知道我们的结果应该是什么样子。 我们可以从数据中推导出结构，我们不一定知道变量的影响。 我们可以通过基于数据中变量之间的关系对数据进行聚类来推导出这种结构。 在无监督学习的基础上，没有基于预测结果的反馈。 例： 聚类(Clustering)：搜集一百万个不同的基因，并找到一种方法，将这些基因自动分组，这些基因组通过不同的变量（例如寿命，位置，角色等）相似或相关。 非聚类(Non-clustering)：“鸡尾酒会算法”，可以让你在混乱的环境中找到结构。 （即在鸡尾酒会上从声音网格中识别个别的声音和音乐）。]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习入门</category>
      </categories>
      <tags>
        <tag>机器学习简介</tag>
      </tags>
  </entry>
</search>
