<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第三章 线性代数回顾(Linear Algebra Review)]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9B%9E%E9%A1%BE-Linear-Algebra-Review%2F</url>
    <content type="text"><![CDATA[第三章 线性代数回顾(Linear Algebra Review)Matrices and Vectors（矩阵和向量） 我们先复习一下线性代数的知识 在这段视频中 我会向大家介绍矩阵和向量的概念 矩阵是指 由数字组成的矩形阵列 并写在方括号中间 例如 屏幕中所示的一个矩阵 先写一个左括号 然后是一些数字 这些数字可能是 机器学习问题的特征值 也可能表示其他意思 不过现在不用管具体的数字 然后我用右方括号将其括起来 这样就得到了一个矩阵 接下来 看一下其他矩阵的例子 依次写下1 2 3 4 5 6 因此实际上矩阵 可以说是二维数组的 另一个名字 另外 我们还需要知道的是 矩阵的维度=矩阵的行数乘以列数 具体到这个例子 看左边 包括1 2 3 4共4行 以及2列 因此 这个例子是一个 4 × 2的矩阵 即行数乘以列数 4行乘2列 右边的矩阵有两行 这是第一行 这是第二行 此外包括三列 这是第一列 第二列 第三列 因此 我们把 这个矩阵称为一个 2 × 3维的矩阵 所以我们说这个矩阵的维度是2 × 3维 有时候大家会发现 书写有些不同 比如左边的矩阵 写成了R4 × 2 具体而言 大家会将该矩阵称作 是集合R4×2的元素 因此 也就是说 这个矩阵 R4×2代表所有4×2的矩阵的集合 而右边的这个矩阵 有时候也写作一个R2×3的矩阵 因此 如果你看到2×3 如果你看到 有些地方表达为 4×2的或者2×3的 一般都是指 一个特定维度的矩阵 接下来 让我们来谈谈如何表达矩阵的某个特定元素 这里我说矩阵元素 而不是矩阵 我的意思是 矩阵的条目数 也就是矩阵内部的某个数 所以 标准的表达是 如果A是 这个矩阵 那么A下标 ij 表示的是 i j对应的那个数字 意思是矩阵的第i行和第j列 对应的那个数 例如 A11 表示的是第1行 第1列所对应的那个元素 所以这是 第一行和第一列 因此A11 就等于 1402 另一个例子A12 表示的是第一行第二列 对应的那个数 所以A12 将等于191 我希望你不会犯下面的错误 但如果你这么写的话 如果你写出了A43 这应该表示的是 第四行第三列 而你知道 这个矩阵没有第三列 因此这是未定义的 接下来让我们来谈谈什么是向量 一个向量是一种特殊的矩阵 向量是只有一列的矩阵 所以 你有一个 n×1 矩阵 还记得吗 N是行数 而这里的1 表示的是列数 所以 只有一列的矩阵 就是我们所说的向量 因此 这里是一个向量的 例子 比如说 我有 n = 4 个元素 所以我们也把这个称为 另一个术语是 这是一个四维的向量 也就意味着 这是一个含有 4个元素的向量 而且 前面我们讲 矩阵的时候提到过 这个符号R3×2 表示的是一个3行2列的矩阵 而对于这个向量 我们也同样可以 表示为集合R4 因此 这个R4是指 一个四维向量的集合 接下来让我们来谈谈如何引用向量的元素 我们将使用符号 yi来代表 向量y的第i个元素 所以 如果这个向量是y 那么y下标i 则表示它的第i个元素 所以y1表示第一个元素 460 y2表示第二个元素 232 这是第二个元素 还有y3等于 315 等等 只有y1至y4是有意义的 因为这定义的是一个四维向量 此外 事实上 有两种方法来表达 某个向量中某个索引 是这两种 有时候 人们会使用 1-索引 有时候用0-索引 因此 左边这个例子 是一个1-索引向量 它的元素写作y1 y2 y3 y4 而右边这个向量 是0-索引的一个例子 我们的索引 从下标0开始 因此 元素从y0至y3 对于很多机器学习的应用问题来说 0-索引向量为我们提供了一个更方便的符号表达 所以你通常应该 做的是 除非特别指定 你应该默认我们使用的是1-索引法表示向量 在本课程的后面所有 关于线性代数的视频中 我都将使用1-索引法表示向量 按照惯例 通常在书写矩阵和向量时 大多数人会使用大写字母 来表示矩阵 因此 我们要使用 大写字母 如 A B C X 来表示矩阵 而通常我们会使用小写字母 像a b x y 来表示数字 或是原始的数字 或标量 或向量 这是实际的使用习惯 我们也经常看到 使用小写字母y 来表示向量 但我们平时 是用大写字母来表示矩阵 Matrices and Vectors笔记 矩阵是二维数组 上面的矩阵有四行三列，所以它是一个4 x 3的矩阵 向量是·一列和许多行·的矩阵： 所以向量是矩阵的一个子集。上述向量是一个4×1矩阵。 表示法和条款： $A_{ij}$引用矩阵A的第i行和第j列中的元素。 具有’n’行的矢量被称为’n’维矢量。 $v_i$指矢量的第i行中的元素。 一般来说，我们所有的向量和矩阵都是1索引的。请注意，对于某些编程语言，这些数组是0索引的。 矩阵通常用大写字母表示，而向量则用小写字母表示。 “标量”表示对象是单个值，而不是矢量或矩阵。 是指一组标量实数。 是指实数的n维向量的集合。 Addition and Scalar Multiplication 在这段视频中 我们要讲 我们将讨论矩阵的加法和减法运算 以及如何进行 数和矩阵的乘法 也就是标量乘法 让我们从下面这个例子开始 假设有这样两个矩阵 如果想对它们做求和运算 应该怎么做呢？ 或者说 矩阵的加法到底是如何进行的？ 答案是 如果你想将两个矩阵相加 你只需要将这两个矩阵的 每一个元素都逐个相加 因此 两个矩阵相加 所得到的结果 就是一个新的矩阵 它的第一个元素 是1和4相加的结果 因此我们得到5 接下来是第二个元素 用2和2相加 因此得到4 然后是3加0得到3 以此类推 这里我用不同颜色区别一下 接下来右边这一列元素 就是0.5 10和2 这里大家不难发现 只有相同维度的两个矩阵才能相加 对于这个例子而言 一個3 x 2的矩陣 也就是说矩阵的行数为3 列数是2 因此是3行2列 第二个矩阵 也是一个3行2列的矩阵 因此这两个矩阵相加的结果 也是一个3行2列的矩阵 所以你只能将相同维度的矩阵 进行相加运算 同时 所得到的结果 将会是一个新的矩阵 这个矩阵与相加的两个矩阵维度相同 反过来 如果你想将这样两个矩阵相加 这是一个3行2列的矩阵 行数为3 列数为2 而这一个是2行2列的矩阵 那么由于这两个矩阵 维度是不相同的 这就出现错误了 所以我们不能将它们相加 也就是说 这两个矩阵的和是没有意义的 这就是矩阵的加法运算 接下来 我们讨论矩阵和标量的乘法运算 这里所说的标量 可能是一个复杂的结构 或者只是一个简单的数字 或者说实数 标量在这里指的就是实数 如果我们用数字3来和这个矩阵相乘 那么结果是显而易见的 你只需要将矩阵中的所有元素 都和3相乘 每一个都逐一与3相乘 因此 1和3相乘 结果是3 2和3相乘 结果是6 最后3乘以3得9 我再换一下颜色 0乘以3得0 3乘以5得15 最后3乘以1得3 这样得到的这个矩阵 就是左边这个矩阵和3相乘的结果 我们再次注意到 这是一个3行2列的矩阵 得到的结果矩阵 维度也是相同的 也就是说这两个矩阵 都是3行2列 这也是3行2列 另外 你也可以写成另一种方式 这里是3和这个矩阵相乘 你也可以把这个矩阵写在前面 把左边这个矩阵照抄过来 我们也可以用这个矩阵乘以3 也就是说 3乘以这个矩阵 和这个矩阵乘以3 结果都是一回事 都是中间的这个矩阵 你也可以用矩阵除以一个数 那么 我们可以看到 用这个矩阵除以4 实际上就是 用四分之一 来和这个矩阵相乘 4 0 6 3 不难发现 相乘的结果是 1/4和4相乘为1 1/4和0相乘得0 1/4乘以6 结果是3/2 6/4也就是3/2 最后1/4乘以3得3/4 这样我们就得到了 这个矩阵除以4的结果 结果就是是右边这个矩阵 最后 我们来看一个稍微复杂一点的例子 我们可以把所有这些运算结合起来 在这个运算中 需要用3来乘以这个向量 然后加上一个向量 再减去另一个向量除以3的结果 让我们先来整理一下这几项运算 首先第一个运算 很明显这是标量乘法的例子 因为这里是用3来乘以一个矩阵 然后这一项 很显然这是另一个标量乘法 或者可以叫标量除法 其实也就是1/3乘以这个矩阵 因此 如果我们先考虑这两项运算 那么我们将得到的是 我们看一下 3乘以这个矩阵 结果是3 12 6 然后和中间的矩阵相加 也就是0 0 5 最后再减去1 0 2/3 同样地 为了便于理解 我们再来梳理一下这几项 这里的这个加号 表明这是一个矩阵加法 对吧？ 当然这里是向量 别忘了 向量是特殊的矩阵 对吧？ 或者你也可以称之为 向量加法运算 同样 这里的减号表明 这是一个矩阵减法运算 但由于这是一个n行1列的矩阵 实际上是3行1列 因此这个矩阵 实际上是也一个向量 一个列向量 因此也可以把它称作向量的减法运算 明白了吗 最后再整理一下 最终的结果依然是一个向量 向量的第一个元素 是3+0-1 就是3-1 也就是2 第二个元素是12+0-0 也就是12 最后第三个元素 6+5-(2/3) 也就是11-(2/3) 结果是10又三分之一 关闭右括号 我们得到了最终的结果 这是一个3行1列的矩阵 或者也可以说是 一个维度为3的向量 这就是这个运算式的计算结果 所以 你学会了矩阵或向量的加减运算 以及矩阵或向量跟标量 或者说实数 的乘法运算 到目前为止 我只介绍了如何进行 矩阵或向量与数的乘法运算 在下一讲中 我们将讨论一个更有趣的话题 那就是如何进行 两个矩阵的乘法运算加法和标量乘法笔记 Matrix Vector Multiplication 在本节课的视频中 讨论如何 将两个矩阵相乘 我们将从矩阵相乘的 特例 向量相乘开始 即 一个矩阵与一个向量相乘 让我们从一个例子开始 左边是一个矩阵 右边是一个向量 假如我们 将这个矩阵 与这个向量相乘 结果会怎样呢？ 我先快速计算出结果 然后我们再 退回去 查看每一个步骤 很明显 相乘的结果 将是 一个向量 我先将这部分完成 然后再来解释 我刚刚是怎么做的 要计算出结果向量的第一个元素 我将会 取这两个数字 并把他们 把矩阵 A 的 然后把对应相乘的结果加起来 取1乘以1 同时取3 乘以 5 计算得到1和15 相加得16 我将在这儿写上16 要计算第二行 的第二个元素 我需要将第二行 与这个向量相乘 所以我得到 4乘以1 加上0乘以5 结果等于4 因此在这里写上4 对于最后一个元素 我需要计算(2, 1) 乘以 (1, 5) 所以先计算2乘以1 再加上 1乘以5 最后结果为7 所以我在这儿写上7 事实证明 3x2的矩阵 和一个2x1的矩阵 即一个二维向量 相乘的结果 我们得到的 将是一个3×1 的矩阵 这个3×1的矩阵 就是这么得来的 也就是一个三维向量 我想 我可能计算时做得很快 你们并不一定能够 自己重复这个过程 下面让我们更加仔细的看一下 刚刚我做了些什么以及一个向量 和一个矩阵相乘的计算过程是怎样的 下面详细介绍了如何 计算一个矩阵与一个向量相乘 假设这是一个矩阵A 我希望将它乘以 一个向量x 结果记为 向量y 所以 矩阵A是一个 m×n维矩阵 有m行和n列 我们让它与一个 n×1的矩阵相乘 换言之 一个n维向量 明显地 这里的两个n是相等的 也就是说 这个矩阵的列数 有n列 必须要与 另一个相乘矩阵的行数相同 即必须匹配这个向量的维数。 这样相乘的结果 将会是一个n维 向量y m 将与 矩阵A的行数 相同 那么如何计算这个向量y呢？ 事实上 计算y的过程可以分解为 计算 yi 的值 让 A 的第 i 行元素 分别乘以向量 x 中的元素 并且相加 就是这样子 为了得到 y 的第一个元素 无论是多少 我们将会 把矩阵 A 的 第一行元素 每次同一个向量 x 的元素 相乘 我取第一个数 与第一个数相乘 然后取第二个数同第二个数相乘 取第三个数 与第三个数相乘 直到全部乘完 最后 将这些相乘的结果 加起来 这样我们就得到了 y 的第一个元素 然后我们 来计算 y 的第二个元素 接下来我们 取A的第二行 然后重复整个过程 现在 我们取A的第二行 将它 与其他元素相乘 也就是 x 的元素 将结果相加 这样我们就得到了 y 的第二个元素 依次计算下去 我们取A得第三行 逐行地与 向量x相乘 将结果加起来 然后得到第三个元素 以此类推 直到最后一行 所以 上述就是具体步骤 让我们再举一个例子 在这个例子中 我们先看一下矩阵的维度 左边是一个 3×4矩阵 右边是一个四维向量 也就是4×1矩阵 所以这样相乘的结果 将是 一个三维向量 我们在写的时候要给这个向量 留三个元素的空间 现在让我们一起来算一下 首先是第一个元素 我将会取这四个数 并将它们与向量x相乘 所以我需要计算 1×1 加上2×3 加1×2 加5×1 等于 1 +6 再加上2 +6 也就是14 而对边距来说 第二个元素 我要 取这一行 然后与向量 (0×1)+3相乘 我们将得到 0×1 + 3×3 0×2 + 4×1 等于 9 + 4 也就是13 最后 对最后一个元素 我将取最后一行 所以我得到了-1×1 -2×3 加上0×2 加上0×1 所以 我们将得到-1和-6 相加得 -7 明白? 所以我最后的答案是 一个向量 其中的元素为 14 我将不给这些字涂上颜色 13 -7 如前面说的 计算结果是一个3×1的矩阵 上述就是矩阵和向量相乘的方法 我知道 这张幻灯片上内容很多 如果你在看的过程中 不是很确定这些数字怎么来的 你可以随时暂停视频 慢慢地 仔细琢磨 整个计算过程 尽量 确保自己理解了 得到14 13 11 这些结果的每一个步骤 最后 我将教你们一个小技巧 假设我 有四间房子 这些房子有四种大小 我有一个 假设函数 用于预测房子的价格 我需要计算 四间房子的大小作为 h(x) 的大小即预测的房价 这里有一种简单的方法 可以同时计算四间房子的预测价格 我可以将它简单地 利用 矩阵向量相乘的思想来计算 所以 对于这个问题我会这么计算 首先我要构建一个 如下所示的矩阵 元素是1 1 1 1 然后我把四个房子的大小 写在这儿 我还需要构造一个向量 我的向量 它将是一个 二维向量 即 40 和 0.25 这是预测函数的两个系数 θ0 和 θ1 接下来 我要做的就是 将我构造好的矩阵和向量相乘 这是相乘符号 我将得到什么结果呢？ 左边是一个 4×2 矩阵 右边是一个 2×1 矩阵 所以结果 将是一个4×1向量 对吧 所以 让我在幻灯片上写上 结果将是 一个4×1的矩阵 输出结果也就是 一个四维向量 让我来把它写出来 用四个实数表示我的四个元素 事实上 结果的第一个元素 我的计算方式 是 将这一行同我的向量相乘 结果将是 -40×1 + 4.25×2104 顺便说一下 在先前的幻灯片中 我写的是 1× (-40) + 2104 × 0.25 但是顺序无关紧要 对吧？ -40×1 和 1×(-40)是一样的 这第一个元素 就是当x为2104时的 h 值 因此 这是我的第一个房子的预测价格 那么 第二个元素呢？ 你应该已经想到了 我要怎么计算第二个元素了 对吧? 我要把这个乘以我的向量 所以就是 -40×1 + 0.25×1416 这就是x为1416的 h 对吧? 这是第三个 和第四个 后面就依次计算这个4×1矩阵的第三和第四个元素 得出结果 这里 我画了绿色边框的部分 是一个实数 对吧？ 它是一个实数 这里 我画了洋红色边框的部分 紫色 洋红色 边框 是一个实数 对吧？ 所以右边 最右边 就是一个 4×1矩阵 是一个4维向量 这个例子的一个小技巧是 当你 在程序中实现这个过程的时候 当你有四间房子 你想使用自己的预测函数 来预测房子的价格 完成这些工作 你可以用一行代码搞定 我们后面会谈到Octave 以及编程语言 你可以只写一行代码就完成整个过程 你可以这样写 prediction = DataMatrix × Parameters 对吧 数据矩阵是这一部分 参数 是这一部分 这就是一个矩阵向量乘法 如果你这么做了 这个变量prediction 抱歉 我的字写得很潦草 只需要实现 这一行代码 如果你有一个做矩阵向量相乘的函数库的话 如果你这样做的话 右侧的prediction变量就会形成 一个4维向量 给你所有的预测价格 另一种计算方式是 作为一种矩阵向量相乘的方式 实际上就是一种 通过for循环 for 1 to 4 对吧？ 如果说你有一千间房子 就将是 for 1 to 1000 或者别的任何数 然后如果i等于的话 你必须写一个 有一个假设条件 I相等 然后需要做 比矩阵向量相乘多得多的工作 当你有 大量的房子的时候 如果你试图预测 不只是四座 或许是一千座房子的时候 事实证明 当你使用矩阵向量相乘的方法时 在计算机中 使用任何语言 不仅仅是Octave 还有C++ Java Python 等高级语言 以及其他语言 都可以很快的实现 事实证明 像左边这样子写代码 不仅可以 简化你的代码 现在你只需要 写一行代码 而不是一堆代码 而且 还有一个微妙的好处 我们后面将会了解到 就是基于你所有的房子 这样做计算效率将会更高 比你像右边那样 用代码实现公式 的方式效率 将会高很多 我后面在讨论向量化的时候 会详细地 讨论这个问题 所以 通过这种方式计算预测值 不仅代码更加简洁 而且效率更高 基本用不上 我们在后面 在其他模型中 计算实例的回归的时候 将会有效地利用到这一讲的内容 在接下来的视频中 我将会从特殊到一般 讲讲矩阵与矩阵相乘的情况 矩阵向量乘法笔记 矩阵和向量的乘法如图：m×n 的矩阵乘以 n×1 的向量，得到的是 m×1 的向量 举例 Matrix Matrix 在这段视频中我们将会讨论 矩阵 矩阵的乘法以及 如何将两个矩阵相乘 我们会使用这样一种方法 在线性回归中用以解决 参数计算的问题 这种方法会把θ0、θ1等参数都放在一起来计算 也就是说 我们不需要一个迭代的梯度下降算法 当我们谈到这个算法的时候 就会发现矩阵以及矩阵间的乘法运算 是你必须理解的关键步骤之一 所以让我们像往常那样 从一个例子开始 比方说 我有两个矩阵 我想将它们相乘 让我先只是按照这个例子做一遍（乘法） 然后告诉你这其中运算的细节 那么 我要做的第一件事是 我先把 右边这个矩阵的第一列 提取出来 然后我将会把 左边的这个矩阵和 之前取出来的这一列（前面提过的，向量）相乘 这只是第一列 是吧？ 然后我们可以看到 如果我 这么做 我就会得到向量（11,9） 所以这是与上个视频的矩阵 和向量的乘法是一样的 我已经提前算出了这个结果 是（11,9） 那么 之后的第二件事 我要做的就是 我将把第二列再单独提出出来 右边这个矩阵的第二列 然后我将要把它和 左边这个矩阵相乘 是的吧 所以 这就是那个矩阵 用右边的第二列 来乘以这个矩阵 因此 同样的 这是一个矩阵和 向量的乘法运算 这 就是你从上一个视频所学到的 如果你这么做 把这个矩阵和这个向量相乘 你会得到 （10,14）这个结果 顺便说一下 如果你想练习 矩阵和向量的乘法运算 那么就先暂停下视频 自己算一算结果对不对 好吧 现在我仅仅需要 将得到的这两个结果放在一起 那么这就是我的答案了 那么 我们可以看到 计算结果是 一个2 x 2的矩阵 我用来填充这个矩阵的方法 就是 把我的（11,9） 填在这里 把（10，14）填在 第二列 是的吧？ 所以 这就是如何 将两个矩阵相乘的 详细方法与过程 每次你只需要看 第二个矩阵的一列 然后把你的答案拼凑起来 再次强调下 我们将一步步的来计算 几秒中的时间里需要非常仔细 但我也要指出 我也要指出的是 第一个例子是一个2X3矩阵 乘以一个 3x2的矩阵 他们相乘 得到的结果 是一个2x2的 矩阵 我们将很快知道为什么是这个结果 好的 这是计算的技巧 让我们再看看 这其中的细节 看看究竟发生了什么 下面就是详细的过程 我有一个矩阵A 我要把它乘以 矩阵B 其结果 会是一个新的矩阵C 并且你会发现你只能 相乘那些维度 匹配的矩阵 因此如果A是一个m×n的矩阵 就是说m行n列 我将要用它与 一个n×o的矩阵相乘 并且实际上这里的n 必须匹配这里的这个n 所以第一个矩阵的列的数目 必须等于第二矩阵中的行的数目 并且相乘得到的结果 结果会是一个m×o的矩阵 就像这个矩阵C这样 并且 在前面的视频中 我们所做的一切都符合这个规则 这是一种当矩阵B的o值 等于1的特殊情况（指的是矩阵和向量相乘） 明白了吗？ 这是在B是一个向量的情况下 但是现在 我们要处理 O的值大于1的情况 所以 这里就是你怎样 把两个矩阵相乘 为了得到结果 我要做的就是 我将要取 B矩阵的第一列 把取出的这列看成一个向量 并乘以矩阵A 用B矩阵的第一列 这个计算结果将是 m×1的矩阵（也就是一个向量） 我们把结果先放在这里 然后 我将要取 B矩阵的 第二列 那么我会又得到一个n×1的向量 也就是 这里的这一列 这是正确的 n×1的矩阵 也就是n维的向量 我将要把这个矩阵 和这些n乘1的向量相乘 其结果将是 一个m维的向量 然后我会把结果先放在那里 依此类推 对吧？ 那么 你知道的 我开始取第三列 把它和这个矩阵相乘 我又得到了一个M维向量 依此类推 直到你计算到了 最后一列 矩阵乘以 你取到的最后一列 就是C的最后一列 再说一遍 矩阵C的第i列 是根据把 矩阵A与 矩阵B的第i列 相乘得到的 结果 依次相加 从1,2到o依次相加的 对吧？ 那么 我们在这里做一个总结 我们总结了我们为了 计算矩阵C所做的步骤 让我们再看一个例子 比方说我想把这两个矩阵相乘 矩阵乘法笔记 Matrix Multiplication Properties 矩阵乘法的性质笔记 Inverse adn Transpose 只有方阵才有逆阵 Octave求逆阵 矩阵的逆和转置笔记]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习入门</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章 单变量线性回归(Linear Regression with One Variable)]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8D%95%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-Linear-Regression-with-One-Variable%2F</url>
    <content type="text"><![CDATA[第二章: 单变量线性回归(Linear Regression with One Variable)Gradient Descennt 我们已经定义了代价函数J 而在这段视频中 我想向你们介绍梯度下降这种算法 这种算法可以将代价函数J最小化 梯度下降是很常用的算法 它不仅被用在线性回归上 它实际上被广泛的应用于机器学习领域中的众多领域 在后面课程中 为了解决其他线性回归问题 我们&amp;&amp;也将使用梯度下降法 最小化其他函数 而不仅仅是只用在本节课的代价函数J 因此在这个视频中 我将讲解用梯度下降算法最小化函数 J 在后面的视频中 我们还会将此算法应用于具体的 代价函数J中来解决线性回归问题 下面是问题概述 在这里 我们有一个函数$J(\theta_0, \theta_1)$ 也许这是一个线性回归的代价函数 也许是一些其他函数 要使其最小化 我们需要用一个算法 来最小化函数$J(\theta_0, \theta_1)$ 就像刚才说的 事实证明 梯度下降算法可应用于 多种多样的函数求解 所以想象一下如果你有一个函数 J(θ0, θ1, θ2, …,θn ) 你希望可以通过最小化 θ0到θn 来最小化此代价函数J(θ0 到θn) 用n个θ是为了证明梯度下降算法可以解决更一般的问题 但为了简洁起见 为了简化符号 在接下来的视频中 我只用两个参数 下面就是关于梯度下降的构想 我们要做的是 我们要开始对θ0和θ1 进行一些初步猜测 它们到底是什么其实并不重要 但通常的选择是将 θ0设为0 将θ1也设为0 将它们都初始化为0 我们在梯度下降算法中要做的 就是不停地一点点地改变 θ0和θ1 试图通过这种改变使得J(θ0, θ1)变小 直到我们找到 J 的最小值 或许是局部最小值 让我们通过一些图片来看看梯度下降法是如何工作的 我在试图让这个函数值最小 注意坐标轴 θ0和θ1在水平轴上 而函数 J在垂直坐标轴上 图形表面高度则是 J的值 我们希望最小化这个函数 所以我们从 θ0和θ1的某个值出发 所以想象一下 对 θ0和θ1赋以某个初值 也就是对应于从这个函数表面上的某个起始点出发 对吧 所以不管 θ0和θ1的取值是多少 我将它们初始化为0 但有时你也可把它初始化为其他值 现在我希望大家把这个图像想象为一座山 想像类似这样的景色 公园中有两座山 想象一下你正站立在山的这一点上 站立在你想象的公园这座红色山上 在梯度下降算法中 我们要做的就是旋转360度 看看我们的周围 并问自己 我要在某个方向上 用小碎步尽快下山 这些小碎步需要朝什么方向? 如果我们站在山坡上的这一点 你看一下周围 你会发现最佳的下山方向 大约是那个方向 好的 现在你在山上的新起点上 你再看看周围 然后再一次想想 我应该从什么方向迈着小碎步下山? 然后你按照自己的判断又迈出一步 往那个方向走了一步 然后重复上面的步骤 从这个新的点 你环顾四周 并决定从什么方向将会最快下山 然后又迈进了一小步 又是一小步 并依此类推 直到你接近这里 直到局部最低点的位置 此外 这种下降有一个有趣的特点 第一次我们是从这个点开始进行梯度下降算法的 是吧 在这一点上从这里开始 现在想象一下 我们在刚才的右边一些的位置 对梯度下降进行初始化 想象我们在右边高一些的这个点 开始使用梯度下降 如果你重复上述步骤 停留在该点 并环顾四周 往下降最快的方向迈出一小步 然后环顾四周 又迈出一步 然后如此往复 如果你从右边不远处开始 梯度下降算法将会带你来到 这个右边的第二个局部最优处 如果从刚才的第一个点出发 你会得到这个局部最优解 但如果你的起始点偏移了一些 起始点的位置略有不同 你会得到一个 非常不同的局部最优解 这就是梯度下降算法的一个特点 我们会在之后继续探讨这个问题 好的 这是我们从图中得到的直观感受 看看这个图 这是梯度下降算法的定义 我们将会反复做这些 直到收敛 我们要更新参数 θj 方法是 用 θj 减去 α乘以这一部分 := 表示赋值 这是一个赋值运算符 等号 = :写出a=b 那么这是一个判断为真的声明 如果我写 a=b 就是在断言 a的值是等于 b的值的 这是声明 声明 a的值 与b的值相同 α :一个数字 被称为学习速率 什么是α呢? 在梯度下降算法中 它控制了 我们下山时会迈出多大的步子 因此如果 α值很大 那么相应的梯度下降过程中 我们会试图用大步子下山 如果α值很小 那么我们会迈着很小的小碎步下山 关于如何设置 α的值等内容 在之后的课程中 我会回到这里并且详细说明 最后 是公式的这一部分这是一个微分项 我现在不想谈论它 但我会推导出这个微分项 并告诉你到底这要如何计算 你们中有人大概比较熟悉微积分 但即使你不熟悉微积分 也不用担心 我会告诉你 对这一项 你最后需要做什么 现在 在梯度下降算法中 还有一个更微妙的问题 在梯度下降中 我们要更新 θ0和θ1 当 j=0 和 j=1 时 会产生更新 所以你将更新 J θ0还有θ1 实现梯度下降算法的微妙之处是 在这个表达式中 如果你要更新这个等式 你需要同时更新 θ0和θ1 我的意思是在这个等式中 我们要这样更新 θ0:=θ0 - 一些东西 并更新 θ1:=θ1 - 一些东西 实现方法是 你应该计算公式右边的部分 通过那一部分计算出θ0和θ1的值 然后同时更新 θ0和θ1 让我进一步阐述这个过程 在梯度下降算法中 这是正确实现同时更新的方法 我要设 temp0等于这些 设temp1等于那些 所以首先计算出公式右边这一部分 然后将计算出的结果 一起存入 temp0和 temp1 之中 然后同时更新 θ0和θ1 因为这才是正确的实现方法 与此相反 下面是不正确的实现方法 因为它没有做到同步更新 在这种不正确的实现方法中 我们计算 temp0 然后我们更新θ0 然后我们计算 temp1 然后我们将 temp1 赋给θ1 右边的方法和左边的区别是 让我们看这里 就是这一步 如果这个时候你已经更新了θ0 那么你会使用 θ0的新的值来计算这个微分项 所以由于你已经在这个公式中使用了新的 θ0的值 那么这会产生一个与左边不同的 temp1的值 所以右边并不是正确地实现梯度下降的做法 我不打算解释为什么你需要同时更新 同时更新是梯度下降中的一种常用方法 我们之后会讲到 实际上同步更新是更自然的实现方法 当人们谈到梯度下降时 他们的意思就是同步更新 如果用非同步更新去实现算法 代码可能也会正确工作 但是右边的方法并不是人们所指的那个梯度下降算法 而是具有不同性质的其他算法 由于各种原因 这其中会表现出微小的差别 你应该做的是 在梯度下降中真正实现同时更新 这些就是梯度下降算法的梗概 在接下来的视频中 我们要进入这个微分项的细节之中 我已经写了出来但没有真正定义 如果你已经修过微积分课程 如果你熟悉偏导数和导数 这其实就是这个微分项 如果你不熟悉微积分 不用担心 即使你之前没有看过微积分 或者没有接触过偏导数 在接下来的视频中 你会得到一切你需要知道的 如何计算这个微分项的知识 下一个视频中 希望我们能够给出 实现梯度下降算法的所有知识 Gradient Descennt笔记 所以我们有我们的假设函数，并且我们有一种测量它适合数据的方式。现在我们需要估计假设函数中的参数。这就是梯度下降的地方。 设想我们根据它的域θ0和θ1来描绘我们的假设函数（实际上我们将代价函数绘制为参数估计的函数）。我们不是图表x和y本身，而是我们的假设函数的参数范围和选择一组特定参数所产生的成本。 我们在x轴上放置θ0，在y轴上放置θ1，在垂直z轴上放置代价函数。我们图上的点将是使用我们的假设与那些特定theta参数的成本函数的结果。下面的图表描述了这样的设置。 当我们的代价函数处于图的坑底时，即当其值最小时，我们将知道我们已经成功了。红色箭头显示图表中的最小点。 我们这样做的方式是通过获取代价函数的导数（函数的切线）。切线的斜率是该点的导数，它会给我们一个走向的方向。我们逐步降低成本函数的下降速度。每一步的大小由参数α决定，称为学习率。 例如，上图中每个“星号”之间的距离代表由我们的参数α确定的一个步骤。 α越小，步长越小，α越大，步长越大。步进的方向取决于J（θ0，θ1）的偏导数。根据图表的起始位置，可能会出现不同的点。上面的图片向我们展示了两个不同的起点，最终在两个不同的地方。 梯度下降算法是：重复，直到收敛： j = 0,1代表特征索引号。 在每次迭代j中，应同时更新参数θ1，θ2，…，θn。在计算第j次迭代之前更新特定参数会导致错误的实现。 Gradient Descent Intuition 在之前的视频中 我们给出了一个数学上关于梯度 下降的定义 本次视频我们更深入研究一下 更直观地感受一下这个 算法是做什么的 以及梯度下降算法的更新过程有什么意义 这是我们上次视频中看到的梯度下降算法 提醒一下 这个参数 α 术语称为学习速率 它控制我们以多大的幅度更新这个参数θj. 第二部分是导数项 而我在这个视频中要做的就是 给你一个更直观的认识 这两部分有什么用 以及 为什么当把 这两部分放一起时 整个更新过程是有意义的 为了更好地让你明白 我要做是用一个稍微简单的例子 比如我们想最小化的那个 函数只有一个参数的情形 所以 假如我们有一个代价函数J 只有一个参数 θ1 就像我们前几次视频中讲的 θ1是一个实数 对吧？那么我们可以画出一维的曲线 看起来很简单 让我们试着去理解 为什么梯度下降法 会在这个函数上起作用 所以 假如这是我的函数 关于$\theta_1$的函数$J(\theta_1)$是一个实数 对吧？ 现在我们已经对这个点上用于梯度下降法的$\theta_1$ 进行了初始化 想象一下在我的函数图像上 从那个点出发 那么梯度下降 要做的事情是不断更新 θ1等于θ1减α倍的 d/dθ1J(θ1)这个项 对吧？哦 顺便插一句 你知道 这个微分项是吧？可能你想问为什么我改变了符号 之前用的是偏导数的符号 如果你不知道偏导数的符号 和d/dθ之间的区别是什么 不用担心 从技术上讲 在数学中 我们称这是一个偏导数 这是一个导数 这取决于函数J的参数数量 但是这是一个 数学上的区别 就本课的目标而言 可以默认为 这些偏导数符号 和d/dθ1是完全一样的东西 不用担心 是否存在任何差异 我会尽量使用数学上的 精确的符号 但就我们的目的而言 这些符号是没有区别的 好的 那么我们来看这个方程 我们要计算 这个导数 求导的目的 基本上可以说 取这一点的切线 就是这样一条红色的直线 刚好与函数相切于这一点 让我们看看这条红色直线的斜率 其实这就是导数 也就是说 直线的斜率 也就是这条 刚好与函数曲线相切的这条直线 这条直线的斜率正好是 这个高度除以这个水平长度 现在 这条线有 一个正斜率 也就是说它有正导数 因此 我得到的新的θ θ1更新后等于θ1减去一个正数乘以α. α 也就是学习速率也是一个正数 所以 我要使θ1减去一个东西 所以相当于我将θ1向左移 使θ1变小了 我们可以看到 这么做是对的 因为实际上我往这个方向移动 确实让我更接近那边的最低点 所以 梯度下降到目前为止似乎 是在做正确的事 让我们来看看另一个例子 让我们用同样的函数J 同样再画出函数J(θ1)的图像 而这次 我们把参数初始化到左边这点 所以θ1在这里 同样把这点对应到曲线上 现在 导数项d/dθ1J(θ1)在这点上计算时 看上去会是这样 这条线的斜率 这个导数是这条线的斜率 但是这条线向下倾斜 所以这条线具有负斜率 对吧？ 或者说 这个函数有负导数 也就意味着在那一点上有负斜率 因此 这个导数项小于等于零 所以 当我更新θ时 θ被更新为θ减去α乘以一个负数 因此我是在用 θ1减去一个负数 这意味着我实际上是在增加θ1 对不对？因为这是减去一个负数 意味着给θ加上一个数 这就意味着最后我实际上增加了θ的值 因此 我们将 从这里开始 增加θ 似乎这也是我希望得到的 也就是 让我更接近最小值了 所以 我希望这样很直观地给你解释了 导数项的意义 让我们接下来再看一看学习速率α 我们来研究一下它有什么用 这就是我梯度下降法的 更新规则 就是这个等式 让我们来看看如果α 太小或 α 太大 会出现什么情况 这第一个例子 α太小会发生什么呢 这是我的函数J(θ) 就从这里开始 如果α太小了 那么我要做的是要去 用一个比较小的数乘以更新的值 所以最终 它就像一个小宝宝的步伐 这是一步 然后从这个新的起点开始 迈出另一步 但是由于α 太小 因此只能迈出另一个 小碎步 所以如果我的学习速率太小 结果就是 只能这样像小宝宝一样一点点地挪动 去努力接近最低点 这样就需要很多步才能到达最低点 所以如果α 太小的话 可能会很慢 因为它会一点点挪动 它会需要 很多步才能到达全局最低点 那么如果α 太大又会怎样呢 这是我的函数J(θ) 如果α 太大 那么梯度下降法可能会越过最低点 甚至可能无法收敛 我的意思是 比如我们从这个点开始 实际上这个点已经接近最低点 因此导数指向右侧 但如果α 太大的话 我会迈出很大一步 也许像这样巨大的一步 对吧？所以我最终迈出了一大步 现在 我的代价函数变得更糟 因为离这个最低点越来越远 现在我的导数指向左侧 实际上在减小θ 但是你看 如果我的学习速率过大 我会移动一大步 从这点一下子又到那点了 对吗？如果我的学习率太大 下一次迭代 又移动了一大步 越过一次 又越过一次 一次次越过最低点 直到你发现 实际上 离最低点越来越远 所以 如果α太大 它会导致无法收敛 甚至发散 现在 我还有一个问题 这问题挺狡猾的 如果我们预先把θ1 放在一个局部的最低点 你认为下一步梯度下降法会怎样工作？ 所以假设你将θ1初始化在局部最低点 假设这是你的θ1的初始值 在这儿 它已经在一个局部的 最优处或局部最低点 结果是局部最优点的导数 将等于零 因为它是那条切线的斜率 而这条线的斜率将等于零 因此 此导数项等于0 因此 在你的梯度下降更新过程中 你有一个θ1 然后用θ1 减α 乘以0来更新θ1 所以这意味着什么 这意味着你已经在局部最优点 它使得θ1不再改变 也就是新的θ1等于原来的θ1 因此 如果你的参数已经处于 局部最低点 那么梯度下降法更新其实什么都没做 它不会改变参数的值 这也正是你想要的 因为它使你的解始终保持在 局部最优点 这也解释了为什么即使学习速率α 保持不变时 梯度下降也可以收敛到局部最低点 我想说的是这个意思 我们来看一个例子 这是代价函数J(θ) 我想找到它的最小值 首先初始化我的梯度下降算法 在那个品红色的点初始化 如果我更新一步梯度下降 也许它会带我到这个点 因为这个点的导数是相当陡的 现在 在这个绿色的点 如果我再更新一步 你会发现我的导数 也即斜率 是没那么陡的 相比于在品红点 对吧？因为随着我接近最低点 我的导数越来越接近零 所以 梯度下降一步后 新的导数会变小一点点 然后我想再梯度下降一步 在这个绿点我自然会用一个稍微 跟刚才在那个品红点时比 再小一点的一步 现在到了新的点 红色点 更接近全局最低点了 因此这点的导数会比在绿点时更小 所以 我再进行一步梯度下降时 我的导数项是更小的 θ1更新的幅度就会更小 所以你会移动更小的一步 像这样 随着梯度下降法的运行 你移动的幅度会自动变得越来越小 直到最终移动幅度非常小 你会发现 已经收敛到局部极小值 所以回顾一下 在梯度下降法中 当我们接近局部最低点时 梯度下降法会自动采取 更小的幅度 这是因为当我们接近局部最低点时 很显然在局部最低时导数等于零 所以当我们 接近局部最低时 导数值会自动变得越来越小 所以梯度下降将自动采取较小的幅度 这就是梯度下降的做法 所以实际上没有必要再另外减小α 这就是梯度下降算法 你可以用它来最小化 最小化任何代价函数J 不只是线性回归中的代价函数J 在接下来的视频中 我们要用代价函数J 回到它的本质 线性回归中的代价函数 也就是我们前面得出的平方误差函数 结合梯度下降法 以及平方代价函数 我们会得出第一个机器学习算法 即线性回归算法 Gradient Descent Intuition笔记 在本视频中，我们探索了使用一个参数θ1并绘制其代价函数来实现梯度下降的场景。 我们的单一参数公式为： 无论的斜率符号如何，θ1最终收敛到其最小值。 下图显示当斜率为负值时，θ1的值增加，当为正值时，θ1的值减小。 在附注中，我们应该调整参数α以确保梯度下降算法在合理的时间内收敛。 未能收敛或获得最小值的时间太多意味着我们的步长是错误的。 梯度下降如何以固定步长α收敛？收敛背后的直觉是，当我们逼近我们的凸函数的底部时，接近0。 至少，派生将始终为0，因此我们得到： Gradient Descent For Linear Regression 在以前的视频中我们谈到 关于梯度下降算法 梯度下降是很常用的算法 它不仅被用在线性回归上 和线性回归模型、平方误差代价函数 在这段视频中 我们要 将梯度下降 和代价函数结合 在后面的视频中 我们将用到此算法 并将其应用于 具体的拟合直线的线性回归算法里 这就是 我们在之前的课程里所做的工作 这是梯度下降算法 这个算法你应该很熟悉 这是线性回归模型 还有线性假设和平方误差代价函数 我们将要做的就是 用梯度下降的方法 来最小化平方误差代价函数 为了 使梯度下降 为了 写这段代码 我们需要的关键项 是这里这个微分项 所以.我们需要弄清楚 这个偏导数项是什么 并结合这里的 代价函数J 的定义 就是这样 一个求和项 代价函数就是 这个误差平方项 我这样做 只是 把定义好的代价函数 插入了这个微分式 再简化一下 这等于是 这一个求和项 θ0 + θ1x(i) - y(i) 实际上我们需要 弄清楚这两个 偏导数项是什么 这两项分别是 j=0 和j=1的情况 因此我们要弄清楚 θ0 和 θ1 对应的 偏导数项是什么 (将上面的式子平方化开再分别对θ0 和θ1求偏导) 所以 偏导数项 从这个等式 到下面的等式 计算这些偏导数项需要一些多元微积分 如果你掌握了微积分 你可以随便自己推导这些 然后你检查你的微分 你实际上会得到我给出的答案 但如果你 不太熟悉微积分 别担心 你可以直接用这些 已经算出来的结果 你不需要掌握微积分 或者别的东西 来完成作业 你只需要会用梯度下降就可以 在定义这些以后 在我们算出 这些微分项以后 这些微分项 实际上就是代价函数J的斜率 现在可以将它们放回 我们的梯度下降算法 所以这就是专用于 线性回归的梯度下降 反复执行括号中的式子直到收敛 θ0和θ1不断被更新 都是加上一个-α/m 乘上后面的求和项 所以这里这一项 所以这就是我们的线性回归算法 这一项就是关于θ0的偏导数 在上一张幻灯片中推出的 而第二项 这一项是刚刚的推导出的 关于θ1的 偏导数项 提醒一下 执行梯度下降时 有一个细节要注意 就是必须要 同时更新θ0和θ1 所以 让我们来看看梯度下降是如何工作的 我们用梯度下降解决问题的 一个原因是 它更容易得到局部最优值 当我第一次解释梯度下降时 我展示过这幅图 在表面上 不断下降 并且我们知道了 根据你的初始化 你会得到不同的局部最优解 你知道.你可以结束了.在这里或这里。 但是 事实证明 用于线性回归的 代价函数 总是这样一个 弓形的样子 这个函数的专业术语是 这是一个凸函数 我不打算在这门课中 给出凸函数的定义 凸函数(convex function) 但不正式的说法是 它就是一个弓形的函数 因此 这个函数 没有任何局部最优解 只有一个全局最优解 并且无论什么时候 你对这种代价函数 使用线性回归 梯度下降法得到的结果 总是收敛到全局最优值 因为没有全局最优以外的其他局部最优点 现在 让我们来看看这个算法的执行过程 像往常一样 这是假设函数的图 还有代价函数J的图 让我们来看看如何 初始化参数的值通常来说 初始化参数为零 θ0和θ1都在零 但为了展示需要 在这个梯度下降的实现中 我把θ0初始化为-900 θ1初始化为-0.1 现在进行一次梯度下降,从一点开始向左下方移动一小步,然后就得到了第二个点,假设函数的线改变了一点点. 不断的移动代价函数的点梯度不断下降,假设函数越来越拟合数据,,直到收敛到全局最小值 现在就可以用它来预测房价了. “Batch”Gradient Descent:批量梯度下降:在梯度下降的每一步中,我们都用到了所有的训练样本 在梯度下降中,在计算微分求导项时,我们需要进行求和计算,所以在每一个单独的梯度计算中,我们最终都要计算这样一个东西—这个项需要对所有m个训练样本求和.]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习入门</category>
      </categories>
      <tags>
        <tag>单变量线性回归</tag>
        <tag>Linear-Regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章: Model and Cost Function]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Model-and-Cost-Function%2F</url>
    <content type="text"><![CDATA[第一章： Model and Cost FunctionModel Representation:模型表示 我们的第一个学习算法是线性回归算法,了解监督学习过程完整的流程 例子 这个例子是预测住房价格的 我们要使用一个数据集 数据集包含俄勒冈州波特兰市的住房价格 在这里 我要根据不同房屋尺寸所售出的价格 画出我的数据集 比方说 我们来看这个数据集 你有一个朋友正想出售自己的房子 如果你朋友的房子是1250平方尺大小 你要告诉他们 这房子能卖多少钱 那么 你可以做的一件事就是 构建一个模型 也许是条直线 从这个数据模型上来看 也许你可以告诉你的朋友 他能以大约220000(美元)左右的价格 卖掉这个房子 那么这就是监督学习算法的一个例子 它被称作监督学习是因为对于每个数据来说 我们给出了 “正确的答案” 即告诉我们 根据我们的数据来说 房子实际的价格是多少 而且 更具体来说 这是一个回归问题 回归一词指的是我们根据之前的数据预测出一个准确的输出值 对于这个例子就是价格 同时 还有另一种最常见的监督学习方式 叫做分类问题 当我们想要预测离散的输出值 例如 如果我们正在寻找 癌症肿瘤并想要确定 肿瘤是良性的还是恶性的 这就是0/1离散输出的问题 更进一步来说 在监督学习中我们有一个数据集 这个数据集被称训练集 因此对于房价的例子 我们有一个训练集 包含不同的房屋价格 我们的任务就是从这个数据中学习预测房屋价格 现在我们给出这门课中经常使用的一些符号定义 我们要定义颇多符号 不过没关系 现在你记不住所有的符号也没关系 随着课程的进展 你会发现记住这些符号会很有用 我将在整个课程中用小写的 m:来表示训练样本的数目 因此 在这个数据集中 如果表中有47行 那么我们就有47组训练样本 m就等于47 x来表示输入变量 往往也被称为特征量 这就是用x表示输入的特征 y来表示输出变量或者目标变量 也就是我的预测结果 那么这就是第二列 在这里使用(x, y)来表示一个训练样本 所以 在这个表格中的单独的一行对应于一个训练样本 表示某个训练样本 我将使用x上标(i)与y上标(i)来表示 ,即 这就是一个监督学习算法的工作方式 我们可以看到这里有我们的训练集里房屋价格 我们把它喂给我们的学习算法 这就是学习算法的工作了 然后输出一个函数 按照惯例 通常表示为小写h h代表hypothesis(假设) h表示一个函数 输入是房屋尺寸大小 就像你朋友想出售的房屋 因此 h 根据输入的 x 值来得出 y 值 y值对应房子的价格 因此 h是一个从x到y的函数映射 人们经常问我为什么这个函数被称作假设(hypothesis)你们中有些人可能知道hypothesis的意思 从字典或者其它什么方式可以查到 其实在机器学习中 这是一个在早期被用于机器学习的名称 它有点绕口 对这类函数来说 这可能不是一个很恰当的名字 对表示从房屋的大小到价格的函数映射 我认为这个词”hypothesis” 可能不是最好的名称 但是这是人们在机器学习中使用的标准术语 所以不用太纠结人们为什么这么叫它 当设计学习算法的时候 我们接下来需要去思考的是 怎样得到这个假设h 对于这一点在接下来的几个视频中 我将选择最初的使用规则 h代表hypothesis 我们将会这么写为了方便 有时非书面形式也可以这么写 hθ(x) 我就写成h(x) 这是缩写方式 但一般来说我会保留这个下标θ 从这个图片中 所有这一切意味着我们要预测一个关于x的 线性函数 y 对吧? 所以这就是数据集和函数的作用:用来预测 这里是y关于x的线性函数 hθ(x)=θ0+θ1*x 那么为什么是一个线性函数呢? 有时候 我们会有更复杂的函数 也许是非线性函数 但是 由于线性方程是简单的形式 我们将先从线性方程的例子入手 当然 最终我们将会建立更复杂的模型 以及更复杂的学习算法 好吧 让我们也给这模型 起一个名字 这个模型被称为线性回归(linear regression)模型 另外 这实际上是关于单个变量的线性回归 这个变量就是x 根据x来预测所有的价格函数 同时 对于这种模型有另外一个名称 称作单变量线性回归 单变量是对一个变量的一种 特别的表述方式 总而言之 这就是线性回归 在接下来的视频中 我们将开始讨论如何去实现这种模型 笔记–Model Representation模型表示 为了建立将来使用的符号，我们将使用 x^i来表示“输入”变量（在这个例子中是居住区域），也被称为输入要素，而 y^i 表示我们试图预测的“输出”或目标变量（价格）。一对 (x^i，y^i)被称为训练样例，我们将用来学习的数据集----m个训练样例的列表(x^i，y^i);i= 1，。 。 。 ，m—- 被称为训练集。请注意，符号中的上标“（i）”仅仅是训练集的索引，与幂运算无关。我们也将用X来表示输入值的空间，用Y来表示输出值的空间。在这个例子中，X = Y =ℝ。 为了更形式化地描述监督学习问题，我们的目标是在给定训练集的情况下，去学习一个函数h：X→Y，使得h（x）是y的相应值的“好”预测器。由于历史原因，这个函数h被称为假设。从形象上看，这个过程是这样的： 当我们试图预测的目标变量是连续的，比如在我们的住房例子中，我们把学习问题称为回归问题。当y只能接受少量的离散值时（比如，如果考虑到居住面积，我们想要预测一个住宅是房子还是公寓），我们称之为分类问题。 Cost Function(代价函数) 这里将定义代价函数的概念 这有助于我们 弄清楚如何把最有可能的直线与我们的数据相拟合 在线性回归中我们有一个像这样的训练集 记住M代表了训练样本的数量 所以 比如说M = 47 而我们的假设函数 也就是用来进行预测的函数 是这样的线性函数形式 接下来我们会引入一些术语 这些θ0和θ1 这些θi我把它们称为模型参数 在这个视频中 我们要做的就是谈谈如何选择这两个参数值θ0和θ1 选择不同的参数θ0和θ1 我们会得到不同的假设函数，如果θ0是1.5 θ1是0 那么假设函数会看起来是这样， 因为你的假设函数是h(x)=1.5+0*x 是这样一个常数函数 恒等于1.5 如果θ0=0并且θ1=0.5 那么假设会看起来像这样 它会通过点(2,1) 这样你又得到了h(x) 或者hθ(x) 但是有时我们为了简洁会省略θ 因此 h(x)将等于0.5倍的x 就像这样 最后 如果θ0=1并且θ1=0.5 我们最后得到的假设会看起来像这样 让我们来看看 它应该通过点(2,2) 这是我的新的h(x)或者写作hθ(x) 对吧？ 你还记得之前我们提到过·hθ(x)的 但作为简写 我们通常只把它写作h(x)· 在线性回归中 我们有一个训练集 可能就像我在这里绘制的 我们要做的就是 得出θ0 θ1这两个参数的值 来让假设函数表示的直线 尽量地与这些数据点很好的拟合 也许就像这里的这条线一样 那么我们如何得出θ0 θ1的值 来使它很好地拟合数据的呢？我们的想法是 我们要选择 能使h(x) 也就是 输入x时我们预测的值 最接近该样本对应的y值的参数θ0 θ1所以 在我们的训练集中我们会得到一定数量的样本 我们知道x表示卖出哪所房子 并且知道这所房子的实际价格 所以 我们要尽量选择参数值 使得 在训练集中 给出训练集中的x值 我们能合理准确地预测y的值 让我们给出标准的定义 在线性回归中 我们要解决的是一个最小化问题 所以我要写出关于θ0 θ1的最小化 而且 我希望这个式子极其小 是吧 我想要h(x)和y之间的差异要小 我要做的事情是尽量减少假设的输出与房子真实价格 之间的差的平方 接下来我会详细的阐述 别忘了 我用符号( x(i),y(i) )代表第i个样本 所以我想要做的是对所有训练样本进行一个求和 对i=1到i=M的样本 将对假设进行预测得到的结果 此时的输入是第i号房子的面积 对吧 将第i号对应的预测结果 减去第i号房子的实际价格 所得的差的平方相加得到总和 而我希望尽量减小这个值 也就是预测值和实际值的差的平方误差和 或者说预测价格和 实际卖出价格的差的平方 我说了这里的m指的是训练集的样本容量 对吧 这个井号是训练样本“个数”的缩写 对吧 而为了让表达式的数学意义 变得容易理解一点 我们实际上考虑的是 这个数的1/m 因此我们要尝试尽量减少我们的平均误差 也就是尽量减少其1/2m 通常是这个数的一半 前面的这些只是为了使数学更直白一点 因此对这个求和值的二分之一求最小值 应该得出相同的θ0值和相同的θ1值来 请大家一定弄清楚这个道理 没问题吧？在这里hθ(x)的这种表达 这是我们的假设 它等于θ0加上θ1与x(i)的乘积 而这个表达 表示关于θ0和θ1的最小化过程 这意味着我们要找到θ0和θ1 的值来使这个表达式的值最小 这个表达式因θ0和θ1的变化而变化对吧？ 因此 简单地说 我们正在把这个问题变成 找到能使 我的训练集中预测值和真实值的差的平方的和 的1/2M最小的θ0和θ1的值 因此 这将是我的线性回归的整体目标函数 为了使它更明确一点 我们要改写这个函数 按照惯例 我要定义一个代价函数 正如屏幕中所示 这里的这个公式 我们想要做的就是关于θ0和θ1 对函数J(θ0,θ1)求最小值 这就是我的代价函数 代价函数也被称作平方误差函数 有时也被称为 平方误差代价函数 事实上 我们之所以要求出 误差的平方和 是因为误差平方代价函数 对于大多数问题 特别是回归问题 都是一个合理的选择 还有其他的代价函数也能很好地发挥作用 但是平方误差代价函数可能是解决回归问题最常用的手段了 在后续课程中 我们还会谈论其他的代价函数 但我们刚刚讲的选择是对于大多数线性回归问题非常合理的 好吧 所以这是代价函数 到目前为止 我们已经 介绍了代价函数的数学定义 也许这个函数J(θ0,θ1)有点抽象 可能你仍然不知道它的内涵 在接下来的几个视频里 我们要更进一步解释 代价函数J的工作原理 并尝试更直观地解释它在计算什么 以及我们使用它的目的 Cost Function(代价函数)笔记 我们可以通过使用代价函数来衡量我们的假设函数的准确性。 这个假设的所有结果的平均差异（实际上是一个平均值的更漂亮的版本）与来自x的输入和实际输出y的输入。 To break it apart，结果是，其中是 $h_\theta(x_i)-y_i$ 平方的平均值，或预测值与实际值之间的差值。 该函数被称为“平方误差函数(Squared error function)”或“均方误差(Mean squared error)”。 由于平方函数的导数项将抵消该项，平均值被减半以作为计算梯度下降的便利。 以下图片总结了成本函数的作用： Cost Function - Intuition I 在上一个视频中 我们给了代价函数一个数学上的定义 在这个视频里 让我们通过一些例子来获取一些直观的感受 看看代价函数到底是在干什么 回顾一下 这是我们上次所讲过的内容 我们想找一条直线来拟合我们的数据 所以我们用 θ0 θ1 等参数 得到了这个假设 而且通过选择不同的参数 我们会得到不同的直线拟合 所以拟合出的数据就像这样 然后我们还有一个代价函数 这就是我们的优化目标 在这个视频里 为了更好地 将代价函数可视化 我将使用一个简化的假设函数 就是下面这个函数 然后我将会用这个简化的假设 也就是 θ1*x 我们可以将这个函数看成是 把 θ0 设为0 所以我只有一个参数 也就是 θ1 代价函数看起来与之前的很像 唯一的区别是现在 h(x) 等于 θ1*x 只有一个参数 θ1 所以我的 优化目标是将 J(θ1)最小化 用图形来表示就是 如果 θ0 等于零 也就意味这我们选择的假设函数 会经过原点 也就是经过坐标 (0,0) 通过利用简化的假设得到的代价函数 我们可以试着更好地理解 代价函数这个概念 我们要理解的是这两个重要的函数 第一个是假设函数 第二个是代价函数 注意这个假设函数 h(x) 对于一个固定的 θ1 ，h(x)是关于 x 的函数 所以这个假设函数就是一个关于 x 这个房子大小的函数 与此不同的是 代价函数 J 是一个关于参数 θ1 的函数 而 θ1 控制着这条直线的斜率 现在我们把这写函数都画出来 试着更好地理解它们 我们从假设函数开始 比如说这里是我的训练样本 它包含了三个点 (1,1) (2,2) 和 (3,3) 现在我们随便选择一个值 θ1 ，这里选择 θ1 等于1 ，选择 θ1=1之后， 那么我的假设函数看起来就会像是这条直线 我将要指出的是 当我想要描绘出我的假设函数时， 我的横轴被标定为X轴 X轴是表示房子大小的量 现在暂时把 θ1 定为1 我想要做的就是 算出在 θ1 等于 1 的时候 J(θ1) 等于多少 所以我们 按照这个思路来计算代价函数的大小 和之前一样 代价函数定义如下 是吧 对这个误差平方项进行求和 这就等于 这样一个形式 简化以后就等于 三个0的平方和 当然还是0 现在 在代价函数里 我们发现所有这些值都等于0 因为对于我所选定的这三个训练样本 ( 1 ,1 ) (2,2) 和 (3,3) 如果 θ1 等于 1 那么 h(x(i)) 就会正好等于 y(i) 所以 h(x) - y 所有的这些值都会等于零 这也就是为什么J(1) 等于零 所以 我们现在知道了 J(1) 是0 让我把这个画出来 我将要在屏幕右边画出我的代价函数 J 要注意的是 因为我的代价函数是关于参数 θ1 的函数 当我描绘我的代价函数时 X轴就是 θ1 现在我有 J(1) 等于零 让我们继续把函数画出来 结果我们会得到这样一个点 现在我们来看其它一些样本 θ1 可以被设定为 某个范围内各种可能的取值 所以 θ1 可以取负数 0 或者正数 所以如果 θ1 等于0.5会发生什么呢 继续把它画出来 现在要把 θ1 设为0.5 在这个条件下 我的假设函数看起来就是这样 这条线的斜率等于0.5 现在让我们计算 J(0.5) 所以这将会等于1除以2m 乘以那一块 其实我们不难发现后面的求和 就是这条线段的高度的平方 加上这条线段高度的平方 再加上这条线段高度的平方 三者求和 对吗？ 就是 y(i) 与预测值 h(x(i)) 的差 对吗 所以第一个样本将会是0.5减去1的平方 因为我的假设函数预测的值是0.5 而实际值则是1 第二个样本 我得到的是1减去2的平方 因为我的假设函数预测的值是1 但是实际房价是2 最后 加上 1.5减去3的平方 那么这就等于1除以2乘以3 因为训练样本有三个点所以 m 等于3 对吧 然后乘以括号里的内容 简化后就是3.5 所以这就等于3.5除以6 也就约等于0.68 让我们把这个点画出来 不好意思 有一个计算错误 这实际上该是0.58 所以我们把点画出来 大约会是在这里 对吗 现在 让我们再多做一个点 让我们试试θ1等于0 J(0) 会等于多少呢 如果θ1等于0 那么 h(x) 就会等于一条水平的线 对了 就会像这样是水平的 所以 测出这些误差 我们将会得到 J(0) 等于 1除以 2m 乘以1的平方 加上2的平方 加上3的平方 也就是 1除以6乘以14 也就是2.3左右 所以让我们接着把这个点也画出来 所以这个点最后是2.3 当然我们可以接着设定 θ1 等于别的值 进行计算 你也可以把 θ1 设定成一个负数 所以如果 θ1 是负数 那么 h(x) 将会等于 打个比方说 －0.5 乘以x 然后 θ1 就是 -0.5 那么这将会 对应着一个斜率为-0.5的假设函数 而且你可以 继续计算这些误差 结果你会发现 对于0.5 结果会是非常大的误差 最后会得到一个较大的数值 类似于5.25 等等 对于不同的 θ1 你可以计算出这些对应的值 对吗 结果你会发现 你算出来的这些值 你得到一条这样的曲线 通过计算这些值 你可以慢慢地得到这条线 这就是 J(θ) 的样子了 我们来回顾一下 任何一个 θ1 的取值对应着一个不同的 假设函数 或者说对应着左边一条不同的拟合直线。 对于任意的θ1 你可以算出一个不同的 J(θ1) 的取值 举个例子 你知道的 θ1 等于1时对应着穿过这些数据的这条直线 当 θ1 等于0.5 也就是这个玫红色的点 也许对应着这条线 然后 θ1 等于0 也就是蓝色的这个点 对应着 这条水平的线 对吧 所以对于任意一个 θ1 的取值 我们会得到 一个不同的 J(θ1) 而且我们可以利用这些来描出右边的这条曲线 现在你还记得 学习算法的优化目标 是我们想找到一个 θ1 的值 来将 J(θ1) 最小化 对吗 这是我们线性回归的目标函数 嗯 看这条曲线 让 J(θ1) 最小化的值 是 θ1 等于1 然后你看 这个确实就对应着最佳的通过了数据点的拟合直线 这条直线就是由 θ1=1 的设定而得到的 然后 对于这个特定的训练样本 我们最后能够完美地拟合 这就是为什么最小化 J(θ1) 对应着寻找一个最佳拟合直线的目标 总结一下 在这个视频里 我们看到了一些图形 来理解代价函数 要做到这个 我们简化了算法 让这个函数只有一个参数 θ1 也就是说我们把 θ0 设定为0 在下一个视频里 我们将回到原来的问题的公式 然后看一些 带有 θ0 和 θ1 的图形 也就是说不把 θ0 设置为0了 希望这会让你更好地理解在原来的线性回归公式里 代价函数 J 的意义 Cost Function - Intuition I笔记 如果我们试图用视觉术语来思考它，我们的训练数据集就散布在x-y平面上。 我们试图做一条直线（由$h_\theta(x)$定义）来穿过这些散布的数据点。 我们的目标是获得最佳线路。 尽可能最好的线是这样的，以便线上散射点的平均垂直距离将是最小的。 理想情况下，该线应该通过我们训练数据集的所有点。 在这种情况下，$J(\theta_0,\theta_1)$值将为0.以下示例显示了代价函数为0的理想情况。 当$\theta_1=1$我们得到1的斜率时，它会经历我们模型中的每个单一数据点。 相反，当$\theta_1=0.5$我们看到从适合度到数据点的垂直距离增加时。 这使我们的代价函数增加到0.58。 绘制几个其他点产生到以下图表： 因此，作为一个目标，我们应该尽量减少代价函数。 在这种情况下，$\theta_1=1$是我们整体最低的。 Cost Function - Intuition II 这节课中 我们将更深入地学习代价函数的作用 这段视频的内容假设你已经认识轮廓图 如果你对轮廓图不太熟悉的话 这段视频中的某些内容你可能会听不懂 但不要紧 如果你跳过这段视频的话 也没什么关系 不听这节课对后续课程理解影响不大 和之前一样 这是我们的几个重要公式 包括了假设h、参数θ、代价函数J 以及优化目标 跟前一节视频不同的是 我还是把θ写成$\theta_0$,$\theta_1$的形式 便于这里我们要对代价函数进行的可视化 和上次一样 首先来理解假设h和代价函数J 这是房价数据组成的训练集数据 让我们来构建某种假设 就像这条线一样 很显然这不是一个很好的假设 但不管怎样 如果我假设θ0等于50 θ1等于0.06的话 那么我将得到这样一个假设函数 对应于这条直线 给出θ0和θ1的值 我们要在右边画出代价函数的图像 上一次 我们是只有一个θ1 也就是说 画出的代价函数是关于θ1的函数 但现在我们有两个参数 θ0和θ1 因此图像就会复杂一些了 当只有一个参数θ1的时候 我们画出来是这样一个弓形函数 而现在我们有了两个参数 那么代价函数 仍然呈现类似的某种弓形 实际上这取决于训练样本 你可能会得到这样的图形 因此这是一个三维曲面图 两个轴分别表示θ0和θ1 随着你改变θ0和θ1的大小 你便会得到不同的代价函数 J(θ0,θ1) 对于某个特定的点 (θ0,θ1) 这个曲面的高度 也就是竖直方向的高度 就表示代价函数 J(θ0,θ1) 的值 不难发现这是一个弓形曲面 我们来看看三维图 这是这个曲面的三维图 水平轴是θ0、θ1 竖直方向表示 J(θ0,θ1) 旋转一下这个图 你就更能理解这个弓形曲面所表示的代价函数了 在这段视频的后半部分 为了描述方便 我将不再像这样给你用三维曲面图的方式解释代价函数J 而还是用轮廓图来表示 .contour plot 或 contour figure 意思一样 下图就是一个轮廓图 两个轴分别表示 θ0 和 θ1 而这些一圈一圈的椭圆形 每一个圈就表示 J(θ0,θ1) 相同的所有点的集合 具体举例来说 我们选三个点出来 这三个桃红色的点 都表示相同的 J(θ0,θ1) 的值 对吧 横纵坐标分别是θ0 θ1 这三个点的 J(θ0,θ1) 值是相同的 如果你之前没怎么接触轮廓图的话 你就这么想 你就想象一个弓形的函数从屏幕里冒出来 因此最小值 也就是这个弓形的最低点就是这个点 对吧 也就是这一系列同心椭圆的中心点 想象一下这个弓形从屏幕里冒出来 所以这些椭圆形 都从我的屏幕上冒出相同的高度 弓形的最小值点是这个位置 因此轮廓图是一种很方便的方法 能够直观地观察 代价函数J 接下来让我们看几个例子 在这里有一点 这个点表示θ0等于800 θ1大概等于-0.15 那么这个红色的点 代表了某个 (θ0,θ1) 组成的数值组 而这个点也对应于左边这样一条线 对吧 θ0等于800 也就是跟纵轴相交于大约800 斜率大概是-0.15 当然 这条线并不能很好地拟合数据 对吧 以这组 θ0 θ1 为参数的这个假设 h(x) 并不是数据的较好拟合 并且你也发现了 这个代价值 就是这里的这个值 距离最小值点还很远 也就是说这个代价值还是算比较大的 因此不能很好拟合数据 让我们再来看几个例子 这是另一个假设 你不难发现 这依然不是一个好的拟合 但比刚才稍微好一点 这是我的 θ0 θ1 点 这是 θ0 的值 大约为360 θ1 的值为0 我们把它写下来 θ0=360 θ1=0 因此这组θ值对应的假设是 这条水平的直线 也就是h(x) = 360 + 0 × x 这就是假设 这个假设同样也有某个代价值 而这个代价值就对应于这个代价函数在这一点的高度 最后一个例子 这个点其实不是最小值 但已经非常靠近最小值点了 这个点对数据的拟合就很不错 它对应这样两个θ0 和 θ1 的值 同时也对应这样一个 h(x) 这个点虽然不在最小值点 但非常接近了 因此误差平方和 或者说 训练样本和假设的距离的平方和 这个距离值的平方和 非常接近于最小值 尽管它还不是最小值 好的 通过这些图形 我希望你能更好地 理解这些代价函数 J 所表达的值 它们是什么样的 它们对应的假设是什么样的 以及什么样的假设对应的点 更接近于代价函数J的最小值 当然 我们真正需要的是一种有效的算法 能够自动地找出这些使代价函数J取最小值的参数θ0和θ1来 对吧 我想我们也不希望编个程序 把这些点画出来 然后人工的方法来读出这些点的数值 这很明显不是一个好办法 事实上 我们后面就会学到 我们会遇到更复杂、更高维度、更多参数的情况 这在我们在后面的视频中很快就会遇到 而这些情况是很难画出图的 因此更无法将其可视化 因此我们真正需要的 是编写程序来找出这些最小化代价函数的θ0和θ1的值 在下一节视频中 我们将介绍一种算法 能够自动地找出能使代价函数 J 最小化的参数θ0和θ1的值 Cost Function(代价函数) - Intuition II笔记 轮廓图（或者叫等值线图）是包含许多等高线的图。两个变量函数的轮廓线在同一行的所有点上具有恒定值。这种图的一个例子就是下面的图。 采取任何颜色并沿着“圆”走，人们会期望获得相同的成本函数值。例如，上面绿线上的三个绿色点对于J（θ0，θ1）具有相同的值，因此它们沿着同一条线发现。带圆圈的x显示θ0= 800和θ1= -0.15时左侧图形的成本函数值。再取一个h（x）并绘制其轮廓图（等值线图），可以得到以下图表： 当θ0= 360且θ1= 0时，等值线图中J（θ0，θ1）的值更靠近中心，从而降低了代价函数误差。现在给我们的假设函数一个稍微正向的斜率会导致更好的数据拟合。 上面的图尽可能地降低了成本函数，因此，θ1和θ0的结果分别趋于0.12和250左右。将我们图上的这些值绘制在右侧似乎将我们的观点置于最内层“圈子”的中心。]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习入门</category>
      </categories>
      <tags>
        <tag>Cost Function</tag>
        <tag>代价函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零:机器学习介绍]]></title>
    <url>%2F2018%2F11%2F15%2F%E9%9B%B6-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[零：机器学习介绍 视频地址 定义定义1给予计算机学习能力的领域。 Samuel的定义可以回溯到50年代，他编写了一个西洋棋程序。 这程序神奇之处在于，编程者自己并不是个下棋高手。 但因为他太菜了，于是就通过编程， 让西洋棋程序自己跟自己下了上万盘棋。通过观察 哪种布局（棋盘位置）会赢，哪种布局会输， 久而久之，这西洋棋程序明白了什么是好的布局， 什么样是坏的布局。然后就牛逼大发了，程序通过学习后， 玩西洋棋的水平超过了Samuel。这绝对是令人注目的成果。 尽管编写者自己是个菜鸟，但因为 计算机有着足够的耐心，去下上万盘的棋， 没有人有这耐心去下这么多盘棋。通过这些练习， 计算机获得无比丰富的经验，于是渐渐成为了 比Samuel更厉害的西洋棋手。定义2: 由Tom Mitchell提出，来自卡内基梅隆大学.一个好的学习一个程序被认为能从经验E中学习，解决任务 T，达到 性能度量值P，当且仅当，有了经验E后，经过P评判， 程序在处理 T 时的性能有所提升 在西洋棋那例子中， 经验E :程序上万次的自我练习的经验 任务T :就是下棋。 性能度量值p:，就是它在与一些新的对手比赛时，赢得比赛的概率。 目主要的两种类型学习算法被我们称之为监督学习和无监督学习。 监督学习:我们将教计算机如何去完成任务 无监督学习:让它自己进行学习。监督学习(Supervised Learning)例子1: 假设你想预测房价， 之前，某学生已经从某地收集了数据集其中一个数据集是这样的。 这是横坐标，即不同房子的面积，单位平方脚（^-^） 纵轴上是房价，单位 千美元。 根据给定数据，假设你朋友有栋房子，750平尺（70平米） 想知道这房子能卖多少，好卖掉。 那么，学习算法怎么帮你呢？学习算法可以： 绘出一条直线，让直线尽可能匹配到所有数据。 基于此，看上去，那个房子应该、可能、也许、大概 卖到15万美元（一平米两千刀！）。 但这不是唯一的学习算法。 可能还有更好的。比如不用直线了， 可能平方函数会更好， 即二次多项式更符合数据集。如果你这样做， 预测结果就应该是20万刀（一平三千刀，涨价好快）。 后面我们会介绍到如何选择 是选择直线还是平方函数来拟合。 没有明确的选择，就不知哪个能给你的朋友 更好的卖房建议。只是这些每个都是很好的学习算法例子。 也是监督学习的例子。 术语监督学习，意指给出一个算法， 需要部分数据集已经有正确答案。比如给定房价数据集， 对于里面每个数据，算法都知道对应的正确房价， 即这房子实际卖出的价格。算法的结果就是 算出更多的正确价格，比如那个新房子， 你朋友想卖的那个。用更术语的方式来定义， 监督学习又叫回归问题(regression problem)，（应该是回归属于监督中的一种） 意指要预测一个连续值的输出，比如房价。 虽然从技术上，一般把房价记到美分单位。 所以实际还是个离散值，但通常把它看作实际数字， 是一个标量值，一个连续值的数，而术语回归， 意味着要预测这类连续值属性的种类。 例子2: 另一个监督学习的例子，我和一些朋友 之前研究的领域。让我们来看医学记录， 并预测胸部肿瘤是恶性良性。 如果某人发现有胸部肿瘤，恶性肿瘤有害又危险， 良性肿瘤则是少害。 显然人们很关注这个。让我们看一个收集好的数据集， 假设在数据集中，横轴表示肿瘤的大小， 纵轴我打算圈上0或1，是或否， 即肿瘤是恶性的还是良性的。 所以如图所示，可以看到这个大小的肿瘤块 是良性的，还有这些大小的都是良性的。 不幸地是也看到一些恶性肿瘤，比如这些大小的肿瘤。 所以，有5个良性块，在这一块， 还有5个恶性的，它们纵轴值为1. 现在假设某人杯具地得胸部肿瘤了， 大小大概是这么大。 对应的机器学习问题就是，你能否估算出一个概率， 即肿瘤为恶或为良的概率？ 专业地说，这是个分类问题(classification problem)。 分类是要预测一个离散值输出。 这里是0或1，恶性或良性。 事实证明， 在分类问题中，有时会有超过两个的值， 输出的值可能超过两种。举个具体例子， 胸部肿瘤可能有三种类型，所以要预测离散值0，1，2，3 ，假设总共有三种癌症。 0就是良性肿瘤，没有癌症。 1 表示1号癌症 2 是2号癌症， 3 就是3号癌症 这同样是个分类问题，因为它的输出的离散值集合 分别对应于无癌，1号，2号，3号癌症 我再露一小手，在分类问题中，还有另一种作图方式 来描述数据—我画你猜。要用到些许不同的符号集合来描绘数据。如果肿瘤大小作为唯一属性， 被用于预测恶性良性，可以把数据作图成这样。 使用不同的符号来表示良性和 恶性，即阴性和阳性。所以，不再统一画叉叉了， 改用圈圈来代表良性肿瘤，就像这样。 仍沿用X（叉叉）代表恶性肿瘤。希望你能明白。 我所做的就是，把在上面的数据， 映射下来。再用不同的符号， 圈和叉来分别代表良性和恶性。 在上例中，只使用了一个特征属性，即肿瘤块大小， 来预测肿瘤是恶性良性。在其它机器学习问题里， 有着不只一个的特征和属性。 例子，现在不只是知道肿瘤大小， 病人年龄和肿瘤大小都知道了。这种情况下， 数据集如表图所示，有些病人，年龄、肿瘤已知， 不同的病人，会有一点不一样， 肿瘤恶性，则用叉来代表。所以，假设 有一朋友得了肿瘤。肿瘤大小和年龄 落在此处。那么依据这个给定的数据集，学习算法 所做的就是画一条直线，分开 恶性肿瘤和良性肿瘤，所以学习算法会 画条直线，像这样，把两类肿瘤分开。 然后你就能判断你朋友的肿瘤是…了 如果它在那边，学习算法就说 你朋友的肿瘤在良性一边，因此更可能 是良性的。 好，本例中，总共有两个特征， 即病人年龄和肿瘤大小。在别的ML问题中， 经常会用到更多特征，我朋友研究这个问题时， 通常使用这些特征：比如块的厚度，即胸部肿瘤的厚度 肿瘤细胞大小和形状的一致性， 等等。它表明， 最有趣的学习算法（本课中将学到） 能够处理，无穷多个特征。不是3到5个这么少。 在这张幻灯片中，我已经列举了总共5个不同的特征。 但对于一些学习问题， 真要用到的不只是三五个特征， 要用到无数多个特征，非常多的属性， 所以，你的学习算法要使用很多的属性 或特征、线索来进行预测。 那么，你如何处理无限多特征呢？甚至你如何存储无数的东西 进电脑里，又要避免内存不足？ 事实上，等我们介绍一种叫支持向量机的算法时， 就知道存在一个简洁的数学方法，能让电脑处理无限多的特征。 想像下，我不是这边写两个特征， 右边写三个特征。而是，写一个无限长的特征表， 不停地写特征，似乎是个无限长的特征的表。 但是，我们也有能力设计一个算法来处理这个问题。 本课中，我们介绍监督学习。 其基本思想是，监督学习中，对于数据集中的每个数据， 都有相应的正确答案（训练集） ,算法就是基于这些来做出预测.就像那个房价， 或肿瘤的性质。后面介绍了回归问题。 即通过回归来预测一个连续值输出。 我们还谈到了分类问题， 目标是预测离散值输出。 下面是个小测验题目： 假设你有家公司，希望研究相应的学习算法去 解决两个问题。第一个问题，你有一堆货物的清单。 假设一些货物有几千件可卖， 你想预测出，你能在未来三个月卖出多少货物。 第二个问题，你有很多用户， 你打算写程序来检查每个用户的帐目。 对每个用户的帐目， 判断这个帐目是否被黑过（hacked or compromised）。 请问，这两个问题是分类问题，还是回归问题？ 问题一是个回归问题 因为如果我有几千件货物， 可能只好把它当作一个实际的值，一个连续的值。 也把卖出的数量当作连续值。 第二个问题，则是分类问题，因为可以把 我想预测的一个值设为0，来表示账目没有被hacked 另一个设为1，表示已经被hacked。 就像乳癌例子中，0表示良性，1表示恶性。 所以这个值为0或1，取决于是否被hacked， 有算法能预测出是这两个离散值中的哪个。 因为只有少量的离散值，所以这个就是个分类问题。 笔记 在监督式学习中，我们给了一个数据集，并且已经知道我们的正确输出应该是什么样子，并且有输入和输出之间有关系的想法。 监督学习问题分为“回归”和“分类”问题。 在回归问题中，我们试图预测连续输出中的结果，这意味着我们试图将输入变量映射到某个连续函数。 在分类问题中，我们试图预测离散输出的结果。换句话说，我们试图将输入变量映射到离散类别 例子 回归 - 给定一个人的照片，我们必须根据给定的图片来预测他们的年龄 分类 - 给予患有肿瘤的患者，我们必须预测肿瘤是恶性的还是良性的。 无监督学习(Unsupervised Learning) 在上一节视频中 我们已经讲过了监督学习 回想起上次的数据集 每个样本 都已经被标明为 正样本或者负样本 即良性或恶性肿瘤 因此 对于监督学习中的每一个样本 我们已经被清楚地告知了 什么是所谓的正确答案 即它们是良性还是恶性 在无监督学习中 我们用的数据会和监督学习里的看起来有些不一样 在无监督学习中 没有属性或标签这一概念 也就是说所有的数据都是一样的,没有区别 所以在无监督学习中 我们只有一个数据集 没人告诉我们该怎么做 我们也不知道每个数据点究竟是什么意思,相反 它只告诉我们:现在有一个数据集 你能在其中找到某种结构吗? 对于给定的数据集,无监督学习算法可能判定,该数据集包含两个不同的聚类,这是第一个聚类,然后这是另一个聚类 .无监督学习算法 会把这些数据分成两个不同的聚类,所以这就是所谓的聚类算法 例子1 我们来举一个聚类算法的例子 Google 新闻的例子 如果你还没见过这个页面的话 你可以到这个URL:news.google.com 去看看谷歌新闻每天都在干什么呢？ 他们每天会去收集成千上万的网络上的新闻然后将他们分组组成一个个新闻专题 比如 让我们来看看这里,这里的URL链接连接着不同的有关BP油井事故的报道,所以 让我们点击 这些URL中的一个 恩 让我们点一个 然后我们会来到这样一个网页 这是一篇来自华尔街日报的 有关……你懂的 有关BP油井泄漏事故的报道 标题为《BP杀死了Macondo》 Macondo 是个地名 就是那个漏油事故的地方 如果你从这个组里点击一个不同的URL 那么你可能会得到不同的新闻 这里是一则CNN的新闻 是一个有关BP石油泄漏的视频 如果你再点击第三个链接 又会出现不同的新闻 这边是英国卫报的报道 也是关于BP石油泄漏 所以 谷歌新闻所做的就是 去搜索成千上万条新闻 然后自动的将他们聚合在一起 因此 有关同一主题的 新闻被显示在一起 实际上 聚类算法和无监督学习算法 也可以被用于许多其他的问题 例子2 这里我们举个它在基因组学中的应用 下面是一个关于基因芯片的例子 基本的思想是 给定一组不同的个体,对于每个个体,检测它们是否拥有某个特定的基因 也就是说，你要去分析有多少基因显现出来了 因此 这些颜色 红 绿 灰 等等 它们 展示了这些不同的个体 是否拥有一个特定基因 的不同程度 然后你能做的就是 运行一个聚类算法 把不同的个体归入不同的类 或归为不同类型的人 这就是无监督学习 我们没有提前告知这个算法 这些是第一类的人 这些是第二类的人 这些是第三类的人等等 相反我们只是告诉算法 你看 这儿有一堆数据 我不知道这个数据是什么东东 我不知道里面都有些什么类型 叫什么名字 我甚至不知道都有哪些类型 但是 请问你可以自动的找到这些数据中的类型吗？ 然后自动的 按得到的类型把这些个体分类 虽然事先我并不知道哪些类型 因为对于这些数据样本来说 我们没有给算法一个正确答案,所以这就是无监督学习 其他例子 无监督学习或聚类算法在其他领域也有着大量的应用 它被用来组织大型的计算机集群 我有一些朋友在管理 大型数据中心 也就是 大型计算机集群 并试图 找出哪些机器趋向于 协同工作 如果你把这些机器放在一起 你就可以让你的数据中心更高效地工作 用于社交网络的分析 所以 如果可以得知 哪些朋友你用email联系的最多 或者知道你的Facebook好友 或者你Google+里的朋友 知道了这些之后 我们是否可以自动识别 哪些是很要好的朋友组 哪些仅仅是互相认识的朋友组 还有在市场分割中的应用 许多公司拥有庞大的客户信息数据库,那么,给你一个客户数据集,你能否自动找出不同的市场分割,并自动将你的客户分到不同的细分市场中.从而有助于我在不同的细分市场中进行更有效的销售 这也是无监督学习 我们现在有 这些客户数据 但我们预先并不知道 有哪些细分市场 而且 对于我们数据集的某个客户 我们也不能预先知道 谁属于细分市场一 谁又属于细分市场二等等 但我们必须让这个算法自己去从数据中发现这一切 天文数据分析 通过这些聚类算法 我们发现了许多 惊人的、有趣的 以及实用的 关于星系是如何诞生的理论 所有这些都是聚类算法的例子 而聚类只是无监督学习的一种 鸡尾酒宴问题 恩 我想你参加过鸡尾酒会的 是吧？ 嗯 想象一下 有一个宴会 有一屋子的人 大家都坐在一起 而且在同时说话 有许多声音混杂在一起 因为每个人都是在同一时间说话的 在这种情况下你很难听清楚你面前的人说的话 因此 比如有这样一个场景 宴会上只有两个人 两个人 同时说话 恩 这是个很小的鸡尾酒宴会 我们准备好了两个麦克风 把它们放在房间里 然后 因为这两个麦克风距离这两个人 的距离是不同的 每个麦克风都记录下了 来自两个人的声音的不同组合 也许A的声音 在第一个麦克风里的声音会响一点 也许B的声音 在第二个麦克风里会比较响一些 因为2个麦克风 的位置相对于 2个说话者的位置是不同的 但每个麦克风都会录到 来自两个说话者的重叠部分的声音 一个研究员录下的两个说话者的声音,无监督学习算法可以将两种混合在一起的音频分开 所以,你可以看到,像这样的无监督学习算法,看起来 为了 构建这个应用程序 做这个音频处理 似乎需要写好多代码啊 或者需要链接到 一堆处理音频的Java库 貌似需要一个非常复杂的程序,分离出音频等 实际上,要实现混合音频分离的效果,只需要一行代码就可以了 当然 研究人员 花了很长时间才想出这行代码的,我不是说这是一个简单的问题 但事实上 如果你 使用正确的编程环境 许多学习 算法是用很短的代码写出来的 所以这也是为什么在 这门课中我们要 使用Octave的编程环境 Octave是一个免费的 开放源码的软件 使用Octave或Matlab这类的工具 许多学习算法 都可以用几行代码就可以实现 在后续课程中 我会教你如何使用Octave 你会学到 如何在Octave中实现这些算法 或者 如果你有Matlab 你可以用它 事实上 在硅谷 很多的机器学习算法 我们都是先用Octave 写一个程序原型 因为在Octave中实现这些 学习算法的速度快得让你无法想象 在这里 每一个函数 例如 SVD 意思是奇异值分解 但这其实是解线性方程 的一个惯例 它被内置在Octave软件中了 如果你试图 在C + +或Java中做这个 将需要写N多代码 并且还要连接复杂的C + +或Java库 所以 你可以在C++或 Java或Python中 实现这个算法 只是会 更加复杂而已 如果你使用Octave的话 会学的更快 并且如果你用 Octave作为你的学习工具 和开发原型的工具 你的学习和开发过程 会变得更快 而事实上在硅谷 很多人会这样做 他们会先用Octave 来实现这样一个学习算法原型 只有在确定 这个算法可以工作后 才开始迁移到 C++ Java或其它编译环境 事实证明 这样做 实现的算法 比你一开始就用C++ 实现的算法要快多了 我们谈到了无监督学习 它是一种学习机制 你给算法大量的数据 要求它找出数据中 蕴含的类型结构 以下的四个例子中 哪一个 您认为是 无监督学习算法 而不是监督学习问题 * 恩 没忘记垃圾邮件文件夹问题吧？ 如果你已经标记过数据 那么就有垃圾邮件和 非垃圾邮件的区别 我们会将此视为一个监督学习问题 * 新闻故事的例子 正是我们在本课中讲到的 谷歌新闻的例子 我们介绍了你可以如何使用 聚类算法这些文章聚合在一起 所以这是无监督学习问题 * 市场细分的例子 我之前有说过 这也是一个无监督学习问题 因为我是要 拿到数据 然后要求 它自动发现细分市场 * 最后一个例子 糖尿病 这实际上就像我们 上节课讲到的乳腺癌的例子 只不过这里不是 好的或坏的癌细胞 良性或恶性肿瘤我们 现在是有糖尿病或 没有糖尿病 所以这是 有监督的学习问题 像处理那个乳腺癌的问题一样 我们会把它作为一个 有监督的学习问题来处理 笔记 无监督的学习使我们能够很少或根本不知道我们的结果应该是什么样子。 我们可以从数据中推导出结构，我们不一定知道变量的影响。 我们可以通过基于数据中变量之间的关系对数据进行聚类来推导出这种结构。 在无监督学习的基础上，没有基于预测结果的反馈。 例： 聚类(Clustering)：搜集一百万个不同的基因，并找到一种方法，将这些基因自动分组，这些基因组通过不同的变量（例如寿命，位置，角色等）相似或相关。 非聚类(Non-clustering)：“鸡尾酒会算法”，可以让你在混乱的环境中找到结构。 （即在鸡尾酒会上从声音网格中识别个别的声音和音乐）。]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习入门</category>
      </categories>
      <tags>
        <tag>机器学习简介</tag>
      </tags>
  </entry>
</search>
