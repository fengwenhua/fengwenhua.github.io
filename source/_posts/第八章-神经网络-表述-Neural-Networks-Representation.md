---
title: 第八章-神经网络-表述(Neural-Networks-Representation)
date: 2019-02-12 21:59:18
mathjax: true
tags:
- 神经网络表述
- Neural-Networks-Representation
categories:
- 机器学习
- 机器学习入门
---

# 第八章 神经网络：表述(Neural Networks: Representation)

-----------------------------------------------------

## 8.1 非线性假设（Non-linear Hypotheses）


在这节课和接下来的课程中 我将给大家介绍 一种叫`“神经网络”(Neural Network)` 的机器学习算法

我们将首先讨论 神经网络的**表层结构** 在后续课程中 再来具体讨论的学习算法 神经网络实际上是一个 相对古老的算法 并且后来沉寂了一段时间 不过到了现在 它又成为许多机器学习问题 的首选技术

不过我们为什么还需要这个学习算法？ 我们已经有线性回归和逻辑回归算法了 为什么还要研究神经网络？

为了阐述研究**神经网络算法的目的** 我们首先来看几个机器学习问题作为例子 这几个问题的解决 都依赖于研究复杂的`非线性分类器`

考虑这个监督学习分类的问题 我们已经有了对应的训练集 如果利用`逻辑回归算法` 来解决这个问题 首先需要构造 一个包含很多**非线性项**的逻辑回归函数 这里g仍是`s型函数 (即f(x)=1/(1+e^-x) )` 我们能让函数 包含很多像这样的多项式项 事实上 当多项式项数足够多时 那么可能 你能够得到一个 分开正样本和负样本的分界线
<!--more-->
![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234006.png)


当只有两项时 比如 x1 x2 这种方法确实能得到不错的结果 因为你可以 把x1和x2的所有组合 都包含到多项式中 但是对于许多 复杂的机器学习问题 涉及的项往往多于两项

我们之前已经讨论过 **房价预测的问题** 假设现在要处理的是 关于**住房的分类问题** 而不是一个回归问题 假设你对一栋房子的多方面特点 都有所了解 你想预测 房子在未来半年内 能被卖出去的概率 这是一个**分类问题**

我们可以想出 很多特征 对于不同的房子有可能 就有上百个特征

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234257.png)

对于这类问题 如果要包含 所有的二次项 即使只包含 二项式或多项式的计算 最终的多项式也可能有很多项

比如x1^2 x1x2 x1x3 x1x 直到x1x100 还有x2^2 x2x3 等等很多项 因此 即使只考虑二阶项 也就是说 **两个项的乘积** x1乘以x1 等等类似于此的项 那么 在n=100的情况下 最终也有5000个二次项

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234500.png)

而且渐渐地 随着特征个数n的增加 二次项的个数大约以`n^2`的量级增长 其中 n是原始项的个数 即我们之前说过的x1到x100这些项 事实上二次项的个数大约是(n^2)/2

因此要包含所有的 二次项是很困难的 所以这可能 不是一个好的做法 而且由于项数过多 最后的结果很有可能是**过拟合**的 此外 在处理这么多项时 也存在运算量过大的问题

当然 你也可以试试 只包含上边**这些二次项的子集** 例如 我们只考虑 x1^2 x2^2 x3^2直到 x100^2 这些项 这样就可以将二次项的数量大幅度减少 减少到只有100个二次项 但是由于 忽略了太多相关项 在处理类似左上角的数据时 不可能得到理想的结果 实际上 如果只考虑x1的平方 到x100的平方 这一百个二次项 那么你可能会 拟合出一些特别的假设 比如可能拟合出 一个**椭圆状的曲线** 但是肯定不能拟合出 像左上角这个数据集的分界线

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234746.png)

所以5000个二次项看起来已经很多了 而现在假设 包括三次项 或者三阶项 例如x1 x2 x3 x1^2 x2 x10 x11 x17等等 类似的三次项有很多很多 事实上 三次项的个数是以n^3的量级增加 当n=100时 可以计算出来 最后能得到 大概17000个三次项 所以 当初始特征个数n增大时 这些高阶多项式项数 将以几何级数递增 特征空间也随之急剧膨胀 当特征个数n很大时 如果找出附加项 来建立一些分类器 这并不是一个好做法

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110234949.png)

对于**许多实际的机器学习问题 特征个数n是很大的** 举个例子 关于计算机视觉中的一个问题 假设你想要 使用机器学习算法 来训练一个分类器 使它检测一个图像 来**判断图像是否为一辆汽车**

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110235108.png)

很多人可能会好奇 这对计算机视觉来说有什么难的 当我们自己看这幅图像时 里面有什么是一目了然的事情 你肯定会很奇怪 为什么学习算法竟可能会不知道 图像是什么

为了解答这个疑问 我们取出这幅图片中的一小部分 将其放大 比如图中 这个红色方框内的部分 结果表明 当人眼看到一辆汽车时 计算机实际上看到的却是这个 一个数`据矩阵` 或像这种格网 它们表示了`像素强度值` 告诉我们 **图像中每个像素的亮度值** 因此 对于计算机视觉来说问题就变成了 **根据这个像素点亮度矩阵 来告诉我们 这些数值代表一个汽车门把手**

具体而言 当用机器学习算法构造 一个`汽车识别器时` 我们要想出 一个带标签的样本集 其中一些样本 是各类汽车 另一部分样本 是其他任何东西 将这个样本集输入给学习算法 以训练出一个`分类器` 训练完毕后 我们输入一幅新的图片 让分类器判定 “这是什么东西？”

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110235348.png)

理想情况下 分类器能识别出这是一辆汽车

为了理解引入 **非线性分类器的必要性** 我们从学习算法的`训练样本`中 挑出一些汽车图片 和一些非汽车图片

让我们从其中 每幅图片中挑出一组像素点 这是像素点1的位置 这是像素点2的位置 在坐标系中标出这幅汽车的位置 **在某一点上 车的位置取决于 像素点1和像素点2的亮度**

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110235648.png)

让我们用同样的方法标出其他图片中汽车的位置 然后我们再举一个 关于汽车的不同的例子 观察这**两个相同的像素位置** 这幅图片中 像素1有一个像素强度 像素2也有一个不同的像素强度 所以在这幅图中它们两个处于不同的位置

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181110235814.png)

我们继续画上两个非汽车样本 这个不是汽车 这个也不是汽车 然后我们继续 在坐标系中画上更多的新样本

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111000301.png)

用''+"表示汽车图片 用“-”表示非汽车图片 我们将发现 汽车样本和非汽车样本 分布在坐标系中的不同区域 因此 我们现在需要一个 非线性分类器 来尽量分开这两类样本

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111000343.png)

这个分类问题中**特征空间的维数**是多少？ 假设我们用50*50像素的图片 我们的图片已经很小了 长宽只各有50个像素 但这依然是2500个像素点 因此 我们的特征向量的元素数量 N=2500 特征向量X 包含了所有像素点的亮度值 这是像素点1的亮度 这是像素点2的亮度 如此类推 直到最后一个 像素点的亮度

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111000517.png)

对于典型的计算机图片表示方法 如果存储的是每个像素点的`灰度值 (色彩的强烈程度)` 那么**每个元素的值 应该在0到255之间** 因此 这个问题中n=2500 但是 这只是使用灰度图片的情况 如果我们用的是`RGB彩色图像` 每个像素点包含`红、绿、蓝`三个子像素 那么n=7500

因此 如果我们非要 通过包含所有的二次项 来解决这个非线性问题 那么 这就是式子中的所有条件 `xi x xj`(笛卡尔积) 连同开始的2500像素 总共大约有300万个（(2500^2)/2） 这数字大得有点离谱了 对于每个样本来说 要发现并表示 所有这300万个项 这计算成本太高了

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111000710.png)

因此 只是简单的增加 二次项或者三次项 之类的逻辑回归算法 并不是一个解决`复杂非线性问题`的好办法 因为当n很大时 将会产生非常多的`特征项` 在接下来的视频课程中 我将为大家讲解神经网络 它在解决复杂的非线性分类问题上 被证明是 是一种好得多的算法 即使你输入特征空间 或输入的特征维数n很大也能轻松搞定


## 8.2 神经元和大脑

`神经网络`是一种很古老的算法 它最初产生的目的是 制造能模拟大脑的机器 在这门课中 我将向你们介绍神经网络 因为它能很好地解决 不同的机器学习问题 而不只因为它们在逻辑上行得通

在本节课中 告诉你们一些神经网络的背景知识 由此我们能知道可以用它们来做什么 不管是将其应用到现代的机器学习问题上 还是应用到那些你可能会感兴趣的问题中 也许这一伟大的人工智能梦想在未来能制造出真正的智能机器

另外 我们还将讲解神经网络是怎么涉及这些问题的

**神经网络产生的原因** 是人们想尝试设计出 模仿大脑的算法 从某种意义上说如果我们 想要建立学习系统 那为什么不去模仿 我们所认识的最神奇的学习机器——-人类的大脑呢 神经网络逐渐兴起于 二十世纪八九十年代 应用得非常广泛 但由于各种原因 在90年代的后期应用减少了 但是最近 神经网络 又东山再起了

其中一个原因是 **神经网络是计算量有些偏大的算法** 然而 大概由于近些年 **计算机的运行速度变快才足以真正运行起大规模的神经网络** 正是由于这个原因 和其他一些我们后面会讨论到的 技术因素 如今的神经网络 对于许多应用来说是最先进的技术

当你想模拟大脑时 是指想制造出与人类大脑 作用效果相同的机器 对吧？ 大脑可以学会去 以看而不是听的方式处理图像 学会处理我们的触觉 我们能学习数学  学着做微积分 而且大脑能处理 各种不同的令人惊奇的事情 似乎如果你想要 模仿它 你得写很多不同的 软件来模拟所有 大脑告诉我们的这些 五花八门的奇妙的事情 不过能不能假设 大脑做所有这些 不同事情的方法 不需要用上千个不同的程序去实现 相反的 大脑处理的方法 只需要 一个单一的学习算法就可以了？ 尽管这只是一个假设 不过让我和你分享 一些这方面的证据

大脑的这一部分 这一小片红色区域 是你的听觉皮层 你现在正在理解我的话 这靠的是耳朵 耳朵接收到声音信号 并把声音信号传递给你的 听觉皮层 正因如此 你才能明白我的话

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111001739.png)

神经系统科学家做了 下面这个有趣的实验 把 **耳朵到听觉皮层的神经切断** 在这种情况下 将其重新接到一个动物的大脑上 这样从眼睛到 视神经的信号最终将传到听觉皮层

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111001936.png)

如果这样做了 那么结果表明 听觉皮层将会 学会“看” 这里“看”代表了 我们所知道的每层含义 所以 如果你对动物这样做 那么动物就可以完成视觉辨别任务 它们可以看图像 并根据图像做出适当的决定 它们正是通过 脑组织中的这个部分完成的

来看另一个例子

这块红色的脑组织是你的`躯体感觉皮层` 这是你用来**处理触觉**的 如果你做一个和刚才类似的重接实验 那么躯体感觉皮层也能学会”看“ 这个实验和其它一些 类似的实验 被称为`神经重接实验`

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111002127.png)

从这个意义上说 如果 人体有同一块 脑组织可以处理光、 声或触觉信号 那么也许存在一种学习算法 可以同时处理 视觉、听觉和触觉 而不是需要 运行上千个不同的程序 或者上千个不同的算法来做这些 大脑所完成的 成千上万的美好事情 也许我们需要做的就是找出 一些近似的或 实际的大脑学习算法 然后实现它 大脑通过自学掌握如何 处理这些不同类型的数据

在很大的程度上 可以猜想如果我们 把几乎任何一种传感器 接入到大脑的 几乎任何一个部位的话 大脑就会学会处理它

下面再举几个例子 左上角的这张图是 用舌头学会“看”的一个例子 它的原理是 这实际上是 一个名为BrainPort的系统 它现在正在FDA (美国食品和药物管理局) 的临床试验阶段 它能帮助失明人士看见事物 它的原理是 你在前额上带一个灰度摄像头 面朝前 它就能 获取你面前事物的 低分辨率的灰度图像 你连一根线 到舌头上安装的 电极阵列上 那么每个像素都被映射到 你舌头的 某个位置上 可能电压值高的点对应一个 暗像素 电压值低的点 对应于亮像素 即使依靠 它现在的功能 使用这种系统就能让你我 在几十分钟里就学会 用我们的舌头“看”东西

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111002341.png)

这是第二个例子 关于人体回声定位或者说人体声纳 你有两种方法可以实现 你可以弹响指 或者咂舌头 这个我做不好 不过现在有失明人士 确实在学校里 接受这样的培训 并学会解读 从环境反弹回来的声波模式—这就是`声纳` 如果你搜索 YouTube之后 就会发现 有些视频讲述了一个令人称奇的孩子 他因为癌症眼球惨遭移除 虽然失去了眼球 但是通过打响指 他可以四处走动而不撞到任何东西 他能滑滑板 他可以将篮球投入篮框中 注意这是一个没有眼球的孩子

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111002434.png)

第三个例子是 触觉皮带 如果你把它 戴在腰上 蜂鸣器会响 而且总是朝向北时发出嗡嗡声 它可以使人拥有 方向感 用类似于 鸟类感知方向的方式 还有一些离奇的例子 如果你在青蛙身上 插入第三只眼 青蛙也能学会使用那只眼睛

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111002728.png)


因此 这将会非常令人惊奇 如果你能 把几乎任何传感器 接入到大脑中 大脑的学习算法就能 找出学习数据的方法 并处理这些数据

从某种意义上来说 如果我们能找出 大脑的学习算法 然后在计算机上执行 大脑学习算法或与之相似的算法 也许 这将是我们 向人工智能迈进 做出的最好的尝试 人工智能的梦想就是 有一天能制造出真正的智能机器

当然我不是 教神经网络的 介绍它只因为它可能为我们 打开一扇进入遥远的 人工智能梦的窗户 对于我个人来说 它也是我研究生涯中致力于的一个项目 但我在这节课中 讲授神经网络的原因 主要是对于 现代机器学习应用 它是最有效的技术方法 因此在接下来的 一些课程中 我们将开始深入到 神经网络的技术细节 那么你就可以 将它们应用到现代 机器学习的应用中 并利用它们很好地解决问题 但对我来说 使我兴奋的原因之一 就是它或许能 给我们一些启示 让我们知道 当我们在思考 未来有什么样的算法 能以与人类相似的方式学习时 我们能做些什么


## 8.3 模型表示1


在这个视频中 我想 开始向你介绍 我们该如何表示神经网络 换句话说 当我们在 **运用神经网络时 我们该如何表示我们的假设或模型** 神经网络是在模仿 大脑中的`神经元`或者`神经网络`时发明的 因此 要解释如何表示 模型假设 我们先来看**单个神经元在大脑中是什么样的**

我们的大脑中充满了 这样的神经元 `神经元`是大脑中的细胞 其中有两点 值得我们注意 一是神经元有 像这样的`细胞主体`

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111003137.png)

二是神经元有 一定数量的 输入神经 这些**输入神经**叫做`树突` 可以把它们想象成输入电线 它们**接收来自其他神经元的信息**

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111003418.png)

神经元的**输出神经**叫做`轴突` 这些输出神经 是用来 **给其他神经元传递信号 或者传送信息的**

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111003515.png)

简而言之 **`神经元`是一个计算单元 它从输入神经接受一定数目的信息 并做一些计算 然后将结果通过它的 轴突传送到其他节点 或者大脑中的其他神经元**

下面是一组神经元的示意图 神经元利用微弱的电流 进行沟通 这些弱电流也称作`动作电位` 其实就是一些微弱的电流

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111004603.png)

所以如果 **神经元想要传递一个消息** 它就会就通过它的`轴突` 发送一段微弱电流 给其他神经元 这就是`轴突` 这里是一条 连接到`输入神经` 或者连接`另一个神经元树突的神经` 接下来这个神经元接收这条消息 做一些计算 它有可能会反过来将 在轴突上的 自己的消息传给其他神经元

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111004853.png)

这就是所有 人类思考的模型： **我们的神经元把自己的收到的消息进行计算,并向其他神经元 传递消息**

顺便说一下 这也是 我们的感觉和肌肉运转的原理 如果你想活动一块肌肉 就会触发一个神经元 给你的肌肉 发送`脉冲` 并引起 你的肌肉收缩 如果一些感官 比如说眼睛 想要给大脑传递 一个消息 那么它就像这样发送 电脉冲给大脑的

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111005109.png)

在一个神经网络里 或者说在我们在电脑上 实现的人工神经网络里 我们将使用 一个非常简单的模型 来模拟神经元的工作 我们**将神经元模拟成一个逻辑单元** 当我画一个这样的 黄色圆圈时 你应该 把它想象成 作用类似于 神经元的东西 然后我们通过 它的树突或者说它的输入神经 传递给它一些信息 然后神经元做一些计算 并通过它的输出神经 即它的轴突 输出计算结果

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111005426.png)

当我画一个像这样的图表时 就表示对h(x)的计算 **h(x)等于1除以1加e的负θ转置乘以x** 通常 x和θ 是我们的参数向量 这是一个简单的模型 甚至说是一个过于简单的 模拟神经元的模型 它被输入 x1 x2和 x3 然后输出一些 类似这样的结果

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111005728.png)

当我绘制一个神经网络时 通常我只绘制 输入节点 x1 x2 x3 但有时也可以这样做： 我增加一个额外的节点 x0 这个 x0 节点 有时也被称作`偏置单位` 或`偏置神经元` 但因为 x0 总是等于1 所以有时候 我会画出它 有时我不会画出 这取决于它是否对例子有利

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111005901.png)

现在来讨论 最后一个关于 神经网络的术语 有时我们会说 这是一个神经元 **一个有s型函数或者`逻辑函数`作为激励函数的 `人工神经元`** 在神经网络术语中 `激励函数`**只是对类似非线性函数g(z)的另一个术语称呼** g(z)等于 **1除以1加e的-z次方**

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010225.png)

到目前为止 我一直称`θ`为`模型的参数` 以后大概会继续将这个术语与 “参数”相对应 而不是与在关于神经网络的文献里 有时你可能会看到人们 谈论一个模型的`权重` **权重其实和模型的参数 是一样的东西** 在视频中 我会继续使用“参数”这个术语 但有时你可能听到别人用“权重”这个术语

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010347.png)

以上的黄色小圈，代表**一个单一的神经元**

`神经网络`其实就是下图这些不同的神经元组合在一起的**集合**

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010504.png)

具体来说 这里是我们的 输入单元 x1 x2和 x3 再说一次 有时也可以画上 额外的节点 x0 我把 x0 画在这了 里有 3个神经元 我在里面写了a(2)1 a(2)2 和a(2)3 然后再次说明 我们可以在这里 添加一个a0 和一个额外的`偏度单元` **它的值永远是1** 最后 我们在 最后一层有第三个节点 正是这第三个节点 输出 **假设函数h(x)计算的结果**

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010613.png)

再多说一点关于 神经网络的术语 网络中的第一层 也被称为`输入层` 因为我们在这一层 输入我们的特征项 x1 x2 x3 最后一层 也称为`输出层` 因为这一层的 神经元—我指的这个 输出 假设的最终计算结果 中间的两层 也被称作`隐藏层` 隐藏层不是一个 很合适的术语 但是 直觉上我们知道 在监督学习中 你能看到输入 也能看到正确的输出 而隐藏层的值 你在训练集里是看不到的 它的值不是 x 也不是y 所以我们叫它`隐藏层`

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111010832.png)

稍后我们会看到神经网络 可以有不止一个的 隐藏层 但在 这个例子中 我们有一个 输入层—第1层 一个隐藏层— 第2层 和一个输出层—第3层 但实际上任何 **非输入层或非输出层的层**就被称为`隐藏层`

接下来 我希望你们明白神经网络 究竟在做什么 让我们逐步分析 这个图表所呈现的 计算步骤

为了解释这个神经网络 具体的计算步骤 这里还有些记号要解释 我要使用`a上标(j)下标i`表示 **第j层的第i个神经元或单元** 具体来说 这里 a上标(2) 下标1 表示第2层的 第一个激励 即隐藏层的第一个激励 所谓`激励(activation)` 是指 **由一个具体神经元读入计算并输出的值**

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011256.png)

此外 我们的神经网络 被这些矩阵参数化 `θ上标(j)` 它将成为 一个`波矩阵` 控制着 比如说 从第一层到第二层 或者 第二层到第三层的作用

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011414.png)

所以 这就是这张图所表示的计算

这里的第一个隐藏单元 是这样计算它的值的： a(2)1等于 s函数（或者说s激励函数，也叫做逻辑激励函数） 作用在这种 输入的线性组合上的结果

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011643.png)

第二个隐藏单元 等于s函数作用在这个 线性组合上的值 同样 对于第三个 隐藏的单元 它是通过这个公式计算的

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011746.png)

在这里 我们有三个 输入单元和三个隐藏单元

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111011904.png)

这样一来 参数矩阵控制了 我们来自 三个输入单元 三个隐藏单元的映射 因此θ1的维数 将变成3 θ1将变成一个 3乘4维的 矩阵 **因为x0是偏度单元，它的值永远是1,所以变成3X4,不要a(2)0是因为它在计算下一层的时候用到,这一层不需要计算它**

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111012412.png)

更一般的 如果一个网络在第j 层有sj个单元 在j+1层有 sj+1个单元 那么矩阵θ(j) 即控制第j层到 第j+1层映射 的矩阵的 维度为s(j+1) * (sj+1) 这里要搞清楚 这个是s下标j+1 而这个是 s下标j 然后 整体加上1 整体加1 明白了吗 所以θ(j)的维度是 s(j+1)行 sj+1列 这里sj+1 当中的1 不是下标的一部分

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111233445.png)

以上我们讨论了 三个隐藏单位是怎么计算它们的值

最后 在输出层 我们还有一个 单元 它计算 `h(x)` 这个也可以 写成a(3)1 就等于后面这块

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111234313.png)

注意到我这里 写了个上标2 因为θ上标2 是`参数矩阵`，或着说是`权重矩阵`。该矩阵**控制从第二层（即隐藏层的3个单位） 到第三层的一个单元 （即输出单元） 的`映射`**

总之 以上我们 展示了像这样一张图是 怎样定义 一个人工神经网络的 这个神经网络定义了函数h： 从输入 x 到输出y的映射 我将这些假设的参数 记为大写的θ 这样一来 不同的θ 对应了不同的假设 所以我们有不同的函数 比如说从 x到y的映射 以上就是我们怎么 从数学上定义 神经网络的假设

在接下来的视频中 我想要做的就是 让你对这些假设的作用 有更深入的理解 并且讲解几个例子 然后谈谈如何有效的计算它们 【教育无边界字幕组】翻译人员不详

## 8.4 模型表示2

在前面的视频里 我们 解释了怎样用数学来 定义或者计算 神经网络算法的假设

在这段视频中 我想 告诉你如何 高效地进行计算 并展示一个`向量化`的实现方法

更重要的是 我想 让你们明白为什么 这样表示神经网络 是一个好的方法 并且明白 它们怎样帮助我们学习复杂的`非线性假设`

以这个神经网络为例 以前我们说 计算出假设输出 的步骤 是左边的这些 方程 通过这些方程 我们计算出 三个隐藏单元的`激励值` 然后利用 这些值来计算 假`设h(x)`的最终输出

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111234714.png)

接下来 我要 定义一些额外的项 因此 这里 我画线的项 把它定义为` z上标(2) 下标1` 这样一来 就有了 `a(2)1` 这个项 等于 `g(z(2)1)` 另外顺便提一下 这些上标2 的意思是 在z(2)和a(2)中 括号中的 2表示这些值 与第二层相关 即与神经网络中的 隐藏层有关

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111235101.png)

接下来 这里的项 我将同样定义为 z(2)2 最后这个 我画线的项 我把它定义为z(2)3 这样 我们有a(2)3 等于 g(z(2)3) 所以这些z值都是 一个线性组合 是输入值x0 x1 x2 x3的 加权线性组合 它将会进入一个特定的神经元

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111235232.png)

现在 看一下 这一堆数字 你可能会注意到这块 对应了 矩阵向量运算 类似于矩阵向量乘法 x1乘以向量x 观察到一点 我们就能将 **神经网络的计算向量化**了

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111235401.png)

具体而言 我们定义 特征向量x 为x0 x1 x2 x3组成的向量 其中x0 仍然等于1 并定义 z(2)为 这些z值组成的向量 即z(2)1 z(2)2 z(2)3 注意 在这里 z(2) 是一个三维向量

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181111235654.png)


下面 我们可以这样 向量化a(2)1 a(2)2 a(2)3的计算 我们只用两个步骤 z(2)等于θ(1) 乘以x 这样就有了向量z(2) 然后 a(2)等于 g(z(2)) 需要明白 这里的z(2)是 三维向量 并且 a(2)也是一个三维 向量 因此这 里的激励g 将s函数 逐元素作用于 z(2)中的每个元素

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112000135.png)

顺便说一下 为了让我们 的符号和接下来的 工作相一致 在输入层 虽然我们有 输入x 但我们 还可以把这些想成 是第一层的激励 所以 我可以定义a(1) 等于x 因此 a(1)就是一个向量了 我就可以把这里的x 替换成a(1) z(2)就等于θ(1)乘以a(1) 这都是通过在输入层定义a(1)做到的

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112000309.png)

现在 就我目前所写的 我得到了 a1 a2 a3的值 并且 我应该把 上标加上去 但我还需要一个值 我同样需要这个a(2)0 它对应于 隐藏层的 得到这个输出的`偏置单元` 当然 这里也有一个 偏置单元 我只是没有 画出来

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112000748.png)

注意这额外的偏置单元 接下来我们 要额外加上一个**a0 上标(2) 它等于1** 这样一来 现在 a(2)就是一个 四维的特征向量 因为我们刚添加了 这个额外的 a0 它等于 1并且它是隐藏层的 一个偏置单元

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112000930.png)

最后 为了计算假设的 实际输出值 我们 只需要计算 z(3) z(3)等于 这里我画线的项 这个方框里的项就是z(3)

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112001106.png)

z(3)等于θ(2) 乘以a(2) 最后 假设输出为h(x) 它等于a(3) a(3)是输出层 唯一的单元 它是一个实数 你可以写成a(3) 或a(3)1 这就是g(z(3)) 这个计算h(x)的过程 也称为`前向传播(forward propagation)`

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112001235.png)

这样命名是因为 我们从 输入层的激励开始 然后进行前向传播给 隐藏层并计算 隐藏层的激励 然后 我们继续前向传播 并计算输出层的激励

这个从输入层到 隐藏层再到输出层依次计算激励的 过程叫`前向传播`

我们刚刚得到了 这一过程的向量化 实现方法 如果你 使用右边这些公式实现它 就会得到 一个有效的 计算h(x) 的方法

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112001704.png)

这种前向传播的角度 也可以帮助我们了解 神经网络的原理 和它为什么能够 帮助我们学习`非线性假设`

看一下这个神经网络 我会暂时盖住 图片的左边部分 如果你观察图中剩下的部分 这看起来很像 逻辑回归 在逻辑回归中 我们用 这个节点 即 这个逻辑回归单元 来预测 h(x)的值 具体来说 假设输出的 h(x)将 等于s型激励函数 g(θ0 xa0 +θ1xa1 +θ2xa2 +θ3xa3) 其中 a1 a2 a3 由这三个单元给出

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112002014.png)

为了和我之前的定义 保持一致 需要 在这里 还有这些地方都填上上标(2) 同样还要加上这些下标1 因为我只有 一个输出单元 但如果你只观察蓝色的部分 这看起来 非常像标准的 `逻辑回归模型` 不同之处在于 我现在用的是大写的θ 而不是小写的θ 这样做完 我们只得到了`逻辑回归`

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112002144.png)

但是 逻辑回归的 输入特征值 是通过隐藏层计算的 神经网络所做的 就像逻辑回归 但是它 不是使用 x1 x2 x3作为输入特征 而是用a1 a2 a3作为新的输入特征 同样 我们需要把
上标加上来和之前的记号保持一致

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112002632.png)

有趣的是 特征项a1 a2 a3它们是作为 输入的函数来学习的 具体来说 就是从第一层 映射到第二层的函数 这个函数由其他 一组参数θ(1)决定 所以 在神经网络中 它没有用 输入特征x1 x2 x3 来训练逻辑回归 而是自己 训练逻辑回归 的输入 a1 a2 a3 可以想象 如果 在θ1中选择不同的参数 有时可以学习到一些 很有趣和复杂的特征 就可以 得到一个 更好的假设 比使用原始输入 x1 x2或x3时得到的假设更好 你也可以 选择多项式项 x1 x2 x3等作为输入项 但这个算法可以 **灵活地 快速学习任意的特征项**

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112003647.png)

我觉得现在描述的这个例子 有点高端 所以 我不知道 你是否能理解 这个具有更复杂特征项的 神经网络 但是 如果你没理解 在接下来的两个视频里 我会讲解一个具体的例子 它描述了怎样用神经网络 如何利用这个隐藏层 计算更复杂的特征 并输入到最后的输出层 以及为什么这样就可以学习更复杂的假设 所以 如果我 现在讲的 你没理解 请继续 观看接下来的两个视频 希望它们 提供的例子能够 让你更加理解神经网络 但有一点 你还可以用其他类型的图来 表示神经网络 神经网络中神经元 相连接的方式 称为`神经网络的架构` 所以说 `架构`是指 **不同的神经元是如何相互连接的** 这里有一个不同的 神经网络架构的例子

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112004927.png)

你可以 意识到这个第二层 是如何工作的 在这里 我们有三个隐藏单元 它们根据输入层 计算一个复杂的函数 然后第三层 可以将第二层 训练出的特征项作为输入 并在第三层计算一些更复杂的函数 这样 在你到达 输出层之前 即第四层 就可以利用第三层 训练出的更复杂的 特征项作为输入 以此得到非常有趣的非线性假设

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112005012.png)

顺便说一下 在这样的 网络里 第一层 被称为输入层 第四层 仍然是我们的输出层 这个网络有两个隐藏层 所以 任何一个不是 输入层或输出层的 都被称为隐藏层

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112005052.png)

我希望从这个视频中 你已经大致理解 **`前向传播`在神经网络里的工作原理**： 从输入层的激励 开始 向前 传播到 第一隐藏层 然后传播到第二 隐藏层 最终到达输出层 并且你也知道了如何 向量化这些计算

我发现 这个视频里我讲了 某些层是如何 计算前面层的复杂特征项 我意识到这可能 仍然有点抽象 显得比较高端 所以 我将 在接下来的两个视频中 讨论具体的例子 它描述了怎样用神经网络 来计算 输入的非线性函数 希望能使你 更好的理解 从神经网络中得到的复杂非线性假设



## 8.5 特征和直观理解1

在接下来两节视频中 我要通过讲解 一个具体的例子来解释 神经网络是如何计算 关于输入的复杂的`非线性函数` 希望这个例子可以 让你了解为什么 神经网络可以用来学习复杂的非线性假设

考虑下面的问题 我们有二进制的 输入特征 x1 x2 要么取0 要么取1 所以x1和x2只能 有两种取值

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112145858.png)

在这个例子中 我只画出了 两个正样本和 两个负样本 但你可以认为这是一个 更复杂的学习问题的 简化版本 在这个复杂问题中 我们可能 在右上角有一堆**正样本（红色叉叉）** 在左下方有 一堆用**圆圈表示的负样本**

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150052.png)

我们想要学习一种非线性的 决策边界来 区分正负样本 那么 神经网络是 如何做到的呢？

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150138.png)

为了描述方便我不用右边这个例子 我用左边这个例子 这样更容易说明 具体来讲 这里需要计算的是 `目标函数y` 等于**x1异或x2** 或者 y也可以等于 x1**异或非**x2 其中异或非表示 **x1异或x2后取反** X1异或X2 为真当且仅当 这两个值 X1或者X2中有且仅有一个为1 如果我 用XNOR作为例子 比用NOT作为例子 结果会好一些 但这两个其实是相同的 这就意味着在x1 异或x2后再取反 即 **当它们同时为真 或者同时为假的时候 我们将获得 y等于1的结果**

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150441.png)


如果它们中**仅有一个 为真 y则为0**

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150535.png)

我们想要知道是否能 找到一个神经网络模型来拟合这种训练集

为了建立 能拟合`XNOR运算` 的神经网络 我们先 讲解一个稍微简单 的神经网络 它拟合了`“且运算”`

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150741.png)

假设我们 有输入x1和 x2 并且都是二进制 即要么为0要么为1 我们的`目标函数y`正如你所知道的 等于`x1且x2` 这是一个`逻辑与`

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150855.png)

那么 我们怎样得到一个 具有单个神经元的神经网络来计算 这个逻辑与呢 为了做到这一点 我也需要画出`偏置单元` 即这个里面有个`+1的单元`

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112150954.png)

现在 让我给这个网络 分配一些权重 或参数 我在图上写出这些参数 这里是-30 正20 正20 即我给 x0前面的 系数赋值 为-30. 这个正1会 作为这个单元的值 关于20的参数值 且x1乘以+20 以及x2乘以+20 都是这个单元的输入

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151059.png)

所以 我的假设ħ(x) 等于 g(-30 + 20x1 + 20x2) 在图上画出 这些参数和 权重是很方便很直观的 其实 在这幅神经网络图中 这个-30 其实是θ(1)10 这个是 θ(1)11 这是 θ(1)12 但把它想成 这些边的 权重会更容易理解

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151204.png)

让我们来看看这个小神经元是怎样计算的 回忆一下 s型 激励函数g(z)看起来是这样的 它从0开始 光滑 上升 穿过0.5 渐进到1.

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151258.png)

我们给出一些坐标 如果横轴值 z等于4.6 则 S形函数等于0.99 这是非常接近 1的 并且由于对称性 如果z为-4.6 S形函数 等于0.01 非常接近0

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151412.png)

让我们来看看四种可能的输入值 x1和x2的四种可能输入 看看我们的假设 在各种情况下的输出 如果X1和X2均为 0 那么 你看看这个 如果 x1和x2都等于 为0 则假设会输出g(-30) g(-30)在图的 很左边的地方 非常接近于0

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151716.png)

如果x1等于0且 x2等于1 那么 此公式等于 g关于 -10取值 也在很左边的位置 所以 也是非常接近0 这个也是g(-10) 也就是说 如果x1 等于1并且 x2等于0 这就是-30加20等于-10 最后 如​​果 x1等于1 x2等于 1 那么这等于 -30 +20 +20 所以这是 取+10时 非常接近1

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112151844.png)

如果你看看 在这一列 这就是 逻辑“与”的计算结果 所以 这里得到的h h关于x取值 近似等于x1和x2的与运算的值 换句话说 假设输出 1 当且仅当 x1 x2 都等于1 所以 通过写出 这张真值表 我们就弄清楚了 神经网络 计算出的逻辑函数

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152000.png)

这里的神经网络 实现了或函数的功能 接下来我告诉你是怎么看出来的 如果你把 假设写出来 会发现它等于 g关于-10 +20x1 +20x2的取值 如果把这些值都填上 会发现 这是g(-10) 约等于0 这是g(10) 约等于1 这个也约等于1

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152137.png)

这些数字 本质上就是逻辑或 运算得到的值

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152206.png)

所以 我希望 通过这个例子 你现在明白了 神经网络里单个的 神经元在计算 如AND和OR逻辑运算时是怎样发挥作用的 在接下来的视频中 我们将继续 讲解一个更复杂的例子 我们将告诉你 一个多层的神经网络 怎样被用于 计算更复杂的函数  如 XOR 函数或 XNOR 函数


## 8.6 样本和直观理解II

在这段视频中 我想通过例子来向大家展示 一个神经网络 是怎样计算`非线性的假设函数`

在上一段视频中 我们学习了 怎样运用神经网络 来计算x1和x2的`与运算` 以及x1和x2的`或运算` 其中x1和x2都是二进制数 也就是说 它们的值只能为0或1 同时 我们也学习了 怎样进行`逻辑非`运算 也就是计算 "非x1" 我先写出这个神经网络中 相连接的各权值 这里我们只有一个输入量x1 在这里我们也加上了 表示`偏差的单位元` +1 如果我将输入单元和两个权数相连 也就是+10和-20 则可用以下假设方程来计算 `h(x)=g(10-20x1)` 其中`g`是一个`S型函数`

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152619.png)

那么 当x1等于0时 计算出假设函数 g(10-20*0) 也就是g(10) 这个值近似的等于1 而当x等于1时 计算出的假设函数则变成 g(-10) 也就是约等于0 如果你观察这两个值 你会发现这实际上计算的 就是“非x1”函数

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152711.png)

所以要计算`逻辑非运算` 总体思路是 在你希望**取非运算的变量前面 放上一个绝对值大的负数作为权值** 因此 如果放一个-20 那么和x1相乘 很显然 最终的结果 就得到了对x1进行非运算的效果

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112152935.png)

另外 我再给出一个例子 计算这样一个函数 `(非x1)与(非x2)` 我希望大家思考一下 自己动手算一算 你大概应该知道 至少应该**在x1和x2前面 放一个绝对值比较大的负数作为权值** 不过 还有一种可行的方法 是**建立一个神经网络来计算 用只有一个输出单元的神经网络** 没问题吧？ 因此 这个看起来很长的逻辑函数 “(非x1)与(非x2)”的值 将等于1 当且仅当 x1等于x2等于0 所以 这是个逻辑函数 这里是非x1 也就是说x1必为0 然后是非x2 这表示x2也必为0 因此这个逻辑函数等于1 当且仅当 x1和x2的值都为0时成立

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153132.png)

现在你应该也清楚了 怎样建立一个小规模的神经网络 来计算 这个逻辑函数的值

把以上我们介绍的 这三个部分内容放在一起 "x1与x2"与运算的网络 以及计算 "(非x1)与(非x2)"的网络 还有最后一个是 "x1或x2"的或运算网络 把这三个网络放在一起 我们就应该能计算 "x1 XNOR x2" 也就是`同或门运算`

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153229.png)

提醒一下 如果这是x1 x2 那么我们想要计算的这个函数 在这里和这里是负样本 而在这里和这里 函数有正样本值 那么很显然 为了分隔开正样本和负样本 我们需要一个`非线性的判别边界`

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153334.png)

这里我们用以下这个网络来解决 取输入单元 +1 x1和x2 建立第一个隐藏层单元 我们称其为a(2)1 因为它是第一个隐藏单元 接下来我要从红色的网络 也就是"x1与x2"这个网络 复制出权值 也就是-30 20 20 接下来 我再建立第二个隐藏单元 我们称之为a(2)2 它是第二层的第二个隐藏单元 然后再从中间的青色网络中 复制出权值 这样我们就有了 10 -20 -20 这样三个权值

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153443.png)

因此 我们来看一下真值表中的值 对于红色的这个网络 我们知道是x1和x2的与运算 所以 这里的值大概等于0 0 0 1 这取决于x1和x2的具体取值

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153548.png)

对于a (2)2 也就是青色的网络 我们知道这是“(非x1)与(非x2)”的运算 那么对于x1和x2的四种取值 其结果将为 1 0 0 0

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153638.png)

最后 建立输出节点 也就是输出单元 a(3)1 这也是等于输出值h(x) 然后 复制一个或运算网络 同时 我需要一个+1作为偏差单元 将其添加进来 然后从绿色的网络中复制出所有的权值 也就是-10 20 20

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153733.png)

我们之前已经知道这是一个`或运算`函数 那么我们继续看真值表的值 第一行的值是0和1的或运算 其结果为1 然后是0和0的或运算 其结果为0 0和0的或运算 结果还是0 1和0的或运算 其结果为1

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153836.png)

因此 h(x)的值等于1 当x1和x2都为0 或者x1和x2都为1的时候成立 具体来说 在这两种情况时 h(x)输出1 在另两种情况时 h(x)输出0 那么对于这样一个神经网络 有一个输入层 一个隐藏层 和一个输出层 我们最终得到了 计算`XNOR函数`的`非线性判别边界`

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112153940.png)

更一般的理解是 在输入层中 我们只有原始输入值 然后我们建立了一个隐藏层 用来计算稍微复杂一些的 输入量的函数 如图所示 这些都是稍微复杂一些的函数 然后 通过添加另一个层 我们得到了一个更复杂一点的函数 这就是关于 神经网络可以计算较复杂函数 的某种直观解释

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112154036.png)

我们知道 当层数很多的时候 你有一个相对简单的输入量的函数 作为第二层 而第三层可以建立在此基础上 来计算更加复杂一些的函数 然后再下一层 又可以计算再复杂一些的函数

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112154119.png)

在这段视频的最后 我想给大家展示一个有趣的例子 这是一个神经网络 通过运用更深的层数 来计算更加复杂函数的例子 我将要展示的这段视频 来源于我的一个好朋友 阳乐昆(Yann LeCun) Yann是一名教授 供职于纽约大学 他也是神经网络研究 早期的奠基者之一 也是这一领域的大牛 他的很多理论和想法 现在都已经被应用于 各种各样的产品和应用中 遍布于全世界 所以我想向大家展示一段 他早期工作中的视频 这段视频中 他使用神经网络的算法 进行`手写数字的辨识`

你也许记得 在这门课刚开始的时候 我说过 关于神经网络的一个早期成就 就是应用神经网络 读取邮政编码 以帮助我们进行邮递 那么这便是其中一种尝试 这就是为了解决这个问题 而尝试采用的一种算法

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112154302.png)

在视频中 这个区域 是输入区域 表示的是手写字符 它们将被传递给神经网络 这一列数字表示 通过该网络第一个隐藏层运算后 特征量的可视化结果 因此通过第一个隐藏层 可视化结果显示的是 探测出的不同特征 不同边缘和边线

这是下一个隐藏层的可视化结果 似乎很难看出 怎样理解更深的隐藏层 以及下一个隐藏层 计算的可视化结果 可能你如果要想看出到底在进行怎样的运算 还是比较困难的 最终远远超出了第一个隐藏层的效果 但不管怎样 最终这些学习后的特征量 将被送到最后一层 也就是输出层 并且在最后作为结果 显示出来 最终预测到的结果 就是这个神经网络辨识出的手写数字的值 下面我们来观看这段视频

我希望你 喜欢这段视频 也希望这段视频能给你一些直观的感受 关于神经网络可以学习的 较为复杂一些的函数 在这个过程中 它使用的输入是不同的图像 或者说 就是一些原始的像素点 第一层计算出一些特征 然后下一层再计算出 一些稍复杂的特征 然后是更复杂的特征 然后这些特征 实际上被最终传递给 最后一层`逻辑回归分类器`上 使其准确地预测出 神经网络“看”到的数字

## 8.7 多类分类

在这段视频中 我想和大家谈谈 如何用神经网络做`多类别分类` 在多类别分类中 通常有不止一个类别 需要我们去区分 在上一段视频最后 我们提到了有关 手写数字辨识的问题 这实际上正是一个 多类别分类的问题 因为辨识数字 从0到9 正好是10个类别 因此你也许已经想问 究竟应该怎样处理这个问题

我们处理`多类别分类`的方法 实际上是基于`一对多神经网络算法` 而延伸出来的

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155020.png)

让我们来看这样一个例子 还是有关计算机视觉的例子 就像我之前介绍过的 识别汽车的例子 但与之不同的是 现在我们希望处理的 是四个类别的分类问题 给出一幅图片 我们需要确定图上是什么 是一个行人 一辆汽车 还是一辆摩托车 亦或是一辆卡车 对于这样一个问题 我们的做法是 建立一个具有四个输出单元的神经网络 也就是说 此时神经网络的输出 是一个`四维向量`

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155134.png)

因此 现在的输出 需要用一个向量来表示 这个向量中有四个元素 而我们要做的 是对第一个输出元素 进行分辨 图上是不是一个行人 然后对第二个元素 分辨它是不是一辆汽车 同样 第三个元素 是不是摩托车 第四个元素 是不是一辆卡车 因此 当图片上是一个行人时 我们希望这个神经网络 输出1 0 0 0 当图片是一辆轿车时 我们希望输出是 0 1 0 0 当图片是一辆摩托车时 我们希望结果是0 0 1 0 以此类推

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155231.png)

所以 这和我们介绍逻辑回归时 讨论过的一对多方法 其实是一样的 只不过现在我们有 四个逻辑回归的分类器 而我们需要对 四个分类器中每一个 都分别进行识别分类 因此 重新整理一下这页讲义 这是我们的神经网络结构 有四个输出单元

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155343.png)


这是针对不同的图片 我们h(x)的表达式 此时 我们需要用如下的方法 来表示训练集 在这个例子中 当我们要表征一个 具有行人 汽车 摩托车和卡车 这样四个不同图片作为元素的训练集时 我们应该怎么做呢 之前 我们把`标签`写作一个整数 用y来表示 1 2 3 4 现在我们不这样表示y 而是用以下的方法来代表y 那就是 y(i) 表示1 0 0 0 或者0 1 0 0 或者0 0 1 0 或者0 0 0 1 根据相对于的图片x(i)来决定 这样 我们的训练样本 将成为 x(i) y(i) 这一对数 其中 x(i)表示我们已知的 四种物体图像中的一个 而y(i)是这四个向量中的某一个

![](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/20181112155552.png)

我们希望 能够找到某种方法 让我们的神经网络输出某个值 因此 h(x) 近似约等于y 在我们的例子中 h(x) 和 y(i) 它们都应该是四维向量 因为我们有四个类别

这样我们就讨论了 怎样基于我们的假设表达式 来表征神经网络 在接下来几节课中 我们会开始讨论 怎样得到`训练集` 以及怎样**自动学习神经网络的参数**

