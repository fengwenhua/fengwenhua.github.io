---
title: '第一章: Model and Cost Function'
date: 2018-11-14 20:17:43
mathjax: true
tags:
- Cost Function
- 代价函数
categories:
- 机器学习
- 机器学习入门
---


## Model Representation:模型表示
* 我们的第一个学习算法是`线性回归算法`,了解监督学习过程完整的流程

### 例子
* 这个例子是预测住房价格的 我们要使用一个数据集 数据集包含俄勒冈州波特兰市的住房价格 在这里 我要根据不同房屋尺寸所售出的价格 画出我的数据集

![_1526486337_877822591_1539943286_1526486337_877822591.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486337_877822591_1539943286)
<!-- more -->
* 比方说 我们来看这个数据集 你有一个朋友正想出售自己的房子 如果你朋友的房子是1250平方尺大小 你要告诉他们 这房子能卖多少钱 那么 你可以**做的一件事就是 构建一个模型** 也许是条直线 从这个数据模型上来看 也许你可以告诉你的朋友 他能以大约220000(美元)左右的价格 卖掉这个房子 那么这就是监督学习算法的一个例子

![_1526486364_1763509138_1539943339_1526486364_1763509138.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486364_1763509138_1539943339)

* 它被称作监督学习是因为对于每个数据来说 我们给出了 “`正确的答案`” 即告诉我们 根据我们的数据来说 房子实际的价格是多少 而且 更具体来说 这是一个`回归问题` **回归一词指的是我们根据之前的数据预测出一个准确的输出值** 对于这个例子就是**价格**
* 同时 还有另一种最常见的监督学习方式 叫做`分类问题` **当我们想要预测离散的输出值** 例如 如果我们正在寻找 癌症肿瘤并想要确定 肿瘤是良性的还是恶性的 这就是0/1离散输出的问题
* 更进一步来说 **在监督学习中我们有一个数据集 这个数据集被称**`训练集` 因此对于房价的例子 我们有一个训练集 包含不同的房屋价格 我们的任务就是从这个数据中学习预测房屋价格
*  现在我们给出这门课中经常使用的一些符号定义 我们要定义颇多符号 不过没关系 现在你记不住所有的符号也没关系 随着课程的进展 你会发现记住这些符号会很有用 我将在整个课程中用小写的

![_1526486393_1037348134_1539943381_1526486393_1037348134.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486393_1037348134_1539943381)

*  `m`:**来表示训练样本的数目** 因此 在这个数据集中 如果表中有47行 那么我们就有47组训练样本 m就等于47
*  `x`**来表示输入变量 往往也被称为特征量** 这就是用x表示输入的特征
*  `y`**来表示输出变量或者目标变量** 也就是我的**预测结果** 那么这就是第二列
*  在这里使用`(x, y)`来表示一个`训练样本` 所以 在这个表格中的单独的一行对应于一个训练样本
*  `表示某个训练样本` 我将使用`x上标(i)`与`y上标(i)`来表示 ,即![_1526486414_196120304_1539943435_1526486414_196120304.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486414_196120304_1539943435)

* 这就是一个监督学习算法的工作方式 我们可以看到这里有我们的训练集里房屋价格 我们把它喂给我们的学习算法 这就是学习算法的工作了 然后输出一个函数 按照惯例 通常表示为小写h `h代表hypothesis(假设)` **h表示一个函数** 输入是房屋尺寸大小 就像你朋友想出售的房屋 因此 h 根据输入的 x 值来得出 y 值 y值对应房子的价格 因此 **h是一个从x到y的函数映射**

![_1526486441_1477225763_1539943461_1526486441_1477225763.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486441_1477225763_1539943461)

*  人们经常问我为什么这个函数被称作`假设(hypothesis) `你们中有些人可能知道`hypothesis`的意思 从字典或者其它什么方式可以查到 其实在机器学习中 这是一个在早期被用于机器学习的名称 它有点绕口 对这类函数来说 这可能不是一个很恰当的名字 对表示从房屋的大小到价格的函数映射 我认为这个词"hypothesis" 可能不是最好的名称 但是这是人们在机器学习中使用的标准术语 所以不用太纠结人们为什么这么叫它
*  **当设计学习算法的时候 我们接下来需要去思考的是 怎样得到这个假设h**
*  对于这一点在接下来的几个视频中 我将选择最初的使用规则 h代表hypothesis 我们将会这么写![_1526486475_1276561196_1539943500_1526486475_1276561196.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486475_1276561196_1539943500)为了方便 有时非书面形式也可以这么写 `hθ(x)` 我就写成`h(x)` 这是缩写方式 但一般来说我会保留这个下标θ 从这个图片中 所有这一切意味着我们要预测一个关于x的 线性函数 y 对吧? 所以这就是**数据集和函数的作用:`用来预测`** 这里是y关于x的线性函数 `hθ(x)=θ0+θ1*x`

![_1526486492_526471029_1539943529_1526486492_526471029.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486492_526471029_1539943529)

*  那么为什么是一个线性函数呢? 有时候 我们会有更复杂的函数 也许是非线性函数 但是 由于线性方程是简单的形式 我们将先从线性方程的例子入手 当然 最终我们将会建立更复杂的模型 以及更复杂的学习算法 好吧 让我们也给这模型 起一个名字 这个模型被称为`线性回归(linear regression)模型` 另外 这实际上是关于单个变量的线性回归 这个变量就是x 根据x来预测所有的价格函数 同时 对于这种模型有另外一个名称 称作`单变量线性回归` 单变量是对一个变量的一种 特别的表述方式 总而言之 这就是线性回归 在接下来的视频中 我们将开始讨论如何去实现这种模型

### 笔记--Model Representation模型表示
* 为了建立将来使用的符号，我们将使用 `x^i`来表示`“输入”变量`（在这个例子中是居住区域），也被称为`输入要素`，而 `y^i` 表示我们试图`预测的“输出”或目标变量`（价格）。一对 `(x^i，y^i) `被称为`训练样例`，我们将用来学习的`数据集----m`个训练样例的列表`(x^i，y^i)`;i= 1，。 。 。 ，`m`---- 被称为`训练集`。请注意，符号中的上标“（`i`）”仅仅是训练集的`索引`，与幂运算无关。我们也将用`X`来表示`输入值的空间`，用`Y`来表示`输出值的空间`。在这个例子中，X = Y =ℝ。
* 为了更形式化地描述监督学习问题，我们的目标是在给定训练集的情况下，去学习一个函数`h：X→Y`，使得`h（x）`是`y`的相应值的`“好”预测器`。由于历史原因，这个函数`h`被称为`假设`。从形象上看，这个过程是这样的：

![_1526486547_637097161_1539943596_1526486547_637097161.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486547_637097161_1539943596)

* 当我们试图预测的目标变量是`连续的`，比如在我们的住房例子中，我们把学习问题称为`回归问题`。当y只能接受少量的`离散值`时（比如，如果考虑到居住面积，我们想要预测一个住宅是房子还是公寓），我们称之为`分类问题`。

## Cost Function(代价函数)
* 这里将定义`代价函数`的概念 这有助于我们 `弄清楚如何把最有可能的直线与我们的数据相拟合`
* 在线性回归中我们有一个像这样的训练集 记住` M代表了训练样本的数量` 所以 比如说`M = 47` 而我们的假设函数 也就是用来进行预测的函数 是这样的线性函数形式![_1526486475_1276561196_1539943500_1526486475_1276561196.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486475_1276561196_1539943500)

* 接下来我们会引入一些术语 这些`θ0`和`θ1` 这些θi我把它们称为`模型参数` 在这个视频中 我们要做的就是**谈谈如何选择这两个参数值θ0和θ1**

![_1526486641_873314729_1539943679_1526486641_873314729.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486641_873314729_1539943679)


* 选择不同的参数θ0和θ1 我们会得到不同的假设函数，如果θ0是1.5 θ1是0 那么假设函数会看起来是这样， 因为你的假设函数是`h(x)=1.5+0*x` 是这样一个常数函数 恒等于1.5 如果θ0=0并且θ1=0.5 那么假设会看起来像这样 它会通过点(2,1) 这样你又得到了h(x) 或者hθ(x) 但是有时我们为了简洁会省略θ 因此 h(x)将等于0.5倍的x 就像这样 最后 如果θ0=1并且θ1=0.5 我们最后得到的假设会看起来像这样 让我们来看看 它应该通过点(2,2) 这是我的新的h(x)或者写作hθ(x) 对吧？ 你还记得之前我们提到过·hθ(x)的 但作为简写 我们通常只把它写作h(x)·

![_1526486670_715550732_1539943705_1526486670_715550732.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486670_715550732_1539943705)

*  在线性回归中 我们有一个训练集 可能就像我在这里绘制的 **我们要做的就是 得出θ0 θ1这两个参数的值 来让假设函数表示的直线 尽量地与这些数据点很好的拟合** 也许就像这里的这条线一样

![_1526486709_1177455732_1539943731_1526486709_1177455732.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486709_1177455732_1539943731)


*  那么我们如何得出θ0 θ1的值 来使它很好地拟合数据的呢？**我们的想法是 我们要选择 能使h(x) 也就是 输入x时我们预测的值 最接近该样本对应的y值的参数θ0 θ1**所以 在我们的训练集中我们会得到一定数量的样本 我们知道x表示卖出哪所房子 并且知道这所房子的实际价格 所以 我们要尽量选择参数值 使得 在训练集中 给出训练集中的x值 我们能合理准确地预测y的值
*  让我们给出标准的定义 `在线性回归中 我们要解决的是一个最小化问题 所以我要写出关于θ0 θ1的最小化 而且 我希望这个式子极其小 是吧 我想要h(x)和y之间的差异要小 我要做的事情是尽量减少假设的输出与房子真实价格 之间的差的平方`

![_1526486729_441195085_1539943756_1526486729_441195085.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486729_441195085_1539943756)

* 接下来我会详细的阐述 别忘了 我用符号( x(i),y(i) )代表第i个样本 所以我想要做的是**对所有训练样本进行一个求和** 对i=1到i=M的样本 将对假设进行预测得到的结果 此时的输入是第i号房子的面积 对吧 将第i号对应的预测结果 减去第i号房子的实际价格 所得的差的平方相加得到总和 而我希望尽量减小这个值 也就是`预测值和实际值的差的平方误差和` 或者说预测价格和 实际卖出价格的差的平方 我说了这里的m指的是训练集的样本容量 对吧 这个`井`号是`训练样本“个数”`的缩写 对吧

![_1526486765_95100177_1539943786_1526486765_95100177.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486765_95100177_1539943786)

* 而为了让表达式的数学意义 变得容易理解一点 我们实际上考虑的是 这个数的`1/m` 因此我们要尝试尽量减少我们的平均误差 也就是**尽量减少其1/2m** 通常是这个数的一半 前面的这些只是为了使数学更直白一点 因此对这个求和值的二分之一求最小值 应该得出相同的θ0值和相同的θ1值来 请大家一定弄清楚这个道理 没问题吧？在这里hθ(x)的这种表达 这是我们的假设 它等于θ0加上θ1与x(i)的乘积 而这个表达 表示关于θ0和θ1的最小化过程 这意味着我们要找到θ0和θ1 的值来使这个表达式的值最小 这个表达式因θ0和θ1的变化而变化对吧？ 因此 简单地说 我们正在把这个问题变成 `找到能使 我的训练集中预测值和真实值的差的平方的和 的1/2M最小的θ0和θ1的值` 因此 这将是我的线性回归的整体目标函数

![_1526486784_343575659_1539943825_1526486784_343575659.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486784_343575659_1539943825)

* 为了使它更明确一点 我们要改写这个函数 按照惯例 我要定义一个`代价函数` 正如屏幕中所示 这里的这个公式 我们想要做的就是`关于θ0和θ1 对函数J(θ0,θ1)求最小值` 这就是我的代价函数 `代价函数也被称作平方误差函数` 有时也被称为 `平方误差代价函数`

![_1526486807_2121076322_1539943869_1526486807_2121076322.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486807_2121076322_1539943869)

* 事实上 我们之所以要求出 误差的平方和 是因为`误差平方代价函数 对于大多数问题 特别是回归问题 都是一个合理的选择` 还有其他的代价函数也能很好地发挥作用 但是平方误差代价函数可能是解决回归问题最常用的手段了 在后续课程中 我们还会谈论其他的代价函数 但我们刚刚讲的选择是对于大多数线性回归问题非常合理的 好吧 所以这是代价函数 到目前为止 我们已经 介绍了代价函数的数学定义 也许这个函数`J(θ0,θ1)`有点抽象 可能你仍然不知道它的内涵 在接下来的几个视频里 我们要更进一步解释 代价函数J的工作原理 并尝试更直观地解释它在计算什么 以及我们使用它的目的

### Cost Function(代价函数)笔记
* 我们可以`通过使用代价函数来衡量我们的假设函数的准确性`。 这个假设的所有结果的平均差异（实际上是一个平均值的更漂亮的版本）与来自x的输入和实际输出y的输入。

![_1526486842_1687157529_1539943891_1526486842_1687157529.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486842_1687157529_1539943891)

* To break it apart，结果是![_1526486856_1339445624_1539944023_1526486856_1339445624.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486856_1339445624_1539944023)，其中![_1526486875_1819812278_1539944058_1526486875_1819812278.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486875_1819812278_1539944058)是 $h_\theta(x_i)-y_i$  平方的平均值，或`预测值与实际值之间的差值`。
* 该函数被称为“`平方误差函数(Squared error function)`”或“`均方误差(Mean squared error)`”。 **由于平方函数的导数项将抵消该项，平均值被减半以作为计算梯度下降的便利**。 以下图片总结了成本函数的作用：

![_1526486916_672453545_1539944069_1526486916_672453545.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486916_672453545_1539944069)

## Cost Function - Intuition I
* 在上一个视频中 我们给了代价函数一个数学上的定义 在这个视频里 让我们通过一些例子来获取一些直观的感受 看看代价函数到底是在干什么 回顾一下 这是我们上次所讲过的内容 我们想找一条直线来拟合我们的数据 所以我们用 θ0 θ1 等参数 得到了这个假设 而且通过选择不同的参数 我们会得到不同的直线拟合 所以拟合出的数据就像这样 然后我们还有一个代价函数 这就是我们的优化目标

![_1526486985_1746525095_1539944106_1526486985_1746525095.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526486985_1746525095_1539944106)

* 在这个视频里 为了更好地 将代价函数可视化 我将使用一个简化的假设函数 就是下面这个函数 然后我将会用这个简化的假设 也就是 `θ1*x` 我们可以将这个函数看成是 把 `θ0 设为0` 所以我只有一个参数 也就是 `θ1` 代价函数看起来与之前的很像 唯一的区别是现在 h(x) 等于 `θ1*x` 只有一个参数 θ1 所以我的 优化目标是将 `J(θ1)`最小化 用图形来表示就是 如果 `θ0` 等于零 也就意味这我们选择的假设函数 会经过原点 也就是经过坐标 (0,0) 通过利用简化的假设得到的代价函数

![_1526487023_1285650805_1539944167_1526487023_1285650805.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487023_1285650805_1539944167)

*   我们可以试着更好地理解 代价函数这个概念 我们要理解的是这两个重要的函数 第一个是假设函数 第二个是代价函数 注意这个假设函数 h(x) 对于一个固定的 θ1 ，h(x)是关于 x 的函数 所以这个假设函数就是一个关于 x 这个房子大小的函数 与此不同的是 代价函数 J 是一个关于参数 θ1 的函数 而 θ1 控制着这条直线的斜率
*   现在我们把这写函数都画出来 试着更好地理解它们 我们从假设函数开始 比如说这里是我的**训练样本 它包含了三个点 (1,1) (2,2) 和 (3,3)** 现在我们随便选择一个值 θ1 ，这里**选择 θ1 等于1** ，选择 θ1=1之后， 那么我的假设函数看起来就会像是这条直线 我将要指出的是 **当我想要描绘出我的假设函数时， 我的横轴被标定为X轴 X轴是表示房子大小的量 现在暂时把 θ1 定为1 我想要做的就是 算出在 θ1 等于 1 的时候 J(θ1) 等于多少**

![_1526487060_1394238758_1539944241_1526487060_1394238758.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487060_1394238758_1539944241)

*   所以我们 按照这个思路来计算代价函数的大小 和之前一样 代价函数定义如下 是吧 对这个误差平方项进行求和 这就等于 这样一个形式 简化以后就等于 三个0的平方和 当然还是0

![_1526487093_1136770439_1539944268_1526487093_1136770439.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487093_1136770439_1539944268)

*   现在 在代价函数里 我们发现所有这些值都等于0 因为**对于我所选定的这三个训练样本 ( 1 ,1 ) (2,2) 和 (3,3) 如果 θ1 等于 1 那么 h(x(i)) 就会正好等于 y(i) 所以 `h(x) - y` 所有的这些值都会等于零** 这也就是为什么**J(1) 等于零**
*   所以 我们现在知道了 J(1) 是0 让我把这个画出来 我将要在屏幕右边画出我的代价函数 J 要注意的是 因为我的代价函数是关于参数 θ1 的函数 当我描绘我的**代价函数时 X轴就是 θ1** 现在我有 **J(1) 等于零** 让我们继续把函数画出来 结果我们会得到这样一个点

![_1526487138_631239648_1539944315_1526487138_631239648.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487138_631239648_1539944315)

*   现在我们来看其它一些样本 θ1 可以被设定为 某个范围内各种可能的取值 所以 θ1 可以取负数 0 或者正数 所以如果 `θ1 等于0.5`会发生什么呢 继续把它画出来 现在要把 θ1 设为0.5 在这个条件下 我的假设函数看起来就是这样 这条线的斜率等于0.5 现在让我们计算 J(0.5) 所以这将会等于1除以2m 乘以那一块 其实我们不难发现后面的求和 就是这条线段的高度的平方 加上这条线段高度的平方 再加上这条线段高度的平方 三者求和 对吗？ 就是 y(i) 与预测值 h(x(i)) 的差 对吗 所以第一个样本将会是0.5减去1的平方 因为我的假设函数预测的值是0.5 而实际值则是1 第二个样本 我得到的是1减去2的平方 因为我的假设函数预测的值是1 但是实际房价是2 最后 加上 1.5减去3的平方 那么这就等于1除以2乘以3 因为训练样本有三个点所以 m 等于3 对吧 然后乘以括号里的内容 简化后就是3.5 所以这就等于3.5除以6 也就约等于0.68

![_1526487160_1122698449_1539944357_1526487160_1122698449.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487160_1122698449_1539944357)

*   让我们把这个点画出来 不好意思 有一个计算错误 `这实际上该是0.58` 所以我们把点画出来 大约会是在这里 对吗

![_1526487174_936519972_1539944425_1526487174_936519972.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487174_936519972_1539944425)

*   现在 让我们再多做一个点 让我们试试θ1等于0 J(0) 会等于多少呢 如果θ1等于0 那么 h(x) 就会等于一条水平的线 对了 就会像这样是水平的 所以 测出这些误差 我们将会得到 J(0) 等于 1除以 2m 乘以1的平方 加上2的平方 加上3的平方 也就是 1除以6乘以14 也就是2.3左右 所以让我们接着把这个点也画出来 所以这个点最后是2.3

![_1526487181_1047071511_1539944461_1526487181_1047071511.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487181_1047071511_1539944461)

* 当然我们可以接着设定 θ1 等于别的值 进行计算 你也可以把 θ1 设定成一个负数 所以如果 θ1 是负数 那么 h(x) 将会等于 打个比方说 －0.5 乘以x 然后 θ1 就是 -0.5 那么这将会 对应着一个斜率为-0.5的假设函数 而且你可以 继续计算这些误差 结果你会发现 对于0.5 结果会是非常大的误差 最后会得到一个较大的数值 类似于5.25 等等 对于不同的 θ1 你可以计算出这些对应的值 对吗 结果你会发现 你算出来的这些值 你得到一条这样的曲线 通过计算这些值 你可以慢慢地得到这条线 这就是 J(θ) 的样子了

![_1526487193_1227128932_1539944492_1526487193_1227128932.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487193_1227128932_1539944492)

* 我们来回顾一下 **任何一个 θ1 的取值对应着一个不同的 假设函数 或者说对应着左边一条不同的拟合直线。 对于任意的θ1 你可以算出一个不同的 J(θ1) 的取值** 举个例子 你知道的 θ1 等于1时对应着穿过这些数据的这条直线 当 θ1 等于0.5 也就是这个玫红色的点 也许对应着这条线 然后 θ1 等于0 也就是蓝色的这个点 对应着 这条水平的线 对吧

![_1526487236_2027776779_1539944521_1526487236_2027776779.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487236_2027776779_1539944521)

* 所以对于任意一个 θ1 的取值 我们会得到 一个不同的 J(θ1) 而且我们可以利用这些来描出右边的这条曲线 现在你还记得 **学习算法的优化目标 是我们想找到一个 θ1 的值 来将 J(θ1) 最小化** 对吗 这是我们线性回归的目标函数 嗯 看这条曲线 **让 J(θ1) 最小化的值 是 θ1 等于1 然后你看 这个确实就对应着最佳的通过了数据点的拟合直线 这条直线就是由 θ1=1 的设定而得到的 然后 对于这个特定的训练样本 我们最后能够完美地拟合 这就是为什么最小化 J(θ1) 对应着寻找一个最佳拟合直线的目标**
* 总结一下 在这个视频里 我们看到了一些图形 来理解代价函数 要做到这个 我们简化了算法 让这个函数只有一个参数 θ1 也就是说我们把 θ0 设定为0 在下一个视频里 我们将回到原来的问题的公式 然后看一些 带有 θ0 和 θ1 的图形 也就是说不把 θ0 设置为0了 希望这会让你更好地理解在原来的线性回归公式里 代价函数 J 的意义

### Cost Function - Intuition I笔记
* 如果我们试图用视觉术语来思考它，我们的训练数据集就散布在`x-y平面`上。 我们试图做一条直线（由$h_\theta(x)$定义）来穿过这些散布的数据点。
* 我们的目标是获得最佳线路。 尽可能最好的线是这样的，以便**线上散射点的平均垂直距离将是最小的**。 理想情况下，该线应该通过我们训练数据集的所有点。 在这种情况下，$J(\theta_0,\theta_1)$值将为0.以下示例显示了代价函数为0的理想情况。

![_1526487322_1703355374_1539944559_1526487322_1703355374.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487322_1703355374_1539944559)

* 当$\theta_1=1$我们得到1的斜率时，它会经历我们模型中的每个单一数据点。 相反，当$\theta_1=0.5$我们看到从适合度到数据点的垂直距离增加时。
* 这使我们的代价函数增加到0.58。 绘制几个其他点产生到以下图表：

![_1526487533_1540848643_1539944572_1526487533_1540848643.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487533_1540848643_1539944572)
* 因此，作为一个目标，我们应该尽量减少代价函数。 在这种情况下，$\theta_1=1$是我们整体最低的。

## Cost Function - Intuition II
* 这节课中 我们将更深入地学习代价函数的作用 这段视频的内容假设你已经认识轮廓图 如果你对轮廓图不太熟悉的话 这段视频中的某些内容你可能会听不懂 但不要紧 如果你跳过这段视频的话 也没什么关系 不听这节课对后续课程理解影响不大
* 和之前一样 这是我们的几个重要公式 包括了假设h、参数θ、代价函数J 以及优化目标 跟前一节视频不同的是 我还是把θ写成$\theta_0$,$\theta_1$的形式 便于这里我们要对代价函数进行的可视化

![_1526487815_1577285052_1539944607_1526487815_1577285052.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487815_1577285052_1539944607)

* 和上次一样 首先来理解假设h和代价函数J 这是**房价数据组成的训练集数据** 让我们来构建某种假设 就像这条线一样 很显然这不是一个很好的假设 但不管怎样 如果我**假设θ0等于50 θ1等于0.06的话 那么我将得到这样一个假设函数** 对应于这条直线 给出θ0和θ1的值

![_1526487858_570681900_1539944661_1526487858_570681900.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487858_570681900_1539944661)


* 我们要在右边画出代价函数的图像 上一次 我们是只有一个θ1 也就是说 画出的代价函数是关于θ1的函数 但现在我们有两个参数 θ0和θ1 因此图像就会复杂一些了 当只有一个参数θ1的时候 我们画出来是这样一个弓形函数 而现在我们有了两个参数 那么代价函数 仍然呈现类似的某种弓形 实际上这取决于训练样本

![_1526487889_1193089078_1539944694_1526487889_1193089078.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487889_1193089078_1539944694)

* 你可能会得到这样的图形 因此这是一个三维曲面图 两个轴分别表示θ0和θ1 随着你改变θ0和θ1的大小 你便会得到不同的代价函数 J(θ0,θ1) 对于某个特定的点 (θ0,θ1) 这个曲面的高度 也就是竖直方向的高度 就表示代价函数 J(θ0,θ1) 的值 不难发现这是一个弓形曲面

![_1526487921_1156596403_1539944720_1526487921_1156596403.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487921_1156596403_1539944720)

* 我们来看看三维图 这是这个曲面的三维图 水平轴是θ0、θ1 竖直方向表示 J(θ0,θ1) 旋转一下这个图 你就更能理解这个弓形曲面所表示的代价函数了 在这段视频的后半部分 为了描述方便 我将不再像这样给你用三维曲面图的方式解释代价函数J 而还是**用轮廓图来表示** .`contour plot` 或 `contour figure` 意思一样
* 下图就是一个轮廓图 两个轴分别表示 θ0 和 θ1 而这些一圈一圈的椭圆形 **每一个圈就表示 J(θ0,θ1) 相同的所有点的集合** 具体举例来说 我们选三个点出来 这三个桃红色的点 都表示相同的 J(θ0,θ1) 的值 对吧 横纵坐标分别是θ0 θ1 这三个点的 J(θ0,θ1) 值是相同的 如果你之前没怎么接触轮廓图的话 你就这么想 你就想象一个弓形的函数从屏幕里冒出来  因此**`最小值` 也就是这个弓形的最低点就是这个点 对吧 也就是这一系列同心椭圆的`中心点`** 想象一下这个弓形从屏幕里冒出来 所以这些椭圆形 都从我的屏幕上冒出相同的高度 弓形的最小值点是这个位置 因此轮廓图是一种很方便的方法 能够直观地观察 代价函数J

![_1526487962_306972773_1539944750_1526487962_306972773.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487962_306972773_1539944750)

* 接下来让我们看几个例子 在这里有一点 这个点表示**θ0等于800 θ1大概等于-0.15** 那么这个**红色的点 代表了某个 (θ0,θ1) 组成的数值组** 而这个点也对应于左边这样一条线 对吧 θ0等于800 也就是跟纵轴相交于大约800 斜率大概是-0.15 当然 这条线并不能很好地拟合数据 对吧 以这组 θ0 θ1 为参数的这个假设 h(x) 并不是数据的较好拟合 并且你也发现了 这个代价值 就是这里的这个值 距离最小值点还很远 也就是说这个代价值还是算比较大的 因此不能很好拟合数据

![_1526487994_1194723141_1539944788_1526487994_1194723141.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526487994_1194723141_1539944788)

* 让我们再来看几个例子 这是另一个假设 你不难发现 这依然不是一个好的拟合 但比刚才稍微好一点 这是我的 θ0 θ1 点 这是 **θ0 的值 大约为360 θ1 的值为0** 我们把它写下来 θ0=360 θ1=0 因此这组θ值对应的假设是 这条水平的直线 也就是**h(x) = 360 + 0 × x** 这就是`假设` 这个假设同样也有某个`代价值` 而这个**代价值就对应于这个代价函数在这一点的高度**

![_1526488011_1542676591_1539944816_1526488011_1542676591.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526488011_1542676591_1539944816)

* 最后一个例子 这个点其实不是最小值 但已经非常靠近最小值点了 这个点对数据的拟合就很不错 它对应这样两个θ0 和 θ1 的值 同时也对应这样一个 h(x) 这个点虽然不在最小值点 但非常接近了 因此误差平方和 或者说 **训练样本和假设的距离的平方和 这个距离值的平方和 非常接近于最小值** 尽管它还不是最小值

![_1526488021_554234801_1539944853_1526488021_554234801.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526488021_554234801_1539944853)

* 好的 通过这些图形 我希望你能更好地 理解这些`代价函数 J` 所表达的值 它们是什么样的 它们对应的假设是什么样的 以及什么样的假设对应的点 更接近于代价函数J的最小值 当然 我们真正需要的是一种有效的算法 能够自动地找出这些使代价函数J取最小值的参数θ0和θ1来 对吧 我想我们也不希望编个程序 把这些点画出来 然后人工的方法来读出这些点的数值 这很明显不是一个好办法 事实上 我们后面就会学到 我们会遇到更复杂、更高维度、更多参数的情况 这在我们在后面的视频中很快就会遇到 而这些情况是很难画出图的 因此更无法将其可视化 因此**我们真正需要的 是编写程序来找出这些最小化代价函数的θ0和θ1的值** 在下一节视频中 我们将介绍一种算法 能够自动地找出能使代价函数 J 最小化的参数θ0和θ1的值

### Cost Function(代价函数) - Intuition II笔记
* `轮廓图（或者叫等值线图）`是包含许多等高线的图。**两个变量函数的轮廓线在同一行的所有点上具有恒定值**。这种图的一个例子就是下面的图。

![_1526488042_674655632_1539944900_1526488042_674655632.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526488042_674655632_1539944900)

* 采取任何颜色并沿着“圆”走，人们会期望获得相同的成本函数值。例如，上面绿线上的三个绿色点对于J（θ0，θ1）具有相同的值，因此它们沿着同一条线发现。带圆圈的x显示θ0= 800和θ1= -0.15时左侧图形的成本函数值。再取一个h（x）并绘制其轮廓图（等值线图），可以得到以下图表：

![_1526488050_330535995_1539944915_1526488050_330535995.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526488050_330535995_1539944915)

* 当θ0= 360且θ1= 0时，等值线图中J（θ0，θ1）的值**更靠近中心，从而降低了代价函数误差**。现在给我们的假设函数一个稍微正向的斜率会导致更好的数据拟合。

![_1526488073_471902153_1539944930_1526488073_471902153.png](https://raw.githubusercontent.com/fengwenhua/ImageBed/master/_1526488073_471902153_1539944930)

* 上面的图尽可能地降低了成本函数，因此，θ1和θ0的结果分别趋于0.12和250左右。将我们图上的这些值绘制在右侧似乎将我们的观点**置于最内层“圈子”的中心**。







